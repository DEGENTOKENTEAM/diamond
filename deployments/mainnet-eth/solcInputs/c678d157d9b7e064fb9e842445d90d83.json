{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n        _transferOwnership(sender);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../security/Pausable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * IMPORTANT: This contract does not include public pause and unpause functions. In\n * addition to inheriting this contract, you must define both functions, invoking the\n * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\n * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\n * make the contract unpausable.\n */\nabstract contract ERC20Pausable is ERC20, Pausable {\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@solidstate/contracts/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Elliptic Curve Digital Signature Algorithm (ECDSA) operations\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nlibrary ECDSA {\n    error ECDSA__InvalidS();\n    error ECDSA__InvalidSignature();\n    error ECDSA__InvalidSignatureLength();\n    error ECDSA__InvalidV();\n\n    /**\n     * @notice recover signer of hashed message from signature\n     * @param hash hashed data payload\n     * @param signature signed data payload\n     * @return recovered message signer\n     */\n    function recover(\n        bytes32 hash,\n        bytes memory signature\n    ) internal pure returns (address) {\n        if (signature.length != 65) revert ECDSA__InvalidSignatureLength();\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        return recover(hash, v, r, s);\n    }\n\n    /**\n     * @notice recover signer of hashed message from signature v, r, and s values\n     * @param hash hashed data payload\n     * @param v signature \"v\" value\n     * @param r signature \"r\" value\n     * @param s signature \"s\" value\n     * @return recovered message signer\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n  2 + 1, and for v in (282): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (\n            uint256(s) >\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\n        ) revert ECDSA__InvalidS();\n        if (v != 27 && v != 28) revert ECDSA__InvalidV();\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) revert ECDSA__InvalidSignature();\n\n        return signer;\n    }\n\n    /**\n     * @notice generate an \"Ethereum Signed Message\" in the format returned by the eth_sign JSON-RPC method\n     * @param hash hashed data payload\n     * @return signed message hash\n     */\n    function toEthSignedMessageHash(\n        bytes32 hash\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked('\\x19Ethereum Signed Message:\\n32', hash)\n            );\n    }\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20Internal } from './IERC20Internal.sol';\n\n/**\n * @title ERC20 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-20\n */\ninterface IERC20 is IERC20Internal {\n    /**\n     * @notice query the total minted token supply\n     * @return token supply\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice query the token balance of given account\n     * @param account address to query\n     * @return token balance\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @notice query the allowance granted from given holder to given spender\n     * @param holder approver of allowance\n     * @param spender recipient of allowance\n     * @return token allowance\n     */\n    function allowance(\n        address holder,\n        address spender\n    ) external view returns (uint256);\n\n    /**\n     * @notice grant approval to spender to spend tokens\n     * @dev prefer ERC20Extended functions to avoid transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\n     * @param spender recipient of allowance\n     * @param amount quantity of tokens approved for spending\n     * @return success status (always true; otherwise function should revert)\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @notice transfer tokens to given recipient\n     * @param recipient beneficiary of token transfer\n     * @param amount quantity of tokens to transfer\n     * @return success status (always true; otherwise function should revert)\n     */\n    function transfer(\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @notice transfer tokens to given recipient on behalf of given holder\n     * @param holder holder of tokens prior to transfer\n     * @param recipient beneficiary of token transfer\n     * @param amount quantity of tokens to transfer\n     * @return success status (always true; otherwise function should revert)\n     */\n    function transferFrom(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC20Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Partial ERC20 interface needed by internal functions\n */\ninterface IERC20Internal {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
    },
    "@solidstate/contracts/security/pausable/IPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IPausableInternal } from './IPausableInternal.sol';\n\ninterface IPausable is IPausableInternal {\n    /**\n     * @notice query whether contract is paused\n     * @return status whether contract is paused\n     */\n    function paused() external view returns (bool status);\n}\n"
    },
    "@solidstate/contracts/security/pausable/IPausableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\ninterface IPausableInternal {\n    error Pausable__Paused();\n    error Pausable__NotPaused();\n\n    event Paused(address account);\n    event Unpaused(address account);\n}\n"
    },
    "@solidstate/contracts/security/pausable/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IPausable } from './IPausable.sol';\nimport { PausableInternal } from './PausableInternal.sol';\n\n/**\n * @title Pausable security control module.\n */\nabstract contract Pausable is IPausable, PausableInternal {\n    /**\n     * @inheritdoc IPausable\n     */\n    function paused() external view virtual returns (bool status) {\n        status = _paused();\n    }\n}\n"
    },
    "@solidstate/contracts/security/pausable/PausableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IPausableInternal } from './IPausableInternal.sol';\nimport { PausableStorage } from './PausableStorage.sol';\n\n/**\n * @title Internal functions for Pausable security control module.\n */\nabstract contract PausableInternal is IPausableInternal {\n    modifier whenNotPaused() {\n        if (_paused()) revert Pausable__Paused();\n        _;\n    }\n\n    modifier whenPaused() {\n        if (!_paused()) revert Pausable__NotPaused();\n        _;\n    }\n\n    /**\n     * @notice query whether contract is paused\n     * @return status whether contract is paused\n     */\n    function _paused() internal view virtual returns (bool status) {\n        status = PausableStorage.layout().paused;\n    }\n\n    /**\n     * @notice Triggers paused state, when contract is unpaused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage.layout().paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @notice Triggers unpaused state, when contract is paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        delete PausableStorage.layout().paused;\n        emit Unpaused(msg.sender);\n    }\n}\n"
    },
    "@solidstate/contracts/security/pausable/PausableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary PausableStorage {\n    struct Layout {\n        bool paused;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.Pausable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/base/ERC20Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20 } from '../../../interfaces/IERC20.sol';\nimport { IERC20Base } from './IERC20Base.sol';\nimport { ERC20BaseInternal } from './ERC20BaseInternal.sol';\nimport { ERC20BaseStorage } from './ERC20BaseStorage.sol';\n\n/**\n * @title Base ERC20 implementation, excluding optional extensions\n */\nabstract contract ERC20Base is IERC20Base, ERC20BaseInternal {\n    /**\n     * @inheritdoc IERC20\n     */\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply();\n    }\n\n    /**\n     * @inheritdoc IERC20\n     */\n    function balanceOf(address account) external view returns (uint256) {\n        return _balanceOf(account);\n    }\n\n    /**\n     * @inheritdoc IERC20\n     */\n    function allowance(\n        address holder,\n        address spender\n    ) external view returns (uint256) {\n        return _allowance(holder, spender);\n    }\n\n    /**\n     * @inheritdoc IERC20\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        return _approve(msg.sender, spender, amount);\n    }\n\n    /**\n     * @inheritdoc IERC20\n     */\n    function transfer(\n        address recipient,\n        uint256 amount\n    ) external returns (bool) {\n        return _transfer(msg.sender, recipient, amount);\n    }\n\n    /**\n     * @inheritdoc IERC20\n     */\n    function transferFrom(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) external returns (bool) {\n        return _transferFrom(holder, recipient, amount);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/base/ERC20BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20BaseInternal } from './IERC20BaseInternal.sol';\nimport { ERC20BaseStorage } from './ERC20BaseStorage.sol';\n\n/**\n * @title Base ERC20 internal functions, excluding optional extensions\n */\nabstract contract ERC20BaseInternal is IERC20BaseInternal {\n    /**\n     * @notice query the total minted token supply\n     * @return token supply\n     */\n    function _totalSupply() internal view virtual returns (uint256) {\n        return ERC20BaseStorage.layout().totalSupply;\n    }\n\n    /**\n     * @notice query the token balance of given account\n     * @param account address to query\n     * @return token balance\n     */\n    function _balanceOf(\n        address account\n    ) internal view virtual returns (uint256) {\n        return ERC20BaseStorage.layout().balances[account];\n    }\n\n    /**\n     * @notice query the allowance granted from given holder to given spender\n     * @param holder approver of allowance\n     * @param spender recipient of allowance\n     * @return token allowance\n     */\n    function _allowance(\n        address holder,\n        address spender\n    ) internal view virtual returns (uint256) {\n        return ERC20BaseStorage.layout().allowances[holder][spender];\n    }\n\n    /**\n     * @notice enable spender to spend tokens on behalf of holder\n     * @param holder address on whose behalf tokens may be spent\n     * @param spender recipient of allowance\n     * @param amount quantity of tokens approved for spending\n     * @return success status (always true; otherwise function should revert)\n     */\n    function _approve(\n        address holder,\n        address spender,\n        uint256 amount\n    ) internal virtual returns (bool) {\n        if (holder == address(0)) revert ERC20Base__ApproveFromZeroAddress();\n        if (spender == address(0)) revert ERC20Base__ApproveToZeroAddress();\n\n        ERC20BaseStorage.layout().allowances[holder][spender] = amount;\n\n        emit Approval(holder, spender, amount);\n\n        return true;\n    }\n\n    /**\n     * @notice decrease spend amount granted by holder to spender\n     * @param holder address on whose behalf tokens may be spent\n     * @param spender address whose allowance to decrease\n     * @param amount quantity by which to decrease allowance\n     */\n    function _decreaseAllowance(\n        address holder,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = _allowance(holder, spender);\n\n        if (amount > allowance) revert ERC20Base__InsufficientAllowance();\n\n        unchecked {\n            _approve(holder, spender, allowance - amount);\n        }\n    }\n\n    /**\n     * @notice mint tokens for given account\n     * @param account recipient of minted tokens\n     * @param amount quantity of tokens minted\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        if (account == address(0)) revert ERC20Base__MintToZeroAddress();\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\n        l.totalSupply += amount;\n        l.balances[account] += amount;\n\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @notice burn tokens held by given account\n     * @param account holder of burned tokens\n     * @param amount quantity of tokens burned\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        if (account == address(0)) revert ERC20Base__BurnFromZeroAddress();\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\n        uint256 balance = l.balances[account];\n        if (amount > balance) revert ERC20Base__BurnExceedsBalance();\n        unchecked {\n            l.balances[account] = balance - amount;\n        }\n        l.totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @notice transfer tokens from holder to recipient\n     * @param holder owner of tokens to be transferred\n     * @param recipient beneficiary of transfer\n     * @param amount quantity of tokens transferred\n     * @return success status (always true; otherwise function should revert)\n     */\n    function _transfer(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) internal virtual returns (bool) {\n        if (holder == address(0)) revert ERC20Base__TransferFromZeroAddress();\n        if (recipient == address(0)) revert ERC20Base__TransferToZeroAddress();\n\n        _beforeTokenTransfer(holder, recipient, amount);\n\n        ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\n        uint256 holderBalance = l.balances[holder];\n        if (amount > holderBalance) revert ERC20Base__TransferExceedsBalance();\n        unchecked {\n            l.balances[holder] = holderBalance - amount;\n        }\n        l.balances[recipient] += amount;\n\n        emit Transfer(holder, recipient, amount);\n\n        return true;\n    }\n\n    /**\n     * @notice transfer tokens to given recipient on behalf of given holder\n     * @param holder holder of tokens prior to transfer\n     * @param recipient beneficiary of token transfer\n     * @param amount quantity of tokens to transfer\n     * @return success status (always true; otherwise function should revert)\n     */\n    function _transferFrom(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) internal virtual returns (bool) {\n        _decreaseAllowance(holder, msg.sender, amount);\n\n        _transfer(holder, recipient, amount);\n\n        return true;\n    }\n\n    /**\n     * @notice ERC20 hook, called before all transfers including mint and burn\n     * @dev function should be overridden and new implementation must call super\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param amount quantity of tokens transferred\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@solidstate/contracts/token/ERC20/base/ERC20BaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ERC20BaseStorage {\n    struct Layout {\n        mapping(address => uint256) balances;\n        mapping(address => mapping(address => uint256)) allowances;\n        uint256 totalSupply;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC20Base');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/base/IERC20Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20 } from '../../../interfaces/IERC20.sol';\nimport { IERC20BaseInternal } from './IERC20BaseInternal.sol';\n\n/**\n * @title ERC20 base interface\n */\ninterface IERC20Base is IERC20BaseInternal, IERC20 {\n\n}\n"
    },
    "@solidstate/contracts/token/ERC20/base/IERC20BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20Internal } from '../../../interfaces/IERC20Internal.sol';\n\n/**\n * @title ERC20 base interface\n */\ninterface IERC20BaseInternal is IERC20Internal {\n    error ERC20Base__ApproveFromZeroAddress();\n    error ERC20Base__ApproveToZeroAddress();\n    error ERC20Base__BurnExceedsBalance();\n    error ERC20Base__BurnFromZeroAddress();\n    error ERC20Base__InsufficientAllowance();\n    error ERC20Base__MintToZeroAddress();\n    error ERC20Base__TransferExceedsBalance();\n    error ERC20Base__TransferFromZeroAddress();\n    error ERC20Base__TransferToZeroAddress();\n}\n"
    },
    "@solidstate/contracts/token/ERC20/extended/ERC20Extended.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20Extended } from './IERC20Extended.sol';\nimport { ERC20ExtendedInternal } from './ERC20ExtendedInternal.sol';\n\n/**\n * @title ERC20 safe approval extensions\n * @dev mitigations for transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\n */\nabstract contract ERC20Extended is IERC20Extended, ERC20ExtendedInternal {\n    /**\n     * @inheritdoc IERC20Extended\n     */\n    function increaseAllowance(\n        address spender,\n        uint256 amount\n    ) external returns (bool) {\n        return _increaseAllowance(spender, amount);\n    }\n\n    /**\n     * @inheritdoc IERC20Extended\n     */\n    function decreaseAllowance(\n        address spender,\n        uint256 amount\n    ) external returns (bool) {\n        return _decreaseAllowance(spender, amount);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/extended/ERC20ExtendedInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { ERC20BaseInternal, ERC20BaseStorage } from '../base/ERC20Base.sol';\nimport { IERC20ExtendedInternal } from './IERC20ExtendedInternal.sol';\n\n/**\n * @title ERC20 safe approval extensions\n * @dev mitigations for transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\n */\nabstract contract ERC20ExtendedInternal is\n    ERC20BaseInternal,\n    IERC20ExtendedInternal\n{\n    /**\n     * @notice increase spend amount granted to spender\n     * @param spender address whose allowance to increase\n     * @param amount quantity by which to increase allowance\n     * @return success status (always true; otherwise function will revert)\n     */\n    function _increaseAllowance(\n        address spender,\n        uint256 amount\n    ) internal virtual returns (bool) {\n        uint256 allowance = _allowance(msg.sender, spender);\n\n        unchecked {\n            if (allowance > allowance + amount)\n                revert ERC20Extended__ExcessiveAllowance();\n\n            return _approve(msg.sender, spender, allowance + amount);\n        }\n    }\n\n    /**\n     * @notice decrease spend amount granted to spender\n     * @param spender address whose allowance to decrease\n     * @param amount quantity by which to decrease allowance\n     * @return success status (always true; otherwise function will revert)\n     */\n    function _decreaseAllowance(\n        address spender,\n        uint256 amount\n    ) internal virtual returns (bool) {\n        _decreaseAllowance(msg.sender, spender, amount);\n\n        return true;\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/extended/IERC20Extended.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20ExtendedInternal } from './IERC20ExtendedInternal.sol';\n\n/**\n * @title ERC20 extended interface\n */\ninterface IERC20Extended is IERC20ExtendedInternal {\n    /**\n     * @notice increase spend amount granted to spender\n     * @param spender address whose allowance to increase\n     * @param amount quantity by which to increase allowance\n     * @return success status (always true; otherwise function will revert)\n     */\n    function increaseAllowance(\n        address spender,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @notice decrease spend amount granted to spender\n     * @param spender address whose allowance to decrease\n     * @param amount quantity by which to decrease allowance\n     * @return success status (always true; otherwise function will revert)\n     */\n    function decreaseAllowance(\n        address spender,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@solidstate/contracts/token/ERC20/extended/IERC20ExtendedInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20BaseInternal } from '../base/IERC20BaseInternal.sol';\n\n/**\n * @title ERC20 extended internal interface\n */\ninterface IERC20ExtendedInternal is IERC20BaseInternal {\n    error ERC20Extended__ExcessiveAllowance();\n    error ERC20Extended__InsufficientAllowance();\n}\n"
    },
    "@solidstate/contracts/token/ERC20/ISolidStateERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20Base } from './base/IERC20Base.sol';\nimport { IERC20Extended } from './extended/IERC20Extended.sol';\nimport { IERC20Metadata } from './metadata/IERC20Metadata.sol';\nimport { IERC20Permit } from './permit/IERC20Permit.sol';\n\ninterface ISolidStateERC20 is\n    IERC20Base,\n    IERC20Extended,\n    IERC20Metadata,\n    IERC20Permit\n{}\n"
    },
    "@solidstate/contracts/token/ERC20/metadata/ERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20Metadata } from './IERC20Metadata.sol';\nimport { ERC20MetadataInternal } from './ERC20MetadataInternal.sol';\n\n/**\n * @title ERC20 metadata extensions\n */\nabstract contract ERC20Metadata is IERC20Metadata, ERC20MetadataInternal {\n    /**\n     * @inheritdoc IERC20Metadata\n     */\n    function name() external view returns (string memory) {\n        return _name();\n    }\n\n    /**\n     * @inheritdoc IERC20Metadata\n     */\n    function symbol() external view returns (string memory) {\n        return _symbol();\n    }\n\n    /**\n     * @inheritdoc IERC20Metadata\n     */\n    function decimals() external view returns (uint8) {\n        return _decimals();\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/metadata/ERC20MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20MetadataInternal } from './IERC20MetadataInternal.sol';\nimport { ERC20MetadataStorage } from './ERC20MetadataStorage.sol';\n\n/**\n * @title ERC20Metadata internal functions\n */\nabstract contract ERC20MetadataInternal is IERC20MetadataInternal {\n    /**\n     * @notice return token name\n     * @return token name\n     */\n    function _name() internal view virtual returns (string memory) {\n        return ERC20MetadataStorage.layout().name;\n    }\n\n    /**\n     * @notice return token symbol\n     * @return token symbol\n     */\n    function _symbol() internal view virtual returns (string memory) {\n        return ERC20MetadataStorage.layout().symbol;\n    }\n\n    /**\n     * @notice return token decimals, generally used only for display purposes\n     * @return token decimals\n     */\n    function _decimals() internal view virtual returns (uint8) {\n        return ERC20MetadataStorage.layout().decimals;\n    }\n\n    function _setName(string memory name) internal virtual {\n        ERC20MetadataStorage.layout().name = name;\n    }\n\n    function _setSymbol(string memory symbol) internal virtual {\n        ERC20MetadataStorage.layout().symbol = symbol;\n    }\n\n    function _setDecimals(uint8 decimals) internal virtual {\n        ERC20MetadataStorage.layout().decimals = decimals;\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/metadata/ERC20MetadataStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ERC20MetadataStorage {\n    struct Layout {\n        string name;\n        string symbol;\n        uint8 decimals;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC20Metadata');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/metadata/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20MetadataInternal } from './IERC20MetadataInternal.sol';\n\n/**\n * @title ERC20 metadata interface\n */\ninterface IERC20Metadata is IERC20MetadataInternal {\n    /**\n     * @notice return token name\n     * @return token name\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @notice return token symbol\n     * @return token symbol\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @notice return token decimals, generally used only for display purposes\n     * @return token decimals\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@solidstate/contracts/token/ERC20/metadata/IERC20MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title ERC20 metadata internal interface\n */\ninterface IERC20MetadataInternal {\n\n}\n"
    },
    "@solidstate/contracts/token/ERC20/permit/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\nimport { ERC20Base } from '../base/ERC20Base.sol';\nimport { ERC20Metadata } from '../metadata/ERC20Metadata.sol';\nimport { ERC20PermitInternal } from './ERC20PermitInternal.sol';\nimport { ERC20PermitStorage } from './ERC20PermitStorage.sol';\nimport { IERC2612 } from './IERC2612.sol';\nimport { IERC20Permit } from './IERC20Permit.sol';\n\n/**\n * @title ERC20 extension with support for ERC2612 permits\n * @dev derived from https://github.com/soliditylabs/ERC20-Permit (MIT license)\n */\nabstract contract ERC20Permit is IERC20Permit, ERC20PermitInternal {\n    /**\n     * @inheritdoc IERC2612\n     */\n    function DOMAIN_SEPARATOR()\n        external\n        view\n        returns (bytes32 domainSeparator)\n    {\n        return _DOMAIN_SEPARATOR();\n    }\n\n    /**\n     * @inheritdoc IERC2612\n     */\n    function nonces(address owner) public view returns (uint256) {\n        return _nonces(owner);\n    }\n\n    /**\n     * @inheritdoc IERC2612\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        _permit(owner, spender, amount, deadline, v, r, s);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/permit/ERC20PermitInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\nimport { ECDSA } from '../../../cryptography/ECDSA.sol';\nimport { ERC20BaseInternal } from '../base/ERC20BaseInternal.sol';\nimport { ERC20MetadataInternal } from '../metadata/ERC20MetadataInternal.sol';\nimport { ERC20PermitStorage } from './ERC20PermitStorage.sol';\nimport { IERC20PermitInternal } from './IERC20PermitInternal.sol';\n\n/**\n * @title ERC20 extension with support for ERC2612 permits\n * @dev derived from https://github.com/soliditylabs/ERC20-Permit (MIT license)\n */\nabstract contract ERC20PermitInternal is\n    ERC20BaseInternal,\n    ERC20MetadataInternal,\n    IERC20PermitInternal\n{\n    using ECDSA for bytes32;\n\n    /**\n     * @notice return the EIP-712 domain separator unique to contract and chain\n     * @return domainSeparator domain separator\n     */\n    function _DOMAIN_SEPARATOR()\n        internal\n        view\n        returns (bytes32 domainSeparator)\n    {\n        domainSeparator = ERC20PermitStorage.layout().domainSeparators[\n            _chainId()\n        ];\n\n        if (domainSeparator == 0x00) {\n            domainSeparator = _calculateDomainSeparator();\n        }\n    }\n\n    /**\n     * @notice get the current ERC2612 nonce for the given address\n     * @return current nonce\n     */\n    function _nonces(address owner) internal view returns (uint256) {\n        return ERC20PermitStorage.layout().nonces[owner];\n    }\n\n    /**\n     * @notice calculate unique EIP-712 domain separator\n     * @return domainSeparator domain separator\n     */\n    function _calculateDomainSeparator()\n        internal\n        view\n        returns (bytes32 domainSeparator)\n    {\n        // no need for assembly, running very rarely\n        domainSeparator = keccak256(\n            abi.encode(\n                keccak256(\n                    'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'\n                ),\n                keccak256(bytes(_name())), // ERC-20 Name\n                keccak256(bytes('1')), // Version\n                _chainId(),\n                address(this)\n            )\n        );\n    }\n\n    /**\n     * @notice get the current chain ID\n     * @return chainId chain ID\n     */\n    function _chainId() private view returns (uint256 chainId) {\n        assembly {\n            chainId := chainid()\n        }\n    }\n\n    /**\n     * @notice approve spender to transfer tokens held by owner via signature\n     * @dev this function may be vulnerable to approval replay attacks\n     * @param owner holder of tokens and signer of permit\n     * @param spender beneficiary of approval\n     * @param amount quantity of tokens to approve\n     * @param v secp256k1 'v' value\n     * @param r secp256k1 'r' value\n     * @param s secp256k1 's' value\n     * @dev If https://eips.ethereum.org/EIPS/eip-1344[ChainID] ever changes, the\n     * EIP712 Domain Separator is automatically recalculated.\n     */\n    function _permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal virtual {\n        if (block.timestamp > deadline) revert ERC20Permit__ExpiredDeadline();\n\n        // Assembly for more efficiently computing:\n        // bytes32 hashStruct = keccak256(\n        //   abi.encode(\n        //     _PERMIT_TYPEHASH,\n        //     owner,\n        //     spender,\n        //     amount,\n        //     _nonces[owner].current(),\n        //     deadline\n        //   )\n        // );\n\n        ERC20PermitStorage.Layout storage l = ERC20PermitStorage.layout();\n\n        bytes32 hashStruct;\n        uint256 nonce = l.nonces[owner];\n\n        assembly {\n            // Load free memory pointer\n            let pointer := mload(64)\n\n            // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\n            mstore(\n                pointer,\n                0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9\n            )\n            mstore(add(pointer, 32), owner)\n            mstore(add(pointer, 64), spender)\n            mstore(add(pointer, 96), amount)\n            mstore(add(pointer, 128), nonce)\n            mstore(add(pointer, 160), deadline)\n\n            hashStruct := keccak256(pointer, 192)\n        }\n\n        bytes32 domainSeparator = l.domainSeparators[_chainId()];\n\n        if (domainSeparator == 0x00) {\n            domainSeparator = _calculateDomainSeparator();\n            l.domainSeparators[_chainId()] = domainSeparator;\n        }\n\n        // Assembly for more efficient computing:\n        // bytes32 hash = keccak256(\n        //   abi.encodePacked(uint16(0x1901), domainSeparator, hashStruct)\n        // );\n\n        bytes32 hash;\n\n        assembly {\n            // Load free memory pointer\n            let pointer := mload(64)\n\n            mstore(\n                pointer,\n                0x1901000000000000000000000000000000000000000000000000000000000000\n            ) // EIP191 header\n            mstore(add(pointer, 2), domainSeparator) // EIP712 domain hash\n            mstore(add(pointer, 34), hashStruct) // Hash of struct\n\n            hash := keccak256(pointer, 66)\n        }\n\n        address signer = hash.recover(v, r, s);\n\n        if (signer != owner) revert ERC20Permit__InvalidSignature();\n\n        l.nonces[owner]++;\n        _approve(owner, spender, amount);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/permit/ERC20PermitStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ERC20PermitStorage {\n    struct Layout {\n        mapping(address => uint256) nonces;\n        // Mapping of ChainID to domain separators. This is a very gas efficient way\n        // to not recalculate the domain separator on every call, while still\n        // automatically detecting ChainID changes.\n        mapping(uint256 => bytes32) domainSeparators;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC20Permit');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/permit/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20Metadata } from '../metadata/IERC20Metadata.sol';\nimport { IERC2612 } from './IERC2612.sol';\nimport { IERC20PermitInternal } from './IERC20PermitInternal.sol';\n\n// TODO: note that IERC20Metadata is needed for eth-permit library\n\ninterface IERC20Permit is IERC20PermitInternal, IERC2612 {\n\n}\n"
    },
    "@solidstate/contracts/token/ERC20/permit/IERC20PermitInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC2612Internal } from './IERC2612Internal.sol';\n\ninterface IERC20PermitInternal is IERC2612Internal {\n    error ERC20Permit__ExpiredDeadline();\n    error ERC20Permit__InvalidSignature();\n}\n"
    },
    "@solidstate/contracts/token/ERC20/permit/IERC2612.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC2612Internal } from './IERC2612Internal.sol';\n\n/**\n * @title ERC2612 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-2612.\n */\ninterface IERC2612 is IERC2612Internal {\n    /**\n     * @notice return the EIP-712 domain separator unique to contract and chain\n     * @return domainSeparator domain separator\n     */\n    function DOMAIN_SEPARATOR() external view returns (bytes32 domainSeparator);\n\n    /**\n     * @notice get the current ERC2612 nonce for the given address\n     * @return current nonce\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @notice approve spender to transfer tokens held by owner via signature\n     * @dev this function may be vulnerable to approval replay attacks\n     * @param owner holder of tokens and signer of permit\n     * @param spender beneficiary of approval\n     * @param amount quantity of tokens to approve\n     * @param v secp256k1 'v' value\n     * @param r secp256k1 'r' value\n     * @param s secp256k1 's' value\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "@solidstate/contracts/token/ERC20/permit/IERC2612Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\ninterface IERC2612Internal {}\n"
    },
    "@solidstate/contracts/token/ERC20/SolidStateERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { ISolidStateERC20 } from './ISolidStateERC20.sol';\nimport { ERC20Base } from './base/ERC20Base.sol';\nimport { ERC20Extended } from './extended/ERC20Extended.sol';\nimport { ERC20Metadata } from './metadata/ERC20Metadata.sol';\nimport { ERC20Permit } from './permit/ERC20Permit.sol';\n\n/**\n * @title SolidState ERC20 implementation, including recommended extensions\n */\nabstract contract SolidStateERC20 is\n    ISolidStateERC20,\n    ERC20Base,\n    ERC20Extended,\n    ERC20Metadata,\n    ERC20Permit\n{\n\n}\n"
    },
    "@solidstate/contracts/utils/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { UintUtils } from './UintUtils.sol';\n\nlibrary AddressUtils {\n    using UintUtils for uint256;\n\n    error AddressUtils__InsufficientBalance();\n    error AddressUtils__NotContract();\n    error AddressUtils__SendValueFailed();\n\n    function toString(address account) internal pure returns (string memory) {\n        return uint256(uint160(account)).toHexString(20);\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendValue(address payable account, uint256 amount) internal {\n        (bool success, ) = account.call{ value: amount }('');\n        if (!success) revert AddressUtils__SendValueFailed();\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data\n    ) internal returns (bytes memory) {\n        return\n            functionCall(target, data, 'AddressUtils: failed low-level call');\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory error\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, error);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                'AddressUtils: failed low-level call with value'\n            );\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) internal returns (bytes memory) {\n        if (value > address(this).balance)\n            revert AddressUtils__InsufficientBalance();\n        return _functionCallWithValue(target, data, value, error);\n    }\n\n    /**\n     * @notice execute arbitrary external call with limited gas usage and amount of copied return data\n     * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\n     * @param target recipient of call\n     * @param gasAmount gas allowance for call\n     * @param value native token value to include in call\n     * @param maxCopy maximum number of bytes to copy from return data\n     * @param data encoded call data\n     * @return success whether call is successful\n     * @return returnData copied return data\n     */\n    function excessivelySafeCall(\n        address target,\n        uint256 gasAmount,\n        uint256 value,\n        uint16 maxCopy,\n        bytes memory data\n    ) internal returns (bool success, bytes memory returnData) {\n        returnData = new bytes(maxCopy);\n\n        assembly {\n            // execute external call via assembly to avoid automatic copying of return data\n            success := call(\n                gasAmount,\n                target,\n                value,\n                add(data, 0x20),\n                mload(data),\n                0,\n                0\n            )\n\n            // determine whether to limit amount of data to copy\n            let toCopy := returndatasize()\n\n            if gt(toCopy, maxCopy) {\n                toCopy := maxCopy\n            }\n\n            // store the length of the copied bytes\n            mstore(returnData, toCopy)\n\n            // copy the bytes from returndata[0:toCopy]\n            returndatacopy(add(returnData, 0x20), 0, toCopy)\n        }\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) private returns (bytes memory) {\n        if (!isContract(target)) revert AddressUtils__NotContract();\n\n        (bool success, bytes memory returnData) = target.call{ value: value }(\n            data\n        );\n\n        if (success) {\n            return returnData;\n        } else if (returnData.length > 0) {\n            assembly {\n                let returnData_size := mload(returnData)\n                revert(add(32, returnData), returnData_size)\n            }\n        } else {\n            revert(error);\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20 } from '../interfaces/IERC20.sol';\nimport { AddressUtils } from './AddressUtils.sol';\n\n/**\n * @title Safe ERC20 interaction library\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nlibrary SafeERC20 {\n    using AddressUtils for address;\n\n    error SafeERC20__ApproveFromNonZeroToNonZero();\n    error SafeERC20__DecreaseAllowanceBelowZero();\n    error SafeERC20__OperationFailed();\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    /**\n     * @dev safeApprove (like approve) should only be called when setting an initial allowance or when resetting it to zero; otherwise prefer safeIncreaseAllowance and safeDecreaseAllowance\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        if ((value != 0) && (token.allowance(address(this), spender) != 0))\n            revert SafeERC20__ApproveFromNonZeroToNonZero();\n\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.approve.selector, spender, value)\n        );\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            if (oldAllowance < value)\n                revert SafeERC20__DecreaseAllowanceBelowZero();\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(\n                token,\n                abi.encodeWithSelector(\n                    token.approve.selector,\n                    spender,\n                    newAllowance\n                )\n            );\n        }\n    }\n\n    /**\n     * @notice send transaction data and check validity of return value, if present\n     * @param token ERC20 token interface\n     * @param data transaction data\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(\n            data,\n            'SafeERC20: low-level call failed'\n        );\n\n        if (returndata.length > 0) {\n            if (!abi.decode(returndata, (bool)))\n                revert SafeERC20__OperationFailed();\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/utils/UintUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title utility functions for uint256 operations\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nlibrary UintUtils {\n    error UintUtils__InsufficientHexLength();\n\n    bytes16 private constant HEX_SYMBOLS = '0123456789abcdef';\n\n    function add(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? sub(a, -b) : a + uint256(b);\n    }\n\n    function sub(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? add(a, -b) : a - uint256(b);\n    }\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0';\n        }\n\n        uint256 temp = value;\n        uint256 digits;\n\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n\n        bytes memory buffer = new bytes(digits);\n\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n\n        return string(buffer);\n    }\n\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0x00';\n        }\n\n        uint256 length = 0;\n\n        for (uint256 temp = value; temp != 0; temp >>= 8) {\n            unchecked {\n                length++;\n            }\n        }\n\n        return toHexString(value, length);\n    }\n\n    function toHexString(\n        uint256 value,\n        uint256 length\n    ) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n\n        unchecked {\n            for (uint256 i = 2 * length + 1; i > 1; --i) {\n                buffer[i] = HEX_SYMBOLS[value & 0xf];\n                value >>= 4;\n            }\n        }\n\n        if (value != 0) revert UintUtils__InsufficientHexLength();\n\n        return string(buffer);\n    }\n}\n"
    },
    "celer/contracts/interfaces/IBridge.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\ninterface IBridge {\n    function send(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        uint64 _dstChainId,\n        uint64 _nonce,\n        uint32 _maxSlippage\n    ) external;\n\n    function sendNative(\n        address _receiver,\n        uint256 _amount,\n        uint64 _dstChainId,\n        uint64 _nonce,\n        uint32 _maxSlippage\n    ) external payable;\n\n    function relay(\n        bytes calldata _relayRequest,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external;\n\n    function transfers(bytes32 transferId) external view returns (bool);\n\n    function withdraws(bytes32 withdrawId) external view returns (bool);\n\n    function withdraw(\n        bytes calldata _wdmsg,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external;\n\n    /**\n     * @notice Verifies that a message is signed by a quorum among the signers.\n     * @param _msg signed message\n     * @param _sigs list of signatures sorted by signer addresses in ascending order\n     * @param _signers sorted list of current signers\n     * @param _powers powers of current signers\n     */\n    function verifySigs(\n        bytes memory _msg,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external view;\n}\n"
    },
    "celer/contracts/interfaces/IDelayedTransfer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.9;\n\ninterface IDelayedTransfer {\n    struct delayedTransfer {\n        address receiver;\n        address token;\n        uint256 amount;\n        uint256 timestamp;\n    }\n\n    function delayedTransfers(bytes32 transferId) external view returns (delayedTransfer memory);\n}\n"
    },
    "celer/contracts/interfaces/IOriginalTokenVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\ninterface IOriginalTokenVault {\n    /**\n     * @notice Lock original tokens to trigger mint at a remote chain's PeggedTokenBridge\n     * @param _token local token address\n     * @param _amount locked token amount\n     * @param _mintChainId destination chainId to mint tokens\n     * @param _mintAccount destination account to receive minted tokens\n     * @param _nonce user input to guarantee unique depositId\n     */\n    function deposit(\n        address _token,\n        uint256 _amount,\n        uint64 _mintChainId,\n        address _mintAccount,\n        uint64 _nonce\n    ) external;\n\n    /**\n     * @notice Lock native token as original token to trigger mint at a remote chain's PeggedTokenBridge\n     * @param _amount locked token amount\n     * @param _mintChainId destination chainId to mint tokens\n     * @param _mintAccount destination account to receive minted tokens\n     * @param _nonce user input to guarantee unique depositId\n     */\n    function depositNative(\n        uint256 _amount,\n        uint64 _mintChainId,\n        address _mintAccount,\n        uint64 _nonce\n    ) external payable;\n\n    /**\n     * @notice Withdraw locked original tokens triggered by a burn at a remote chain's PeggedTokenBridge.\n     * @param _request The serialized Withdraw protobuf.\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\n     * +2/3 of the bridge's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function withdraw(\n        bytes calldata _request,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external;\n\n    function records(bytes32 recordId) external view returns (bool);\n}\n"
    },
    "celer/contracts/interfaces/IOriginalTokenVaultV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\ninterface IOriginalTokenVaultV2 {\n    /**\n     * @notice Lock original tokens to trigger mint at a remote chain's PeggedTokenBridge\n     * @param _token local token address\n     * @param _amount locked token amount\n     * @param _mintChainId destination chainId to mint tokens\n     * @param _mintAccount destination account to receive minted tokens\n     * @param _nonce user input to guarantee unique depositId\n     */\n    function deposit(\n        address _token,\n        uint256 _amount,\n        uint64 _mintChainId,\n        address _mintAccount,\n        uint64 _nonce\n    ) external returns (bytes32);\n\n    /**\n     * @notice Lock native token as original token to trigger mint at a remote chain's PeggedTokenBridge\n     * @param _amount locked token amount\n     * @param _mintChainId destination chainId to mint tokens\n     * @param _mintAccount destination account to receive minted tokens\n     * @param _nonce user input to guarantee unique depositId\n     */\n    function depositNative(\n        uint256 _amount,\n        uint64 _mintChainId,\n        address _mintAccount,\n        uint64 _nonce\n    ) external payable returns (bytes32);\n\n    /**\n     * @notice Withdraw locked original tokens triggered by a burn at a remote chain's PeggedTokenBridge.\n     * @param _request The serialized Withdraw protobuf.\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\n     * +2/3 of the bridge's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function withdraw(\n        bytes calldata _request,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external returns (bytes32);\n\n    function records(bytes32 recordId) external view returns (bool);\n}\n"
    },
    "celer/contracts/interfaces/IPeggedTokenBridge.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\ninterface IPeggedTokenBridge {\n    /**\n     * @notice Burn tokens to trigger withdrawal at a remote chain's OriginalTokenVault\n     * @param _token local token address\n     * @param _amount locked token amount\n     * @param _withdrawAccount account who withdraw original tokens on the remote chain\n     * @param _nonce user input to guarantee unique depositId\n     */\n    function burn(\n        address _token,\n        uint256 _amount,\n        address _withdrawAccount,\n        uint64 _nonce\n    ) external;\n\n    /**\n     * @notice Mint tokens triggered by deposit at a remote chain's OriginalTokenVault.\n     * @param _request The serialized Mint protobuf.\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\n     * +2/3 of the sigsVerifier's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function mint(\n        bytes calldata _request,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external;\n\n    function records(bytes32 recordId) external view returns (bool);\n}\n"
    },
    "celer/contracts/interfaces/IPeggedTokenBridgeV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\ninterface IPeggedTokenBridgeV2 {\n    /**\n     * @notice Burn pegged tokens to trigger a cross-chain withdrawal of the original tokens at a remote chain's\n     * OriginalTokenVault, or mint at another remote chain\n     * @param _token The pegged token address.\n     * @param _amount The amount to burn.\n     * @param _toChainId If zero, withdraw from original vault; otherwise, the remote chain to mint tokens.\n     * @param _toAccount The account to receive tokens on the remote chain\n     * @param _nonce A number to guarantee unique depositId. Can be timestamp in practice.\n     */\n    function burn(\n        address _token,\n        uint256 _amount,\n        uint64 _toChainId,\n        address _toAccount,\n        uint64 _nonce\n    ) external returns (bytes32);\n\n    // same with `burn` above, use openzeppelin ERC20Burnable interface\n    function burnFrom(\n        address _token,\n        uint256 _amount,\n        uint64 _toChainId,\n        address _toAccount,\n        uint64 _nonce\n    ) external returns (bytes32);\n\n    /**\n     * @notice Mint tokens triggered by deposit at a remote chain's OriginalTokenVault.\n     * @param _request The serialized Mint protobuf.\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\n     * +2/3 of the sigsVerifier's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function mint(\n        bytes calldata _request,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external returns (bytes32);\n\n    function records(bytes32 recordId) external view returns (bool);\n}\n"
    },
    "celer/contracts/interfaces/ISigsVerifier.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\ninterface ISigsVerifier {\n    /**\n     * @notice Verifies that a message is signed by a quorum among the signers.\n     * @param _msg signed message\n     * @param _sigs list of signatures sorted by signer addresses in ascending order\n     * @param _signers sorted list of current signers\n     * @param _powers powers of current signers\n     */\n    function verifySigs(\n        bytes memory _msg,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external view;\n}\n"
    },
    "celer/contracts/libraries/Utils.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\nlibrary Utils {\n    // https://ethereum.stackexchange.com/a/83577\n    // https://github.com/Uniswap/v3-periphery/blob/v1.0.0/contracts/base/Multicall.sol\n    function getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"Transaction reverted silently\";\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n}\n"
    },
    "celer/contracts/message/framework/MessageBusAddress.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\nabstract contract MessageBusAddress {\n    address public messageBus;\n}\n"
    },
    "celer/contracts/message/framework/MessageReceiverApp.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\nimport \"../interfaces/IMessageReceiverApp.sol\";\nimport \"../libraries/MsgDataTypes.sol\";\nimport \"./MessageBusAddress.sol\";\n\nabstract contract MessageReceiverApp is IMessageReceiverApp, MessageBusAddress {\n    modifier onlyMessageBus() {\n        require(msg.sender == messageBus, \"caller is not message bus\");\n        _;\n    }\n\n    // Add abort prefix in the reason string for require or revert.\n    // This will abort (revert) the message execution without markig it as failed state,\n    // making it possible to retry later.\n    function _abortReason(string memory reason) internal pure returns (string memory) {\n        return MsgDataTypes.abortReason(reason);\n    }\n\n    /**\n     * @notice Called by MessageBus to execute a message\n     * @param _sender The address of the source app contract\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessage(\n        address _sender,\n        uint64 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external payable virtual override onlyMessageBus returns (ExecutionStatus) {}\n\n    // execute message from non-evm chain with bytes for sender address,\n    // otherwise same as above.\n    function executeMessage(\n        bytes calldata _sender,\n        uint64 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external payable virtual override onlyMessageBus returns (ExecutionStatus) {}\n\n    /**\n     * @notice Called by MessageBus to execute a message with an associated token transfer.\n     * The contract is guaranteed to have received the right amount of tokens before this function is called.\n     * @param _sender The address of the source app contract\n     * @param _token The address of the token that comes out of the bridge\n     * @param _amount The amount of tokens received at this contract through the cross-chain bridge.\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessageWithTransfer(\n        address _sender,\n        address _token,\n        uint256 _amount,\n        uint64 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external payable virtual override onlyMessageBus returns (ExecutionStatus) {}\n\n    /**\n     * @notice Only called by MessageBus if\n     *         1. executeMessageWithTransfer reverts, or\n     *         2. executeMessageWithTransfer returns ExecutionStatus.Fail\n     * The contract is guaranteed to have received the right amount of tokens before this function is called.\n     * @param _sender The address of the source app contract\n     * @param _token The address of the token that comes out of the bridge\n     * @param _amount The amount of tokens received at this contract through the cross-chain bridge.\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessageWithTransferFallback(\n        address _sender,\n        address _token,\n        uint256 _amount,\n        uint64 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external payable virtual override onlyMessageBus returns (ExecutionStatus) {}\n\n    /**\n     * @notice Called by MessageBus to process refund of the original transfer from this contract.\n     * The contract is guaranteed to have received the refund before this function is called.\n     * @param _token The token address of the original transfer\n     * @param _amount The amount of the original transfer\n     * @param _message The same message associated with the original transfer\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessageWithTransferRefund(\n        address _token,\n        uint256 _amount,\n        bytes calldata _message,\n        address _executor\n    ) external payable virtual override onlyMessageBus returns (ExecutionStatus) {}\n}\n"
    },
    "celer/contracts/message/interfaces/IMessageBus.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\nimport \"../libraries/MsgDataTypes.sol\";\n\ninterface IMessageBus {\n    /**\n     * @notice Send a message to a contract on another chain.\n     * Sender needs to make sure the uniqueness of the message Id, which is computed as\n     * hash(type.MessageOnly, sender, receiver, srcChainId, srcTxHash, dstChainId, message).\n     * If messages with the same Id are sent, only one of them will succeed at dst chain..\n     * A fee is charged in the native gas token.\n     * @param _receiver The address of the destination app contract.\n     * @param _dstChainId The destination chain ID.\n     * @param _message Arbitrary message bytes to be decoded by the destination app contract.\n     */\n    function sendMessage(\n        address _receiver,\n        uint256 _dstChainId,\n        bytes calldata _message\n    ) external payable;\n\n    // same as above, except that receiver is an non-evm chain address,\n    function sendMessage(\n        bytes calldata _receiver,\n        uint256 _dstChainId,\n        bytes calldata _message\n    ) external payable;\n\n    /**\n     * @notice Send a message associated with a token transfer to a contract on another chain.\n     * If messages with the same srcTransferId are sent, only one of them will succeed at dst chain..\n     * A fee is charged in the native token.\n     * @param _receiver The address of the destination app contract.\n     * @param _dstChainId The destination chain ID.\n     * @param _srcBridge The bridge contract to send the transfer with.\n     * @param _srcTransferId The transfer ID.\n     * @param _dstChainId The destination chain ID.\n     * @param _message Arbitrary message bytes to be decoded by the destination app contract.\n     */\n    function sendMessageWithTransfer(\n        address _receiver,\n        uint256 _dstChainId,\n        address _srcBridge,\n        bytes32 _srcTransferId,\n        bytes calldata _message\n    ) external payable;\n\n    /**\n     * @notice Execute a message not associated with a transfer.\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\n     * +2/3 of the sigsVerifier's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function executeMessage(\n        bytes calldata _message,\n        MsgDataTypes.RouteInfo calldata _route,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external payable;\n\n    /**\n     * @notice Execute a message with a successful transfer.\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _transfer The transfer info.\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\n     * +2/3 of the sigsVerifier's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function executeMessageWithTransfer(\n        bytes calldata _message,\n        MsgDataTypes.TransferInfo calldata _transfer,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external payable;\n\n    /**\n     * @notice Execute a message with a refunded transfer.\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _transfer The transfer info.\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\n     * +2/3 of the sigsVerifier's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function executeMessageWithTransferRefund(\n        bytes calldata _message, // the same message associated with the original transfer\n        MsgDataTypes.TransferInfo calldata _transfer,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external payable;\n\n    /**\n     * @notice Withdraws message fee in the form of native gas token.\n     * @param _account The address receiving the fee.\n     * @param _cumulativeFee The cumulative fee credited to the account. Tracked by SGN.\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A withdrawal must be\n     * signed-off by +2/3 of the sigsVerifier's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function withdrawFee(\n        address _account,\n        uint256 _cumulativeFee,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external;\n\n    /**\n     * @notice Calculates the required fee for the message.\n     * @param _message Arbitrary message bytes to be decoded by the destination app contract.\n     @ @return The required fee.\n     */\n    function calcFee(bytes calldata _message) external view returns (uint256);\n\n    function liquidityBridge() external view returns (address);\n\n    function pegBridge() external view returns (address);\n\n    function pegBridgeV2() external view returns (address);\n\n    function pegVault() external view returns (address);\n\n    function pegVaultV2() external view returns (address);\n}\n"
    },
    "celer/contracts/message/interfaces/IMessageReceiverApp.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\ninterface IMessageReceiverApp {\n    enum ExecutionStatus {\n        Fail, // execution failed, finalized\n        Success, // execution succeeded, finalized\n        Retry // execution rejected, can retry later\n    }\n\n    /**\n     * @notice Called by MessageBus to execute a message\n     * @param _sender The address of the source app contract\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessage(\n        address _sender,\n        uint64 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external payable returns (ExecutionStatus);\n\n    // same as above, except that sender is an non-evm chain address,\n    // otherwise same as above.\n    function executeMessage(\n        bytes calldata _sender,\n        uint64 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external payable returns (ExecutionStatus);\n\n    /**\n     * @notice Called by MessageBus to execute a message with an associated token transfer.\n     * The contract is guaranteed to have received the right amount of tokens before this function is called.\n     * @param _sender The address of the source app contract\n     * @param _token The address of the token that comes out of the bridge\n     * @param _amount The amount of tokens received at this contract through the cross-chain bridge.\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessageWithTransfer(\n        address _sender,\n        address _token,\n        uint256 _amount,\n        uint64 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external payable returns (ExecutionStatus);\n\n    /**\n     * @notice Only called by MessageBus if\n     *         1. executeMessageWithTransfer reverts, or\n     *         2. executeMessageWithTransfer returns ExecutionStatus.Fail\n     * The contract is guaranteed to have received the right amount of tokens before this function is called.\n     * @param _sender The address of the source app contract\n     * @param _token The address of the token that comes out of the bridge\n     * @param _amount The amount of tokens received at this contract through the cross-chain bridge.\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessageWithTransferFallback(\n        address _sender,\n        address _token,\n        uint256 _amount,\n        uint64 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external payable returns (ExecutionStatus);\n\n    /**\n     * @notice Called by MessageBus to process refund of the original transfer from this contract.\n     * The contract is guaranteed to have received the refund before this function is called.\n     * @param _token The token address of the original transfer\n     * @param _amount The amount of the original transfer\n     * @param _message The same message associated with the original transfer\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessageWithTransferRefund(\n        address _token,\n        uint256 _amount,\n        bytes calldata _message,\n        address _executor\n    ) external payable returns (ExecutionStatus);\n}\n"
    },
    "celer/contracts/message/libraries/MessageSenderLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../../interfaces/IBridge.sol\";\nimport \"../../interfaces/IOriginalTokenVault.sol\";\nimport \"../../interfaces/IOriginalTokenVaultV2.sol\";\nimport \"../../interfaces/IPeggedTokenBridge.sol\";\nimport \"../../interfaces/IPeggedTokenBridgeV2.sol\";\nimport \"../interfaces/IMessageBus.sol\";\nimport \"./MsgDataTypes.sol\";\n\nlibrary MessageSenderLib {\n    using SafeERC20 for IERC20;\n\n    // ============== Internal library functions called by apps ==============\n\n    /**\n     * @notice Sends a message to an app on another chain via MessageBus without an associated transfer.\n     * @param _receiver The address of the destination app contract.\n     * @param _dstChainId The destination chain ID.\n     * @param _message Arbitrary message bytes to be decoded by the destination app contract.\n     * @param _messageBus The address of the MessageBus on this chain.\n     * @param _fee The fee amount to pay to MessageBus.\n     */\n    function sendMessage(\n        address _receiver,\n        uint64 _dstChainId,\n        bytes memory _message,\n        address _messageBus,\n        uint256 _fee\n    ) internal {\n        IMessageBus(_messageBus).sendMessage{value: _fee}(_receiver, _dstChainId, _message);\n    }\n\n    // Send message to non-evm chain with bytes for receiver address,\n    // otherwise same as above.\n    function sendMessage(\n        bytes calldata _receiver,\n        uint64 _dstChainId,\n        bytes memory _message,\n        address _messageBus,\n        uint256 _fee\n    ) internal {\n        IMessageBus(_messageBus).sendMessage{value: _fee}(_receiver, _dstChainId, _message);\n    }\n\n    /**\n     * @notice Sends a message to an app on another chain via MessageBus with an associated transfer.\n     * @param _receiver The address of the destination app contract.\n     * @param _token The address of the token to be sent.\n     * @param _amount The amount of tokens to be sent.\n     * @param _dstChainId The destination chain ID.\n     * @param _nonce A number input to guarantee uniqueness of transferId. Can be timestamp in practice.\n     * @param _maxSlippage The max slippage accepted, given as percentage in point (pip). Eg. 5000 means 0.5%.\n     * Must be greater than minimalMaxSlippage. Receiver is guaranteed to receive at least (100% - max slippage percentage) * amount or the\n     * transfer can be refunded. Only applicable to the {MsgDataTypes.BridgeSendType.Liquidity}.\n     * @param _message Arbitrary message bytes to be decoded by the destination app contract.\n     * @param _bridgeSendType One of the {MsgDataTypes.BridgeSendType} enum.\n     * @param _messageBus The address of the MessageBus on this chain.\n     * @param _fee The fee amount to pay to MessageBus.\n     * @return The transfer ID.\n     */\n    function sendMessageWithTransfer(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        uint64 _dstChainId,\n        uint64 _nonce,\n        uint32 _maxSlippage,\n        bytes memory _message,\n        MsgDataTypes.BridgeSendType _bridgeSendType,\n        address _messageBus,\n        uint256 _fee\n    ) internal returns (bytes32) {\n        (bytes32 transferId, address bridge) = sendTokenTransfer(\n            _receiver,\n            _token,\n            _amount,\n            _dstChainId,\n            _nonce,\n            _maxSlippage,\n            _bridgeSendType,\n            _messageBus\n        );\n        if (_message.length > 0) {\n            IMessageBus(_messageBus).sendMessageWithTransfer{value: _fee}(\n                _receiver,\n                _dstChainId,\n                bridge,\n                transferId,\n                _message\n            );\n        }\n        return transferId;\n    }\n\n    /**\n     * @notice Sends a token transfer via a bridge.\n     * @param _receiver The address of the destination app contract.\n     * @param _token The address of the token to be sent.\n     * @param _amount The amount of tokens to be sent.\n     * @param _dstChainId The destination chain ID.\n     * @param _nonce A number input to guarantee uniqueness of transferId. Can be timestamp in practice.\n     * @param _maxSlippage The max slippage accepted, given as percentage in point (pip). Eg. 5000 means 0.5%.\n     * Must be greater than minimalMaxSlippage. Receiver is guaranteed to receive at least (100% - max slippage percentage) * amount or the\n     * transfer can be refunded.\n     * @param _bridgeSendType One of the {MsgDataTypes.BridgeSendType} enum.\n     */\n    function sendTokenTransfer(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        uint64 _dstChainId,\n        uint64 _nonce,\n        uint32 _maxSlippage,\n        MsgDataTypes.BridgeSendType _bridgeSendType,\n        address _messageBus\n    ) internal returns (bytes32 transferId, address bridge) {\n        if (_bridgeSendType == MsgDataTypes.BridgeSendType.Liquidity) {\n            bridge = IMessageBus(_messageBus).liquidityBridge();\n            IERC20(_token).safeIncreaseAllowance(bridge, _amount);\n            IBridge(bridge).send(_receiver, _token, _amount, _dstChainId, _nonce, _maxSlippage);\n            transferId = computeLiqBridgeTransferId(_receiver, _token, _amount, _dstChainId, _nonce);\n        } else if (_bridgeSendType == MsgDataTypes.BridgeSendType.PegDeposit) {\n            bridge = IMessageBus(_messageBus).pegVault();\n            IERC20(_token).safeIncreaseAllowance(bridge, _amount);\n            IOriginalTokenVault(bridge).deposit(_token, _amount, _dstChainId, _receiver, _nonce);\n            transferId = computePegV1DepositId(_receiver, _token, _amount, _dstChainId, _nonce);\n        } else if (_bridgeSendType == MsgDataTypes.BridgeSendType.PegBurn) {\n            bridge = IMessageBus(_messageBus).pegBridge();\n            IERC20(_token).safeIncreaseAllowance(bridge, _amount);\n            IPeggedTokenBridge(bridge).burn(_token, _amount, _receiver, _nonce);\n            // handle cases where certain tokens do not spend allowance for role-based burn\n            IERC20(_token).safeApprove(bridge, 0);\n            transferId = computePegV1BurnId(_receiver, _token, _amount, _nonce);\n        } else if (_bridgeSendType == MsgDataTypes.BridgeSendType.PegV2Deposit) {\n            bridge = IMessageBus(_messageBus).pegVaultV2();\n            IERC20(_token).safeIncreaseAllowance(bridge, _amount);\n            transferId = IOriginalTokenVaultV2(bridge).deposit(_token, _amount, _dstChainId, _receiver, _nonce);\n        } else if (_bridgeSendType == MsgDataTypes.BridgeSendType.PegV2Burn) {\n            bridge = IMessageBus(_messageBus).pegBridgeV2();\n            IERC20(_token).safeIncreaseAllowance(bridge, _amount);\n            transferId = IPeggedTokenBridgeV2(bridge).burn(_token, _amount, _dstChainId, _receiver, _nonce);\n            // handle cases where certain tokens do not spend allowance for role-based burn\n            IERC20(_token).safeApprove(bridge, 0);\n        } else if (_bridgeSendType == MsgDataTypes.BridgeSendType.PegV2BurnFrom) {\n            bridge = IMessageBus(_messageBus).pegBridgeV2();\n            IERC20(_token).safeIncreaseAllowance(bridge, _amount);\n            transferId = IPeggedTokenBridgeV2(bridge).burnFrom(_token, _amount, _dstChainId, _receiver, _nonce);\n            // handle cases where certain tokens do not spend allowance for role-based burn\n            IERC20(_token).safeApprove(bridge, 0);\n        } else {\n            revert(\"bridge type not supported\");\n        }\n    }\n\n    function computeLiqBridgeTransferId(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        uint64 _dstChainId,\n        uint64 _nonce\n    ) internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(address(this), _receiver, _token, _amount, _dstChainId, _nonce, uint64(block.chainid))\n            );\n    }\n\n    function computePegV1DepositId(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        uint64 _dstChainId,\n        uint64 _nonce\n    ) internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(address(this), _token, _amount, _dstChainId, _receiver, _nonce, uint64(block.chainid))\n            );\n    }\n\n    function computePegV1BurnId(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        uint64 _nonce\n    ) internal view returns (bytes32) {\n        return keccak256(abi.encodePacked(address(this), _token, _amount, _receiver, _nonce, uint64(block.chainid)));\n    }\n}\n"
    },
    "celer/contracts/message/libraries/MsgDataTypes.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\nlibrary MsgDataTypes {\n    string constant ABORT_PREFIX = \"MSG::ABORT:\";\n\n    // Add abort prefix in the reason string for require or revert.\n    // This will abort (revert) the message execution without markig it as failed state,\n    // making it possible to retry later.\n    function abortReason(string memory reason) internal pure returns (string memory) {\n        return string.concat(MsgDataTypes.ABORT_PREFIX, reason);\n    }\n\n    // bridge operation type at the sender side (src chain)\n    enum BridgeSendType {\n        Null,\n        Liquidity,\n        PegDeposit,\n        PegBurn,\n        PegV2Deposit,\n        PegV2Burn,\n        PegV2BurnFrom\n    }\n\n    // bridge operation type at the receiver side (dst chain)\n    enum TransferType {\n        Null,\n        LqRelay, // relay through liquidity bridge\n        LqWithdraw, // withdraw from liquidity bridge\n        PegMint, // mint through pegged token bridge\n        PegWithdraw, // withdraw from original token vault\n        PegV2Mint, // mint through pegged token bridge v2\n        PegV2Withdraw // withdraw from original token vault v2\n    }\n\n    enum MsgType {\n        MessageWithTransfer,\n        MessageOnly\n    }\n\n    enum TxStatus {\n        Null,\n        Success,\n        Fail,\n        Fallback,\n        Pending // transient state within a transaction\n    }\n\n    struct TransferInfo {\n        TransferType t;\n        address sender;\n        address receiver;\n        address token;\n        uint256 amount;\n        uint64 wdseq; // only needed for LqWithdraw (refund)\n        uint64 srcChainId;\n        bytes32 refId;\n        bytes32 srcTxHash; // src chain msg tx hash\n    }\n\n    struct RouteInfo {\n        address sender;\n        address receiver;\n        uint64 srcChainId;\n        bytes32 srcTxHash; // src chain msg tx hash\n    }\n\n    // used for msg from non-evm chains with longer-bytes address\n    struct RouteInfo2 {\n        bytes sender;\n        address receiver;\n        uint64 srcChainId;\n        bytes32 srcTxHash;\n    }\n\n    // combination of RouteInfo and RouteInfo2 for easier processing\n    struct Route {\n        address sender; // from RouteInfo\n        bytes senderBytes; // from RouteInfo2\n        address receiver;\n        uint64 srcChainId;\n        bytes32 srcTxHash;\n    }\n\n    struct MsgWithTransferExecutionParams {\n        bytes message;\n        TransferInfo transfer;\n        bytes[] sigs;\n        address[] signers;\n        uint256[] powers;\n    }\n\n    struct BridgeTransferParams {\n        bytes request;\n        bytes[] sigs;\n        address[] signers;\n        uint256[] powers;\n    }\n}\n"
    },
    "celer/contracts/message/messagebus/MessageBusReceiver.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.9;\n\nimport \"../libraries/MsgDataTypes.sol\";\nimport \"../interfaces/IMessageReceiverApp.sol\";\nimport \"../../interfaces/IBridge.sol\";\nimport \"../../interfaces/IOriginalTokenVault.sol\";\nimport \"../../interfaces/IOriginalTokenVaultV2.sol\";\nimport \"../../interfaces/IPeggedTokenBridge.sol\";\nimport \"../../interfaces/IPeggedTokenBridgeV2.sol\";\nimport \"../../interfaces/IDelayedTransfer.sol\";\nimport \"../../safeguard/Ownable.sol\";\nimport \"../../libraries/Utils.sol\";\n\ncontract MessageBusReceiver is Ownable {\n    mapping(bytes32 => MsgDataTypes.TxStatus) public executedMessages;\n\n    address public liquidityBridge; // liquidity bridge address\n    address public pegBridge; // peg bridge address\n    address public pegVault; // peg original vault address\n    address public pegBridgeV2; // peg bridge address\n    address public pegVaultV2; // peg original vault address\n\n    // minimum amount of gas needed by this contract before it tries to\n    // deliver a message to the target contract.\n    uint256 public preExecuteMessageGasUsage;\n\n    event Executed(\n        MsgDataTypes.MsgType msgType,\n        bytes32 msgId,\n        MsgDataTypes.TxStatus status,\n        address indexed receiver,\n        uint64 srcChainId,\n        bytes32 srcTxHash\n    );\n    event NeedRetry(MsgDataTypes.MsgType msgType, bytes32 msgId, uint64 srcChainId, bytes32 srcTxHash);\n    event CallReverted(string reason); // help debug\n\n    event LiquidityBridgeUpdated(address liquidityBridge);\n    event PegBridgeUpdated(address pegBridge);\n    event PegVaultUpdated(address pegVault);\n    event PegBridgeV2Updated(address pegBridgeV2);\n    event PegVaultV2Updated(address pegVaultV2);\n\n    constructor(\n        address _liquidityBridge,\n        address _pegBridge,\n        address _pegVault,\n        address _pegBridgeV2,\n        address _pegVaultV2\n    ) {\n        liquidityBridge = _liquidityBridge;\n        pegBridge = _pegBridge;\n        pegVault = _pegVault;\n        pegBridgeV2 = _pegBridgeV2;\n        pegVaultV2 = _pegVaultV2;\n    }\n\n    function initReceiver(\n        address _liquidityBridge,\n        address _pegBridge,\n        address _pegVault,\n        address _pegBridgeV2,\n        address _pegVaultV2\n    ) internal {\n        require(liquidityBridge == address(0), \"liquidityBridge already set\");\n        liquidityBridge = _liquidityBridge;\n        pegBridge = _pegBridge;\n        pegVault = _pegVault;\n        pegBridgeV2 = _pegBridgeV2;\n        pegVaultV2 = _pegVaultV2;\n    }\n\n    // ============== functions called by executor ==============\n\n    /**\n     * @notice Execute a message with a successful transfer.\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _transfer The transfer info.\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\n     * +2/3 of the sigsVerifier's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function executeMessageWithTransfer(\n        bytes calldata _message,\n        MsgDataTypes.TransferInfo calldata _transfer,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) public payable {\n        // For message with token transfer, message Id is computed through transfer info\n        // in order to guarantee that each transfer can only be used once.\n        bytes32 messageId = verifyTransfer(_transfer);\n        require(executedMessages[messageId] == MsgDataTypes.TxStatus.Null, \"transfer already executed\");\n        executedMessages[messageId] = MsgDataTypes.TxStatus.Pending;\n\n        bytes32 domain = keccak256(abi.encodePacked(block.chainid, address(this), \"MessageWithTransfer\"));\n        IBridge(liquidityBridge).verifySigs(\n            abi.encodePacked(domain, messageId, _message, _transfer.srcTxHash),\n            _sigs,\n            _signers,\n            _powers\n        );\n        MsgDataTypes.TxStatus status;\n        IMessageReceiverApp.ExecutionStatus est = executeMessageWithTransfer(_transfer, _message);\n        if (est == IMessageReceiverApp.ExecutionStatus.Success) {\n            status = MsgDataTypes.TxStatus.Success;\n        } else if (est == IMessageReceiverApp.ExecutionStatus.Retry) {\n            executedMessages[messageId] = MsgDataTypes.TxStatus.Null;\n            emit NeedRetry(\n                MsgDataTypes.MsgType.MessageWithTransfer,\n                messageId,\n                _transfer.srcChainId,\n                _transfer.srcTxHash\n            );\n            return;\n        } else {\n            est = executeMessageWithTransferFallback(_transfer, _message);\n            if (est == IMessageReceiverApp.ExecutionStatus.Success) {\n                status = MsgDataTypes.TxStatus.Fallback;\n            } else {\n                status = MsgDataTypes.TxStatus.Fail;\n            }\n        }\n        executedMessages[messageId] = status;\n        emitMessageWithTransferExecutedEvent(messageId, status, _transfer);\n    }\n\n    /**\n     * @notice Execute a message with a refunded transfer.\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _transfer The transfer info.\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\n     * +2/3 of the sigsVerifier's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function executeMessageWithTransferRefund(\n        bytes calldata _message, // the same message associated with the original transfer\n        MsgDataTypes.TransferInfo calldata _transfer,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) public payable {\n        // similar to executeMessageWithTransfer\n        bytes32 messageId = verifyTransfer(_transfer);\n        require(executedMessages[messageId] == MsgDataTypes.TxStatus.Null, \"transfer already executed\");\n        executedMessages[messageId] = MsgDataTypes.TxStatus.Pending;\n\n        bytes32 domain = keccak256(abi.encodePacked(block.chainid, address(this), \"MessageWithTransferRefund\"));\n        IBridge(liquidityBridge).verifySigs(\n            abi.encodePacked(domain, messageId, _message, _transfer.srcTxHash),\n            _sigs,\n            _signers,\n            _powers\n        );\n        MsgDataTypes.TxStatus status;\n        IMessageReceiverApp.ExecutionStatus est = executeMessageWithTransferRefund(_transfer, _message);\n        if (est == IMessageReceiverApp.ExecutionStatus.Success) {\n            status = MsgDataTypes.TxStatus.Success;\n        } else if (est == IMessageReceiverApp.ExecutionStatus.Retry) {\n            executedMessages[messageId] = MsgDataTypes.TxStatus.Null;\n            emit NeedRetry(\n                MsgDataTypes.MsgType.MessageWithTransfer,\n                messageId,\n                _transfer.srcChainId,\n                _transfer.srcTxHash\n            );\n            return;\n        } else {\n            status = MsgDataTypes.TxStatus.Fail;\n        }\n        executedMessages[messageId] = status;\n        emitMessageWithTransferExecutedEvent(messageId, status, _transfer);\n    }\n\n    /**\n     * @notice Execute a message not associated with a transfer.\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _route The info about the sender and the receiver.\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\n     * +2/3 of the sigsVerifier's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function executeMessage(\n        bytes calldata _message,\n        MsgDataTypes.RouteInfo calldata _route,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external payable {\n        MsgDataTypes.Route memory route = getRouteInfo(_route);\n        executeMessage(_message, route, _sigs, _signers, _powers, \"Message\");\n    }\n\n    // execute message from non-evm chain with bytes for sender address,\n    // otherwise same as above.\n    function executeMessage(\n        bytes calldata _message,\n        MsgDataTypes.RouteInfo2 calldata _route,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external payable {\n        MsgDataTypes.Route memory route = getRouteInfo(_route);\n        executeMessage(_message, route, _sigs, _signers, _powers, \"Message2\");\n    }\n\n    function executeMessage(\n        bytes calldata _message,\n        MsgDataTypes.Route memory _route,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers,\n        string memory domainName\n    ) private {\n        // For message without associated token transfer, message Id is computed through message info,\n        // in order to guarantee that each message can only be applied once\n        bytes32 messageId = computeMessageOnlyId(_route, _message);\n        require(executedMessages[messageId] == MsgDataTypes.TxStatus.Null, \"message already executed\");\n        executedMessages[messageId] = MsgDataTypes.TxStatus.Pending;\n\n        bytes32 domain = keccak256(abi.encodePacked(block.chainid, address(this), domainName));\n        IBridge(liquidityBridge).verifySigs(abi.encodePacked(domain, messageId), _sigs, _signers, _powers);\n        MsgDataTypes.TxStatus status;\n        IMessageReceiverApp.ExecutionStatus est = executeMessage(_route, _message);\n        if (est == IMessageReceiverApp.ExecutionStatus.Success) {\n            status = MsgDataTypes.TxStatus.Success;\n        } else if (est == IMessageReceiverApp.ExecutionStatus.Retry) {\n            executedMessages[messageId] = MsgDataTypes.TxStatus.Null;\n            emit NeedRetry(MsgDataTypes.MsgType.MessageOnly, messageId, _route.srcChainId, _route.srcTxHash);\n            return;\n        } else {\n            status = MsgDataTypes.TxStatus.Fail;\n        }\n        executedMessages[messageId] = status;\n        emitMessageOnlyExecutedEvent(messageId, status, _route);\n    }\n\n    // ================= utils (to avoid stack too deep) =================\n\n    function emitMessageWithTransferExecutedEvent(\n        bytes32 _messageId,\n        MsgDataTypes.TxStatus _status,\n        MsgDataTypes.TransferInfo calldata _transfer\n    ) private {\n        emit Executed(\n            MsgDataTypes.MsgType.MessageWithTransfer,\n            _messageId,\n            _status,\n            _transfer.receiver,\n            _transfer.srcChainId,\n            _transfer.srcTxHash\n        );\n    }\n\n    function emitMessageOnlyExecutedEvent(\n        bytes32 _messageId,\n        MsgDataTypes.TxStatus _status,\n        MsgDataTypes.Route memory _route\n    ) private {\n        emit Executed(\n            MsgDataTypes.MsgType.MessageOnly,\n            _messageId,\n            _status,\n            _route.receiver,\n            _route.srcChainId,\n            _route.srcTxHash\n        );\n    }\n\n    function executeMessageWithTransfer(MsgDataTypes.TransferInfo calldata _transfer, bytes calldata _message)\n        private\n        returns (IMessageReceiverApp.ExecutionStatus)\n    {\n        uint256 gasLeftBeforeExecution = gasleft();\n        (bool ok, bytes memory res) = address(_transfer.receiver).call{value: msg.value}(\n            abi.encodeWithSelector(\n                IMessageReceiverApp.executeMessageWithTransfer.selector,\n                _transfer.sender,\n                _transfer.token,\n                _transfer.amount,\n                _transfer.srcChainId,\n                _message,\n                msg.sender\n            )\n        );\n        if (ok) {\n            return abi.decode((res), (IMessageReceiverApp.ExecutionStatus));\n        }\n        handleExecutionRevert(gasLeftBeforeExecution, res);\n        return IMessageReceiverApp.ExecutionStatus.Fail;\n    }\n\n    function executeMessageWithTransferFallback(MsgDataTypes.TransferInfo calldata _transfer, bytes calldata _message)\n        private\n        returns (IMessageReceiverApp.ExecutionStatus)\n    {\n        uint256 gasLeftBeforeExecution = gasleft();\n        (bool ok, bytes memory res) = address(_transfer.receiver).call{value: msg.value}(\n            abi.encodeWithSelector(\n                IMessageReceiverApp.executeMessageWithTransferFallback.selector,\n                _transfer.sender,\n                _transfer.token,\n                _transfer.amount,\n                _transfer.srcChainId,\n                _message,\n                msg.sender\n            )\n        );\n        if (ok) {\n            return abi.decode((res), (IMessageReceiverApp.ExecutionStatus));\n        }\n        handleExecutionRevert(gasLeftBeforeExecution, res);\n        return IMessageReceiverApp.ExecutionStatus.Fail;\n    }\n\n    function executeMessageWithTransferRefund(MsgDataTypes.TransferInfo calldata _transfer, bytes calldata _message)\n        private\n        returns (IMessageReceiverApp.ExecutionStatus)\n    {\n        uint256 gasLeftBeforeExecution = gasleft();\n        (bool ok, bytes memory res) = address(_transfer.receiver).call{value: msg.value}(\n            abi.encodeWithSelector(\n                IMessageReceiverApp.executeMessageWithTransferRefund.selector,\n                _transfer.token,\n                _transfer.amount,\n                _message,\n                msg.sender\n            )\n        );\n        if (ok) {\n            return abi.decode((res), (IMessageReceiverApp.ExecutionStatus));\n        }\n        handleExecutionRevert(gasLeftBeforeExecution, res);\n        return IMessageReceiverApp.ExecutionStatus.Fail;\n    }\n\n    function verifyTransfer(MsgDataTypes.TransferInfo calldata _transfer) private view returns (bytes32) {\n        bytes32 transferId;\n        address bridgeAddr;\n        MsgDataTypes.TransferType t = _transfer.t;\n        if (t == MsgDataTypes.TransferType.LqRelay) {\n            bridgeAddr = liquidityBridge;\n            transferId = keccak256(\n                abi.encodePacked(\n                    _transfer.sender,\n                    _transfer.receiver,\n                    _transfer.token,\n                    _transfer.amount,\n                    _transfer.srcChainId,\n                    uint64(block.chainid),\n                    _transfer.refId\n                )\n            );\n            require(IBridge(bridgeAddr).transfers(transferId) == true, \"relay not exist\");\n        } else if (t == MsgDataTypes.TransferType.LqWithdraw) {\n            bridgeAddr = liquidityBridge;\n            transferId = keccak256(\n                abi.encodePacked(\n                    uint64(block.chainid),\n                    _transfer.wdseq,\n                    _transfer.receiver,\n                    _transfer.token,\n                    _transfer.amount\n                )\n            );\n            require(IBridge(bridgeAddr).withdraws(transferId) == true, \"withdraw not exist\");\n        } else {\n            if (t == MsgDataTypes.TransferType.PegMint || t == MsgDataTypes.TransferType.PegWithdraw) {\n                bridgeAddr = (t == MsgDataTypes.TransferType.PegMint) ? pegBridge : pegVault;\n                transferId = keccak256(\n                    abi.encodePacked(\n                        _transfer.receiver,\n                        _transfer.token,\n                        _transfer.amount,\n                        _transfer.sender,\n                        _transfer.srcChainId,\n                        _transfer.refId\n                    )\n                );\n            } else {\n                bridgeAddr = (t == MsgDataTypes.TransferType.PegV2Mint) ? pegBridgeV2 : pegVaultV2;\n                transferId = keccak256(\n                    abi.encodePacked(\n                        _transfer.receiver,\n                        _transfer.token,\n                        _transfer.amount,\n                        _transfer.sender,\n                        _transfer.srcChainId,\n                        _transfer.refId,\n                        bridgeAddr\n                    )\n                );\n            }\n            // function is same for peg, peg2, vault, vault2\n            require(IPeggedTokenBridge(bridgeAddr).records(transferId) == true, \"record not exist\");\n        }\n        require(IDelayedTransfer(bridgeAddr).delayedTransfers(transferId).timestamp == 0, \"transfer delayed\");\n        return keccak256(abi.encodePacked(MsgDataTypes.MsgType.MessageWithTransfer, bridgeAddr, transferId));\n    }\n\n    function computeMessageOnlyId(MsgDataTypes.Route memory _route, bytes calldata _message)\n        private\n        view\n        returns (bytes32)\n    {\n        bytes memory sender = _route.senderBytes;\n        if (sender.length == 0) {\n            sender = abi.encodePacked(_route.sender);\n        }\n        return\n            keccak256(\n                abi.encodePacked(\n                    MsgDataTypes.MsgType.MessageOnly,\n                    sender,\n                    _route.receiver,\n                    _route.srcChainId,\n                    _route.srcTxHash,\n                    uint64(block.chainid),\n                    _message\n                )\n            );\n    }\n\n    function executeMessage(MsgDataTypes.Route memory _route, bytes calldata _message)\n        private\n        returns (IMessageReceiverApp.ExecutionStatus)\n    {\n        uint256 gasLeftBeforeExecution = gasleft();\n        bool ok;\n        bytes memory res;\n        if (_route.senderBytes.length == 0) {\n            (ok, res) = address(_route.receiver).call{value: msg.value}(\n                abi.encodeWithSelector(\n                    bytes4(keccak256(bytes(\"executeMessage(address,uint64,bytes,address)\"))),\n                    _route.sender,\n                    _route.srcChainId,\n                    _message,\n                    msg.sender\n                )\n            );\n        } else {\n            (ok, res) = address(_route.receiver).call{value: msg.value}(\n                abi.encodeWithSelector(\n                    bytes4(keccak256(bytes(\"executeMessage(bytes,uint64,bytes,address)\"))),\n                    _route.senderBytes,\n                    _route.srcChainId,\n                    _message,\n                    msg.sender\n                )\n            );\n        }\n        if (ok) {\n            return abi.decode((res), (IMessageReceiverApp.ExecutionStatus));\n        }\n        handleExecutionRevert(gasLeftBeforeExecution, res);\n        return IMessageReceiverApp.ExecutionStatus.Fail;\n    }\n\n    function handleExecutionRevert(uint256 _gasLeftBeforeExecution, bytes memory _returnData) private {\n        uint256 gasLeftAfterExecution = gasleft();\n        uint256 maxTargetGasLimit = block.gaslimit - preExecuteMessageGasUsage;\n        if (_gasLeftBeforeExecution < maxTargetGasLimit && gasLeftAfterExecution <= _gasLeftBeforeExecution / 64) {\n            // if this happens, the executor must have not provided sufficient gas limit,\n            // then the tx should revert instead of recording a non-retryable failure status\n            // https://github.com/wolflo/evm-opcodes/blob/main/gas.md#aa-f-gas-to-send-with-call-operations\n            assembly {\n                invalid()\n            }\n        }\n        string memory revertMsg = Utils.getRevertMsg(_returnData);\n        // revert the execution if the revert message has the ABORT prefix\n        checkAbortPrefix(revertMsg);\n        // otherwiase, emit revert message, return and mark the execution as failed (non-retryable)\n        emit CallReverted(revertMsg);\n    }\n\n    function checkAbortPrefix(string memory _revertMsg) private pure {\n        bytes memory prefixBytes = bytes(MsgDataTypes.ABORT_PREFIX);\n        bytes memory msgBytes = bytes(_revertMsg);\n        if (msgBytes.length >= prefixBytes.length) {\n            for (uint256 i = 0; i < prefixBytes.length; i++) {\n                if (msgBytes[i] != prefixBytes[i]) {\n                    return; // prefix not match, return\n                }\n            }\n            revert(_revertMsg); // prefix match, revert\n        }\n    }\n\n    function getRouteInfo(MsgDataTypes.RouteInfo calldata _route) private pure returns (MsgDataTypes.Route memory) {\n        return MsgDataTypes.Route(_route.sender, \"\", _route.receiver, _route.srcChainId, _route.srcTxHash);\n    }\n\n    function getRouteInfo(MsgDataTypes.RouteInfo2 calldata _route) private pure returns (MsgDataTypes.Route memory) {\n        return MsgDataTypes.Route(address(0), _route.sender, _route.receiver, _route.srcChainId, _route.srcTxHash);\n    }\n\n    // ================= helper functions =====================\n\n    /**\n     * @notice combine bridge transfer and msg execution calls into a single tx\n     * @dev caller needs to get the required input params from SGN\n     * @param _tp params to call bridge transfer\n     * @param _mp params to execute message\n     */\n    function transferAndExecuteMsg(\n        MsgDataTypes.BridgeTransferParams calldata _tp,\n        MsgDataTypes.MsgWithTransferExecutionParams calldata _mp\n    ) external {\n        _bridgeTransfer(_mp.transfer.t, _tp);\n        executeMessageWithTransfer(_mp.message, _mp.transfer, _mp.sigs, _mp.signers, _mp.powers);\n    }\n\n    /**\n     * @notice combine bridge refund and msg execution calls into a single tx\n     * @dev caller needs to get the required input params from SGN\n     * @param _tp params to call bridge transfer for refund\n     * @param _mp params to execute message for refund\n     */\n    function refundAndExecuteMsg(\n        MsgDataTypes.BridgeTransferParams calldata _tp,\n        MsgDataTypes.MsgWithTransferExecutionParams calldata _mp\n    ) external {\n        _bridgeTransfer(_mp.transfer.t, _tp);\n        executeMessageWithTransferRefund(_mp.message, _mp.transfer, _mp.sigs, _mp.signers, _mp.powers);\n    }\n\n    function _bridgeTransfer(MsgDataTypes.TransferType t, MsgDataTypes.BridgeTransferParams calldata _params) private {\n        if (t == MsgDataTypes.TransferType.LqRelay) {\n            IBridge(liquidityBridge).relay(_params.request, _params.sigs, _params.signers, _params.powers);\n        } else if (t == MsgDataTypes.TransferType.LqWithdraw) {\n            IBridge(liquidityBridge).withdraw(_params.request, _params.sigs, _params.signers, _params.powers);\n        } else if (t == MsgDataTypes.TransferType.PegMint) {\n            IPeggedTokenBridge(pegBridge).mint(_params.request, _params.sigs, _params.signers, _params.powers);\n        } else if (t == MsgDataTypes.TransferType.PegV2Mint) {\n            IPeggedTokenBridgeV2(pegBridgeV2).mint(_params.request, _params.sigs, _params.signers, _params.powers);\n        } else if (t == MsgDataTypes.TransferType.PegWithdraw) {\n            IOriginalTokenVault(pegVault).withdraw(_params.request, _params.sigs, _params.signers, _params.powers);\n        } else if (t == MsgDataTypes.TransferType.PegV2Withdraw) {\n            IOriginalTokenVaultV2(pegVaultV2).withdraw(_params.request, _params.sigs, _params.signers, _params.powers);\n        }\n    }\n\n    // ================= contract config =================\n\n    function setLiquidityBridge(address _addr) public onlyOwner {\n        require(_addr != address(0), \"invalid address\");\n        liquidityBridge = _addr;\n        emit LiquidityBridgeUpdated(liquidityBridge);\n    }\n\n    function setPegBridge(address _addr) public onlyOwner {\n        require(_addr != address(0), \"invalid address\");\n        pegBridge = _addr;\n        emit PegBridgeUpdated(pegBridge);\n    }\n\n    function setPegVault(address _addr) public onlyOwner {\n        require(_addr != address(0), \"invalid address\");\n        pegVault = _addr;\n        emit PegVaultUpdated(pegVault);\n    }\n\n    function setPegBridgeV2(address _addr) public onlyOwner {\n        require(_addr != address(0), \"invalid address\");\n        pegBridgeV2 = _addr;\n        emit PegBridgeV2Updated(pegBridgeV2);\n    }\n\n    function setPegVaultV2(address _addr) public onlyOwner {\n        require(_addr != address(0), \"invalid address\");\n        pegVaultV2 = _addr;\n        emit PegVaultV2Updated(pegVaultV2);\n    }\n\n    function setPreExecuteMessageGasUsage(uint256 _usage) public onlyOwner {\n        preExecuteMessageGasUsage = _usage;\n    }\n}\n"
    },
    "celer/contracts/safeguard/Ownable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n *\n * This adds a normal func that setOwner if _owner is address(0). So we can't allow\n * renounceOwnership. So we can support Proxy based upgradable contract\n */\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(msg.sender);\n    }\n\n    /**\n     * @dev Only to be called by inherit contracts, in their init func called by Proxy\n     * we require _owner == address(0), which is only possible when it's a delegateCall\n     * because constructor sets _owner in contract state.\n     */\n    function initOwner() internal {\n        require(_owner == address(0), \"owner already set\");\n        _setOwner(msg.sender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/__mocks__/CelerFeeHubFacetMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.17;\n\nimport { ICelerFeeHubFacet } from \"../diamond/interfaces/ICelerFeeHubFacet.sol\";\n\ncontract CelerFeeHubFacetMock is ICelerFeeHubFacet {\n    event deployFeesWithCelerConfirmEvent(uint64 _chainId, bytes _message);\n\n    function deployFeesWithCelerConfirm(uint64 _chainId, bytes memory _message) external {\n        emit deployFeesWithCelerConfirmEvent(_chainId, _message);\n    }\n}\n"
    },
    "contracts/__mocks__/DepositableMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.17;\n\nimport { IERC20, SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IDepositable } from \"./../diamond/interfaces/IDepositable.sol\";\n\ncontract DepositableMock is IDepositable {\n    using SafeERC20 for IERC20;\n\n    event depositEvent(address _token, uint256 _amount);\n\n    function deposit(address _token, uint256 _amount) external {\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n        emit depositEvent(_token, _amount);\n    }\n}\n"
    },
    "contracts/__mocks__/ERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.9;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { ERC20Pausable } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol\";\n\ncontract ERC20Mock is ERC20Pausable {\n    constructor() ERC20(\"ERC20Mock\", \"ERC20Mock\") {\n        _mint(msg.sender, 1000 * 10 ** decimals());\n    }\n\n    function mint(address to, uint256 amount) public {\n        _mint(to, amount);\n    }\n\n    function disable() public {\n        _pause();\n    }\n\n    function enable() public {\n        _unpause();\n    }\n}\n"
    },
    "contracts/__mocks__/FeeDistributorFacetMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.19;\n\nimport { IFeeDistributorFacet } from \"./../diamond/interfaces/IFeeDistributorFacet.sol\";\nimport { FeeConfigSyncHomeDTO } from \"./../diamond/helpers/Structs.sol\";\n\ncontract FeeDistributorFacetMock is IFeeDistributorFacet {\n    event pushFeesEvent(address _token, uint256 _amount, FeeConfigSyncHomeDTO _dto, uint256 _value, uint256 _gas);\n\n    function pushFees(address _token, uint256 _amount, FeeConfigSyncHomeDTO calldata _dto) external payable {\n        emit pushFeesEvent(_token, _amount, _dto, msg.value, gasleft());\n    }\n}\n"
    },
    "contracts/__mocks__/FeeStoreFacetMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.19;\n\nimport { IFeeStoreFacet } from \"./../diamond/interfaces/IFeeStoreFacet.sol\";\nimport { FeeConfigSyncHomeDTO, FeeConfigSyncHomeFees, FeeConfigSyncDTO, FeeStoreConfig } from \"./../diamond/helpers/Structs.sol\";\nimport { LibFeeStore } from \"./../diamond/libraries/LibFeeStore.sol\";\nimport { LibFeeStoreStorage } from \"./../diamond/libraries/LibFeeStoreStorage.sol\";\n\ncontract FeeStoreFacetMock is IFeeStoreFacet {\n    event prepareToSendFeesEvent();\n\n    function prepareToSendFeesSETUP(uint256[] calldata _amounts, FeeStoreConfig[] calldata _feeStoreConfig) external {\n        LibFeeStoreStorage.FeeStoreStorage storage s = LibFeeStoreStorage.feeStoreStorage();\n        for (uint256 i = 0; i < _feeStoreConfig.length; ) {\n            FeeStoreConfig memory fmem = _feeStoreConfig[i];\n            FeeStoreConfig storage fstore = s.feeConfigs[_feeStoreConfig[i].id];\n            fstore.id = fmem.id;\n            fstore.fee = fmem.fee;\n            fstore.target = fmem.target;\n            fstore.deleted = fmem.deleted;\n            s.feeConfigIds.push(fmem.id);\n            s.collectedFeesTotal += _amounts[i];\n            s.collectedFees[fmem.id] += _amounts[i];\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    function prepareToSendFees() external returns (FeeConfigSyncHomeDTO memory _dto) {\n        return LibFeeStore.prepareToSendFees();\n    }\n\n    function syncFees(FeeConfigSyncDTO[] calldata _feeConfigSyncDTO) external payable {}\n\n    event restoreFeesFromSendFeesEvent(FeeConfigSyncHomeDTO _dto);\n\n    function restoreFeesFromSendFees(FeeConfigSyncHomeDTO memory _dto) external payable {\n        emit restoreFeesFromSendFeesEvent(_dto);\n    }\n\n    function getFeeStoreConfig(bytes32 _id) external view returns (FeeStoreConfig memory _feeStoreConfig) {}\n\n    function setIntermediateAsset(address _intermediateAsset) external {\n        LibFeeStore.setIntermediateAsset(_intermediateAsset);\n    }\n}\n"
    },
    "contracts/__mocks__/FeeStoreTestingDummyFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.19;\n\nimport { FeeConfigSyncHomeDTO } from \"./../diamond/helpers/Structs.sol\";\nimport { IFeeStoreFacet } from \"./../diamond/interfaces/IFeeStoreFacet.sol\";\nimport { LibFeeStore } from \"./../diamond/libraries/LibFeeStore.sol\";\n\ncontract FeeStoreTestingDummyFacet {\n    function prepareToSendFeesTest() external returns (FeeConfigSyncHomeDTO memory _messageData) {\n        return LibFeeStore.prepareToSendFees();\n    }\n\n    function calcFeesRelative(\n        bytes32 _feeConfigId,\n        address _asset,\n        uint256 _amount\n    ) external view returns (uint256 _amountNet, uint256 _fee, uint256 _feePoints) {\n        return LibFeeStore.calcFeesRelative(_feeConfigId, _asset, _amount);\n    }\n\n    function calcFeesAbsolute(\n        bytes32 _feeConfigId,\n        address _asset,\n        uint256 _amount\n    ) external view returns (uint256 _amountNet, uint256 _fee, uint256 _feePoints) {\n        return LibFeeStore.calcFeesAbsolute(_feeConfigId, _asset, _amount);\n    }\n\n    function putFees(bytes32 _feeConfigId, uint256 _amount) external {\n        LibFeeStore.putFees(_feeConfigId, _amount);\n    }\n}\n"
    },
    "contracts/__mocks__/NativeWrapperMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.19;\n\ncontract NativeWrapperMock {\n    uint256 constant MAX_UINT = 2 ** 256 - 1;\n\n    string public name = \"Wrapped Native\";\n    string public symbol = \"WNATIVE\";\n    uint8 public decimals = 18;\n\n    event Approval(address indexed src, address indexed guy, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    receive() external payable {\n        deposit();\n    }\n\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 wad) public {\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] -= wad;\n        payable(msg.sender).transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint256 wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint256 wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint256 wad) public returns (bool) {\n        require(balanceOf[src] >= wad);\n\n        if (src != msg.sender && allowance[src][msg.sender] != MAX_UINT) {\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}\n"
    },
    "contracts/__mocks__/SwapRouterMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.19;\n\nimport { IRouter02 } from \"./../diamond/interfaces/IRouter02.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IWAVAX {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n}\n\ncontract SwapRouterMock is IRouter02 {\n    address immutable lp;\n    address immutable nativeWrapper;\n\n    event swapExactTokensForTokensEvent();\n    event swapExactTokensForAVAXEvent();\n    event swapExactAVAXForTokensEvent();\n\n    constructor(address _lp, address _nativeWrapper) {\n        lp = _lp;\n        nativeWrapper = _nativeWrapper;\n    }\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256,\n        address[] calldata path,\n        address to,\n        uint256\n    ) external returns (uint256[] memory amounts) {\n        amounts = new uint256[](path.length);\n        amounts[0] = amountIn;\n        amounts[path.length - 1] = amountIn;\n        IERC20(path[0]).transferFrom(msg.sender, lp, amountIn);\n        IERC20(path[path.length - 1]).transferFrom(lp, to, amounts[path.length - 1]);\n        emit swapExactTokensForTokensEvent();\n    }\n\n    function swapExactTokensForAVAX(\n        uint256 amountIn,\n        uint256,\n        address[] calldata path,\n        address to,\n        uint256\n    ) external returns (uint256[] memory amounts) {\n        amounts = new uint256[](path.length);\n        amounts[0] = amountIn;\n        amounts[path.length - 1] = amountIn;\n        IERC20(path[0]).transferFrom(msg.sender, lp, amountIn);\n        IERC20(path[path.length - 1]).transferFrom(lp, address(this), amounts[path.length - 1]);\n        IWAVAX(path[path.length - 1]).withdraw(amounts[path.length - 1]);\n        (bool sent, ) = payable(to).call{ value: amountIn }(\"\");\n        sent;\n        emit swapExactTokensForAVAXEvent();\n    }\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256,\n        address[] calldata path,\n        address to,\n        uint256\n    ) external returns (uint256[] memory amounts) {\n        amounts = new uint256[](path.length);\n        amounts[0] = amountIn;\n        amounts[path.length - 1] = amountIn;\n        IERC20(path[0]).transferFrom(msg.sender, lp, amountIn);\n        IERC20(path[path.length - 1]).transferFrom(lp, address(this), amounts[path.length - 1]);\n        IWAVAX(path[path.length - 1]).withdraw(amounts[path.length - 1]);\n        (bool sent, ) = payable(to).call{ value: amountIn }(\"\");\n        sent;\n        emit swapExactTokensForAVAXEvent();\n    }\n\n    function swapExactAVAXForTokens(\n        uint256,\n        address[] calldata path,\n        address to,\n        uint256\n    ) external payable returns (uint256[] memory amounts) {\n        amounts = new uint256[](path.length);\n        amounts[0] = msg.value;\n        amounts[path.length - 1] = msg.value;\n        IWAVAX(path[0]).deposit{ value: msg.value }();\n        IERC20(path[0]).transfer(lp, msg.value);\n        IERC20(path[path.length - 1]).transferFrom(lp, to, msg.value);\n        emit swapExactAVAXForTokensEvent();\n    }\n\n    function swapExactETHForTokens(\n        uint256,\n        address[] calldata path,\n        address to,\n        uint256\n    ) external payable returns (uint256[] memory amounts) {\n        amounts = new uint256[](path.length);\n        amounts[0] = msg.value;\n        amounts[path.length - 1] = msg.value;\n        IWAVAX(path[0]).deposit{ value: msg.value }();\n        IERC20(path[0]).transfer(lp, msg.value);\n        IERC20(path[path.length - 1]).transferFrom(lp, to, msg.value);\n        emit swapExactAVAXForTokensEvent();\n    }\n\n    bool public getAmountsOutSuccess = true;\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts) {\n        if (!getAmountsOutSuccess) {\n            revert(\"nope\");\n        }\n        amounts = new uint256[](path.length);\n        amounts[0] = amountIn;\n        amounts[path.length - 1] = 1337 * 10 ** 18;\n    }\n\n    function setGetAmountsOutSuccess(bool _success) external {\n        getAmountsOutSuccess = _success;\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/DegenATM.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.19;\n\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport { IERC20Facet } from \"./diamond/interfaces/IERC20Facet.sol\";\n\n/// @title Degen ATM\n/// @author Daniel <danieldegendev@gmail.com>\n/// @notice Funds collecting and vesting smart contract\n/// @custom:version 1.0.0\ncontract DegenATM is Ownable, ReentrancyGuard {\n    using Address for address payable;\n\n    uint256 public constant LOCK_PERIOD = 31_536_000; // 365 days\n    uint256 public constant DENOMINATOR = 10_000_000;\n    uint256 public constant TOTAL_REWARD_BPS = 2_400; // 24%\n    uint256 public constant REWARD_PENALTY_BPS = 7_000; // 70%\n\n    bool public claiming;\n    bool public collecting;\n    uint256 public totalDeposits;\n    uint256 public startTimestamp;\n    uint256 public allocationLimit = 3 * 10 ** 18;\n    uint256 public totalLockedTokens;\n    uint256 public tokensPerOneNative;\n    uint256 public totalClaimedTokens;\n    address public token;\n    mapping(address => bool) public locked;\n    mapping(address => bool) public claimed;\n    mapping(address => bool) public whitelist;\n    mapping(address => uint256) public deposits;\n    mapping(address => uint256) public lockedAmount;\n    mapping(address => uint256) public claimedAmount;\n\n    event Deposit(address depositer, uint256 amount);\n    event Claimed(address claimer, uint256 amount);\n    event LockJoin(address locker, uint256 amount);\n    event LockLeave(address locker, uint256 amount, uint256 reward, uint256 penalty);\n    event CollectingEnabled();\n    event CollectingDisabled();\n    event ClaimingEnabled();\n    event ClaimingDisabled();\n    event LockingEnabled();\n    event LockingDisabled();\n    event UpdatedAllocationRate(uint256 rate);\n    event UpdatedAllocationLimit(uint256 limit);\n    event UpdatedToken(address token);\n    event AddToWhitelist(address candidate);\n    event RemoveFromWhitelist(address candidate);\n    event StartLockPeriod();\n\n    modifier qualifyCheck() {\n        _checkQualification();\n        _;\n    }\n\n    /// Deposit native token\n    function deposit() external payable {\n        _deposit(msg.value, _msgSender());\n    }\n\n    /// Claiming the tokens\n    /// @notice claiming is only possible when the claiming period has started\n    /// @dev it also makes some qualify checks whether sender is allowed to execute, otherwise it reverts\n    /// @dev possible to execute when claming is started\n    function claimTokens() external nonReentrant qualifyCheck {\n        if (!claiming) revert(\"not started\");\n        uint256 _amount = _calcClaimAmount(_msgSender());\n        if (!IERC20(token).transfer(_msgSender(), _amount)) revert(\"payout failed\");\n        claimed[_msgSender()] = true;\n        claimedAmount[_msgSender()] = _amount;\n        totalClaimedTokens += _amount;\n        emit Claimed(_msgSender(), _amount);\n    }\n\n    /// Locks the tokens\n    /// @notice the sender will enter a lock state with his allocated amount of tokens\n    /// @dev it also makes some qualify checks whether sender is allowed to execute, otherwise it reverts\n    /// @dev possible to execute when claming is started\n    function lockJoin() external qualifyCheck {\n        if (!claiming) revert(\"not started\");\n        if (startTimestamp > 0) revert(\"lock not possible anymore\");\n        uint256 _amount = _calcClaimAmount(_msgSender());\n        locked[_msgSender()] = true;\n        lockedAmount[_msgSender()] = _amount;\n        totalLockedTokens += _amount;\n        emit LockJoin(_msgSender(), _amount);\n    }\n\n    /// Leaves the lock of the tokens\n    /// @notice The sender will leave the locked state if he has joined it.\n    /// @notice After leaving, he will auto claim the tokens and not be able to join the lock anymore.\n    /// @notice The sender can leave at any time. Before the lock period, he has not gained any rewards\n    /// @notice and claims only his initial allocated amount of tokens. If the lock period has started\n    /// @notice and not ended yet, the sender will receive his initial allocated tokens with 30% of the\n    /// @notice rewards, because of the desined penalty when leaving the locked state before end of period.\n    /// @notice After the lock period has ended, the sender will receive the allocated amount of tokens\n    /// @notice and the full amount of rewards.\n    function lockLeave() external nonReentrant {\n        if (!locked[_msgSender()]) revert(\"not locked\");\n        uint256 _penalty = 0;\n        uint256 _reward = 0;\n        uint256 _amount = lockedAmount[_msgSender()];\n        locked[_msgSender()] = false;\n        lockedAmount[_msgSender()] = 0;\n        totalLockedTokens -= _amount;\n\n        if (startTimestamp > 0) {\n            (, _penalty, _reward) = _calcRewards(_amount, startTimestamp);\n            _amount += _reward;\n        } else emit Claimed(_msgSender(), _amount);\n\n        if (!IERC20(token).transfer(_msgSender(), _amount)) revert(\"payout failed\");\n        claimed[_msgSender()] = true;\n        claimedAmount[_msgSender()] = _amount;\n        totalClaimedTokens += _amount;\n\n        emit LockLeave(_msgSender(), _amount, _reward, _penalty);\n    }\n\n    /// viewables\n\n    struct StatsForQualifier {\n        bool isWhitelisted;\n        bool hasClaimed;\n        bool hasLocked;\n        uint256 tokenBalance;\n        uint256 lockedAmount;\n        uint256 claimedAmount;\n        uint256 totalDeposited;\n        uint256 currentRewardAmount;\n        uint256 currentPenaltyAmount;\n        uint256 currentRewardAmountNet;\n        uint256 estimatedTotalRewardAmount;\n        uint256 estimatedTotalClaimAmount;\n    }\n\n    /// Returns atm stats for a given qualifier\n    /// @param _qualifier address of the account\n    /// @return _stats statistics for a qualifier\n    /// @dev `isWhitelisted` flag if the qualifier is whitelisted or not\n    /// @dev `hasClaimed` flag if the qualifier has claimed his tokens\n    /// @dev `hasLocked` flag if the qualifier has locked his tokens\n    /// @dev `tokenBalance` qualifiers balance of the token\n    /// @dev `lockedAmount` amount of locked tokens\n    /// @dev `claimedAmount` amount of claimed tokens\n    /// @dev `totalDeposited` amount of deposited native\n    /// @dev `currentRewardAmount` returns the current reward amount (only if lock period has started, else 0)\n    /// @dev `currentPenaltyAmount` returns the current penalty amount if the qualifier leaves the lock (only if lock period has started, else 0)\n    /// @dev `currentRewardAmountNet` returns the current rewart amount excl. penalty amount (only if lock period has started, else 0)\n    /// @dev `estimatedTotalRewardAmount` potential amount of rewards qualifier receives after whole lock period\n    /// @dev `estimatedTotalClaimAmount` potential total amount (accumulated + rewards) which the qualifier will receive after whole lock period\n    function getStatsForQualifier(address _qualifier) external view returns (StatsForQualifier memory _stats) {\n        uint256 _amount = locked[_qualifier] ? lockedAmount[_qualifier] : _calcClaimAmount(_qualifier);\n        (uint256 _currentRewardAmount, uint256 _currentPenaltyAmount, uint256 _currentRewardAmountNet) = _calcRewards(\n            lockedAmount[_qualifier],\n            startTimestamp > 0 ? startTimestamp : block.timestamp\n        );\n        _stats = StatsForQualifier(\n            whitelist[_qualifier],\n            claimed[_qualifier],\n            locked[_qualifier],\n            token != address(0) ? IERC20(token).balanceOf(_qualifier) : 0,\n            lockedAmount[_qualifier],\n            claimedAmount[_qualifier],\n            deposits[_qualifier],\n            _currentRewardAmount,\n            _currentPenaltyAmount,\n            _currentRewardAmountNet,\n            (_amount * TOTAL_REWARD_BPS) / 10_000,\n            _amount + (_amount * TOTAL_REWARD_BPS) / 10_000\n        );\n    }\n\n    struct Stats {\n        bool collecting;\n        bool claiming;\n        bool lockPeriodActive;\n        address token;\n        uint256 tokenBalance;\n        uint256 allocationLimit;\n        uint256 tokensPerOneNative;\n        uint256 totalDeposits;\n        uint256 totalLockedTokens;\n        uint256 totalClaimedTokens;\n        uint256 estimatedTotalLockedTokensRewards;\n        uint256 estimatedTotalLockedTokensPayouts;\n        uint256 estimatedTotalTokensPayout;\n        uint256 lockPeriodStarts;\n        uint256 lockPeriodEnds;\n        uint256 lockPeriodInSeconds;\n        uint256 rewardPenaltyBps;\n        uint256 totalRewardBps;\n    }\n\n    /// Returns general atm stats\n    /// @return _stats statistics for a qualifier\n    /// @dev `collecting` flag if the native token collection has started or not\n    /// @dev `claiming` flag if the claiming has started or not (will enable claiming and locking functionality)\n    /// @dev `lockPeriodActive` flag is the lock period has started\n    /// @dev `token` address of the token\n    /// @dev `tokenBalance` contract balance of the token\n    /// @dev `allocationLimit` defined alloctaion limit\n    /// @dev `tokensPerOneNative` defined tokens per one native\n    /// @dev `totalDeposits` total amount of native deposits\n    /// @dev `totalLockedTokens` total amount of locked tokens\n    /// @dev `totalClaimedTokens` total amount of claimed tokens\n    /// @dev `estimatedTotalLockedTokensRewards` estimated amount of total rewards paid for current locked tokens\n    /// @dev `estimatedTotalLockedTokensPayouts` estimated amount of tokens incl. rewards which are getting paid out\n    /// @dev `estimatedTotalTokensPayout` estimated amount of ALL possible paid out tokens (claimed + locked + rewards)\n    /// @dev `lockPeriodStarts` the timestamp when the lock period starts\n    /// @dev `lockPeriodEnds` the timestamp when the lock period ends\n    /// @dev `lockPeriodInSeconds` lock period in seconds which result in 365d or 1y\n    /// @dev `rewardPenaltyBps` % loyalty penalty in basis points\n    /// @dev `totalRewardBps` % reward in basis points\n    function getStats() external view returns (Stats memory _stats) {\n        _stats = Stats(\n            collecting,\n            claiming,\n            startTimestamp > 0,\n            token,\n            token != address(0) ? IERC20(token).balanceOf(address(this)) : 0,\n            allocationLimit,\n            tokensPerOneNative,\n            totalDeposits,\n            totalLockedTokens,\n            totalClaimedTokens,\n            (totalLockedTokens * TOTAL_REWARD_BPS) / 10_000,\n            totalLockedTokens + ((totalLockedTokens * TOTAL_REWARD_BPS) / 10_000),\n            ((totalDeposits * tokensPerOneNative) / 10 ** 18) + ((totalLockedTokens * TOTAL_REWARD_BPS) / 10_000),\n            startTimestamp,\n            startTimestamp > 0 ? startTimestamp + LOCK_PERIOD : 0,\n            LOCK_PERIOD,\n            REWARD_PENALTY_BPS,\n            TOTAL_REWARD_BPS\n        );\n    }\n\n    /// admin\n\n    /// Starts the lock period\n    function startLockPeriod() external onlyOwner {\n        if (!claiming) revert(\"not started\");\n        if (startTimestamp > 0) revert(\"lock period already started\");\n        startTimestamp = block.timestamp;\n        emit StartLockPeriod();\n    }\n\n    /// Recovers the native funds and sends it to the owner\n    function recoverNative() external onlyOwner {\n        uint256 _balance = address(this).balance;\n        if (_balance > 0) payable(owner()).sendValue(_balance);\n    }\n\n    /// Recovers the tokens and sends it to the owner\n    function recoverTokens(address _asset) external onlyOwner {\n        uint256 _balance = IERC20(_asset).balanceOf(address(this));\n        if (_balance > 0) IERC20(_asset).transfer(owner(), _balance);\n    }\n\n    /// Sets the state of the claiming\n    /// @param _enable true enables, false disables\n    /// @dev when enabling, automaticall disabled collectiong flag and vice versa\n    function enableClaiming(bool _enable) external onlyOwner {\n        if (_enable && tokensPerOneNative == 0) revert(\"no rate set\");\n        claiming = _enable;\n        enableCollecting(!_enable);\n        if (_enable) emit ClaimingEnabled();\n        else emit ClaimingDisabled();\n    }\n\n    /// Sets the state of the collecting\n    /// @param _enable true enables, false disables\n    function enableCollecting(bool _enable) public onlyOwner {\n        collecting = _enable;\n        if (_enable) emit CollectingEnabled();\n        else emit CollectingDisabled();\n    }\n\n    /// Sets the allocation rate\n    /// @param _rate amount of tokens\n    /// @notice this number is used to calculate the accumulated token\n    function setAllocationRate(uint256 _rate) external onlyOwner {\n        tokensPerOneNative = _rate;\n        emit UpdatedAllocationRate(_rate);\n    }\n\n    /// Sets the deposit limit for accounts\n    /// @param _limit amount of native token a participant can deposit\n    function setAllocationLimit(uint256 _limit) external onlyOwner {\n        allocationLimit = _limit;\n        emit UpdatedAllocationLimit(_limit);\n    }\n\n    /// Sets the token address which to pay out\n    /// @param _token address of the token\n    function setToken(address _token) external onlyOwner {\n        if (claiming) revert(\"claiming already started\");\n        token = _token;\n        emit UpdatedToken(_token);\n    }\n\n    /// Adds an account to the whitelist\n    /// @param _account address of the participant\n    function addToWhitelist(address _account) public onlyOwner {\n        whitelist[_account] = true;\n        emit AddToWhitelist(_account);\n    }\n\n    /// Adds multiple accounts to the whitelist\n    /// @param _accounts array of addresses of participants\n    function addToWhitelistInBulk(address[] calldata _accounts) external onlyOwner {\n        for (uint256 i = 0; i < _accounts.length; i++) addToWhitelist(_accounts[i]);\n    }\n\n    /// Removes the address from the whitelist\n    /// @param _account address of the participant\n    /// @notice When the address is being removed and has already deposited, this amount will be sent back to the account\n    function removeFromWhitelist(address payable _account) external onlyOwner {\n        uint256 _returnAmount = deposits[_account];\n        if (_returnAmount > 0) {\n            delete deposits[_account];\n            totalDeposits -= _returnAmount;\n            _account.sendValue(_returnAmount);\n        }\n        delete whitelist[_account];\n        emit RemoveFromWhitelist(_account);\n    }\n\n    /// internals\n\n    function _checkQualification() internal view {\n        if (!whitelist[_msgSender()]) revert(\"not whitelisted\");\n        if (deposits[_msgSender()] == 0) revert(\"not deposited\");\n        if (claimed[_msgSender()]) revert(\"already claimed\");\n        if (locked[_msgSender()]) revert(\"already locked\");\n    }\n\n    function _deposit(uint256 _amount, address _sender) internal nonReentrant {\n        if (!collecting) revert(\"not started\");\n        if (!whitelist[_sender]) revert(\"not whitelisted\");\n        uint256 _depositAmount = _amount;\n        uint256 _actual = deposits[_sender] + _depositAmount;\n        if (_actual > allocationLimit) {\n            uint256 _sendBack = _actual - allocationLimit;\n            payable(_sender).sendValue(_sendBack);\n            _depositAmount = allocationLimit - deposits[_sender];\n        }\n        deposits[_sender] += _depositAmount;\n        totalDeposits += _depositAmount;\n        emit Deposit(_sender, _amount);\n    }\n\n    function _calcClaimAmount(address _depositer) internal view returns (uint256 _amount) {\n        return (tokensPerOneNative * deposits[_depositer]) / 10 ** 18;\n    }\n\n    // function _calcClaimAmountTotal() internal view returns (uint256 _amount) {\n    //     return (tokensPerOneNative * totalDeposits) / 10 ** 18;\n    // }\n\n    function _calcRewards(\n        uint256 _lockedAmount,\n        uint256 _startTimestamp\n    ) internal view returns (uint256 _amount, uint256 _penalty, uint256 _amountNet) {\n        _amount = (_lockedAmount * TOTAL_REWARD_BPS) / 10_000;\n        _amountNet = _amount;\n        if (block.timestamp > _startTimestamp && block.timestamp < _startTimestamp + LOCK_PERIOD) {\n            _amount = (((_amount * DENOMINATOR) / LOCK_PERIOD) * (block.timestamp - _startTimestamp)) / DENOMINATOR;\n            _penalty = (_amount * REWARD_PENALTY_BPS) / 10_000;\n        } else if (block.timestamp <= _startTimestamp) {\n            _amount = 0;\n            _amountNet = 0;\n        }\n\n        _amountNet = _amount - _penalty;\n    }\n\n    /// receiver\n    receive() external payable {\n        _deposit(msg.value, _msgSender());\n    }\n}\n"
    },
    "contracts/diamond/DegenX.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.19;\n\nimport { Diamond } from \"./Diamond.sol\";\n\n/// @title DegenX Ecosystem Diamond\n/// @author Daniel <danieldegendev@gmail.com>\n/// @custom:version 1.0.0\ncontract DegenX is Diamond {\n    constructor(address _owner, address _diamondCutFacet) payable Diamond(_owner, _diamondCutFacet) {}\n}\n"
    },
    "contracts/diamond/Diamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport { LibAccessControlEnumerable } from \"./libraries/LibAccessControlEnumerable.sol\";\nimport { Constants } from \"./helpers/Constants.sol\";\nimport { LibDiamond } from \"./libraries/LibDiamond.sol\";\nimport { IDiamondCut } from \"./interfaces/IDiamondCut.sol\";\n\n/// @custom:version 1.0.0\ncontract Diamond {\n    constructor(address _owner, address _diamondCutFacet) payable {\n        LibDiamond.setContractOwner(_owner);\n\n        // Add the diamondCut external function from the diamondCutFacet\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\n        bytes4[] memory functionSelectors = new bytes4[](1);\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\n        cut[0] = IDiamondCut.FacetCut({\n            facetAddress: _diamondCutFacet,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: functionSelectors\n        });\n\n        LibDiamond.diamondCut(cut, address(0), \"\");\n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    fallback() external payable {\n        LibDiamond.DiamondStorage storage ds;\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n        // get diamond storage\n        assembly {\n            ds.slot := position\n        }\n        // get facet from function selector\n        address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\n        require(facet != address(0), \"Diamond: Function does not exist\");\n        // Execute external function from facet using delegatecall and return any value.\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/diamond/facets/AccessControlEnumerableFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"../libraries/LibAccessControlEnumerable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/access/IAccessControlEnumerable.sol\";\n\n/// @custom:version 1.0.0\ncontract AccessControlEnumerableFacet is IAccessControlEnumerable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    function hasRole(bytes32 role, address account) external view override returns (bool) {\n        return LibAccessControlEnumerable.hasRole(role, account);\n    }\n\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        LibAccessControlEnumerable.AccessControlStorage storage acs = LibAccessControlEnumerable.accessControlStorage();\n        return acs.roles[role].adminRole;\n    }\n\n    function grantRole(bytes32 role, address account) external override {\n        LibAccessControlEnumerable.checkRole(getRoleAdmin(role), msg.sender);\n        LibAccessControlEnumerable.grantRole(role, account);\n    }\n\n    function revokeRole(bytes32 role, address account) external override {\n        LibAccessControlEnumerable.checkRole(getRoleAdmin(role), msg.sender);\n        LibAccessControlEnumerable.revokeRole(role, account);\n    }\n\n    function renounceRole(bytes32 role, address account) external override {\n        require(account == msg.sender, \"AccessControlEnumerableFacet: can only renounce roles for self\");\n        LibAccessControlEnumerable.revokeRole(role, account);\n    }\n\n    function getRoleMember(bytes32 role, uint256 index) external view override returns (address) {\n        LibAccessControlEnumerable.AccessControlStorage storage acs = LibAccessControlEnumerable.accessControlStorage();\n        return acs.roleMembers[role].at(index);\n    }\n\n    function getRoleMemberCount(bytes32 role) external view override returns (uint256) {\n        LibAccessControlEnumerable.AccessControlStorage storage acs = LibAccessControlEnumerable.accessControlStorage();\n        return acs.roleMembers[role].length();\n    }\n}\n"
    },
    "contracts/diamond/facets/CelerFeeHubFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.19;\n\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { IERC20 } from \"@solidstate/contracts/interfaces/IERC20.sol\";\nimport { SafeERC20 } from \"@solidstate/contracts/utils/SafeERC20.sol\";\nimport { IFeeDistributorFacet } from \"./../interfaces/IFeeDistributorFacet.sol\";\nimport { ICelerFeeHubFacet } from \"./../interfaces/ICelerFeeHubFacet.sol\";\nimport { IFeeStoreFacet } from \"./../interfaces/IFeeStoreFacet.sol\";\nimport { IRelayerCeler } from \"./../interfaces/IRelayerCeler.sol\";\nimport { LibAccessControlEnumerable } from \"./../libraries/LibAccessControlEnumerable.sol\";\nimport { LibFeeManagerStorage } from \"./../libraries/LibFeeManagerStorage.sol\";\nimport { LibFeeManager } from \"./../libraries/LibFeeManager.sol\";\nimport { LibFeeStore } from \"./../libraries/LibFeeStore.sol\";\nimport { LibDiamond } from \"./../libraries/LibDiamond.sol\";\nimport { FeeConfig, FeeConfigSyncDTO, FeeConfigSyncHomeDTO, FeeSyncQueue } from \"./../helpers/Structs.sol\";\nimport { AddressZero, AlreadyInitialized, NotAllowed, WrongChain, ZeroValueNotAllowed } from \"./../helpers/GenericErrors.sol\";\nimport { addressZeroCheck } from \"./../helpers/Functions.sol\";\nimport { FeeDeployState } from \"./../helpers/Enums.sol\";\nimport { Constants } from \"./../helpers/Constants.sol\";\n\n/// @title Celer Fee Hub Facet\n/// @author Daniel <danieldegendev@gmail.com>\n/// @notice This contract provides the functionality to interact with the celer services through a defined relayer\n/// @custom:version 1.0.0\ncontract CelerFeeHubFacet is ICelerFeeHubFacet {\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n\n    bytes32 constant STORAGE_NAMESPACE = keccak256(\"degenx.celer-fee-hub.storage.v1\");\n\n    address immutable relayer;\n\n    event QueueProcessed();\n    event FeesSent();\n    event UpdateThreshold(uint256 amount);\n    event UpdateSendFeesWei(uint256 amount);\n    event UpdateDeployFeesWei(uint256 amount);\n    event RefundCollected(address asset, address receiver, uint256 amount);\n    event RefundForwarded(address asset, address receiver, uint256 amount);\n    event RelayerForChainAdded(address relayer, uint256 chainId);\n    event RelayerForChainUpdated(address relayer, uint256 chainId);\n    event RelayerForChainRemoved(uint256 chainId);\n    event DeploymentSuccessful(uint64 indexed chainId);\n\n    error QueueEmpty();\n    error NoChainsConfigured();\n    error RefundFailed();\n    error ChainExisting(uint256 chainId);\n    error ChainNotExisting(uint256 chainId);\n    error RelayerExists(address relayer);\n    error ThresholdNotMet();\n    error InsufficientFundsSent();\n    error InsufficientFundsForGas();\n\n    /// @param sendFeesThreshold defines threshold when it is allowed to send fees to home chain\n    /// @param sendFeesWei defines the funds in wei that are needed to initiate the process. leftovers are moved back to sender\n    /// @param deployFeesWei defines the funds in wei that are needed to initiate the process. leftovers are moved back to sender\n    /// @param chainIdToRelayer a map of chain ids and their matching relayer address\n    struct Storage {\n        uint256 sendFeesThreshold;\n        uint256 sendFeesWei;\n        uint256 deployFeesWei;\n        mapping(uint256 => address) chainIdToRelayer;\n    }\n\n    /// Constructor\n    /// @param _relayer address of the relayer\n    constructor(address _relayer) {\n        relayer = _relayer;\n    }\n\n    /// Adds a relayer for a specific chain id\n    /// @param _relayer address of a relayer\n    /// @param _chainId chain id of the relayer\n    /// @dev this can only be executed by the FEE_MANAGER_ROLE, which is the DAO and the owner\n    function addRelayerForChain(address _relayer, uint256 _chainId) external {\n        LibAccessControlEnumerable.checkRole(Constants.FEE_MANAGER_ROLE);\n        addressZeroCheck(_relayer);\n        if (_chainId == 0) revert ZeroValueNotAllowed();\n        Storage storage s = _store();\n        if (s.chainIdToRelayer[_chainId] != address(0)) revert ChainExisting(_chainId);\n        s.chainIdToRelayer[_chainId] = _relayer;\n        emit RelayerForChainAdded(_relayer, _chainId);\n    }\n\n    /// Updates a relayer for a specific chain id\n    /// @param _relayer address of a relayer\n    /// @param _chainId chain id of the relayer\n    /// @dev this can only be executed by the FEE_MANAGER_ROLE, which is the DAO and the owner\n    function updateRelayerOnChain(address _relayer, uint256 _chainId) external {\n        LibAccessControlEnumerable.checkRole(Constants.FEE_MANAGER_ROLE);\n        addressZeroCheck(_relayer);\n        if (_chainId == 0) revert ZeroValueNotAllowed();\n        Storage storage s = _store();\n        if (s.chainIdToRelayer[_chainId] == address(0)) revert ChainNotExisting(_chainId);\n        if (s.chainIdToRelayer[_chainId] == _relayer) revert RelayerExists(_relayer);\n        s.chainIdToRelayer[_chainId] = _relayer;\n        emit RelayerForChainUpdated(_relayer, _chainId);\n    }\n\n    /// Removes a relayer for a specific chain id\n    /// @param _chainId chain id of the relayer\n    /// @dev this can only be executed by the FEE_MANAGER_ROLE, which is the DAO and the owner\n    function removeRelayerOnChain(uint256 _chainId) external {\n        LibAccessControlEnumerable.checkRole(Constants.FEE_MANAGER_ROLE);\n        Storage storage s = _store();\n        if (s.chainIdToRelayer[_chainId] == address(0)) revert ChainNotExisting(_chainId);\n        delete s.chainIdToRelayer[_chainId];\n        emit RelayerForChainRemoved(_chainId);\n    }\n\n    /// Sets the threshold a total fee can be sent to the home chain\n    /// @param _amount threshold amount\n    function updateSendFeesThreshold(uint256 _amount) external {\n        LibAccessControlEnumerable.checkRole(Constants.FEE_MANAGER_ROLE);\n        Storage storage s = _store();\n        s.sendFeesThreshold = _amount;\n        emit UpdateThreshold(_amount);\n    }\n\n    /// Sets the amount of fees that is being used to initiate the send fees process\n    /// @param _wei amount of fees\n    function updateSendFeesWei(uint256 _wei) external {\n        LibAccessControlEnumerable.checkRole(Constants.FEE_MANAGER_ROLE);\n        Storage storage s = _store();\n        s.sendFeesWei = _wei;\n        emit UpdateSendFeesWei(_wei);\n    }\n\n    /// Sets the amount of fees that is being used to initiate the deploy fees process\n    /// @param _wei amount of fees\n    function updateDeployFeesWei(uint256 _wei) external {\n        LibAccessControlEnumerable.checkRole(Constants.FEE_MANAGER_ROLE);\n        Storage storage s = _store();\n        s.deployFeesWei = _wei;\n        emit UpdateDeployFeesWei(_wei);\n    }\n\n    /// @notice This method deploys added, updated or removed fee configuration to desired chains through CELER IM. It is executable by everyone (DeFi things obv)\n    /// @dev Once the queue of the fee manager is filled with configs, it'll be processable. It creates an array of dtos which are being processed by the target chain and its relayer.\n    function deployFeesWithCeler() external payable {\n        LibFeeManagerStorage.FeeManagerStorage storage _managerStore = LibFeeManagerStorage.feeManagerStorage();\n        Storage storage s = _store();\n\n        uint256 _providedWei = msg.value;\n        if (_providedWei == 0 || s.deployFeesWei > _providedWei) revert InsufficientFundsSent();\n\n        uint256[] memory _chainIds = _managerStore.chainIds;\n        if (_chainIds.length == 0) revert NoChainsConfigured();\n\n        bool _sync = false;\n        mapping(uint256 => FeeSyncQueue[]) storage _queue = _managerStore.feeSyncQueue;\n        for (uint256 i = 0; i < _chainIds.length; i++) {\n            if (_queue[_chainIds[i]].length == 0) continue;\n            if (!_sync) _sync = true;\n            uint256 chainId = _chainIds[i];\n            addressZeroCheck(s.chainIdToRelayer[chainId]);\n            FeeConfigSyncDTO[] memory _dto = new FeeConfigSyncDTO[](_queue[chainId].length);\n            for (uint256 j = 0; j < _queue[chainId].length; j++) {\n                bytes32 feeId = _queue[chainId][j].id;\n                FeeConfig storage _config = _managerStore.feeConfigs[feeId];\n                _dto[j] = FeeConfigSyncDTO({\n                    id: feeId,\n                    fee: _config.fee,\n                    action: _queue[chainId][j].action,\n                    target: _managerStore.chainTargets[chainId]\n                });\n                _managerStore.feeDeployState[chainId][feeId] = FeeDeployState.Pending;\n            }\n\n            address _target = LibFeeManager.getChainTarget(chainId);\n            bytes memory _message = abi.encodeWithSelector(IFeeStoreFacet.syncFees.selector, _dto);\n\n            uint256 _fee = IRelayerCeler(relayer).deployFeesFeeCalc(_target, _message);\n            if (_fee > _providedWei) revert InsufficientFundsForGas();\n            _providedWei -= _fee;\n\n            IRelayerCeler(relayer).deployFees{ value: _fee }(s.chainIdToRelayer[chainId], _target, chainId, _message);\n            delete _managerStore.feeSyncQueue[_chainIds[i]];\n        }\n        if (_sync) {\n            if (_providedWei > 0) payable(msg.sender).sendValue(_providedWei);\n            emit QueueProcessed();\n        } else revert QueueEmpty();\n    }\n\n    /// @inheritdoc ICelerFeeHubFacet\n    function deployFeesWithCelerConfirm(uint64 _chainId, bytes calldata _message) external {\n        if (relayer != msg.sender) revert NotAllowed();\n        LibFeeManagerStorage.FeeManagerStorage storage _managerStore = LibFeeManagerStorage.feeManagerStorage();\n        FeeConfigSyncDTO[] memory _dto = abi.decode(_message[4:], (FeeConfigSyncDTO[]));\n        for (uint256 i = 0; i < _dto.length; i++) {\n            _managerStore.feeDeployState[_chainId][_dto[i].id] = FeeDeployState.Deployed;\n        }\n    }\n\n    /// Sends fees stored on the FeeStore back to the home chain, respecting a bounty receiver\n    /// @param minMaxSlippage external defined minimal max slippage by the estimation api of CELER\n    /// @param _bountyReceiver address of the bounty receiver on the home chain\n    /// @dev The bounty receiver is set because you can't relay on the initiator in the consuming\n    ///      contract on the home chain, because contracts can execute this method without having\n    ///      the same address on the home chain. It also transfers the tokens to the relayer which\n    ///      then bridges the tokens and sends the message to the CELER IM service\n    /// @notice Can be executed by everyone. Its success is dependend on the sendFeesThreshold being met\n    function sendFeesWithCeler(uint32 minMaxSlippage, address _bountyReceiver) external payable {\n        Storage storage s = _store();\n        FeeConfigSyncHomeDTO memory _dto = LibFeeStore.prepareToSendFees(); // implicit zero fee check here\n        if (_dto.totalFees < s.sendFeesThreshold) revert ThresholdNotMet();\n\n        uint256 _providedWei = msg.value;\n        if (_providedWei == 0 || s.sendFeesWei > _providedWei) revert InsufficientFundsSent();\n\n        if (_bountyReceiver == address(0) || _bountyReceiver == address(0xdead)) revert AddressZero();\n\n        _dto.bountyReceiver = _bountyReceiver;\n        IERC20(LibFeeStore.getIntermediateAsset()).safeTransfer(relayer, _dto.totalFees);\n\n        bytes memory _message = abi.encode(_dto);\n        uint256 _fee = IRelayerCeler(relayer).sendFeesFeeCalc(_message);\n\n        if (_fee > _providedWei) revert InsufficientFundsForGas();\n        _providedWei -= _fee;\n\n        IRelayerCeler(relayer).sendFees{ value: _fee }(LibFeeStore.getIntermediateAsset(), _dto.totalFees, minMaxSlippage, _message);\n\n        if (_providedWei > 0) payable(msg.sender).sendValue(_providedWei);\n        emit FeesSent();\n    }\n\n    /// viewables\n\n    function celerFeeHubSendFeesWei() external view returns (uint256 _wei) {\n        Storage storage s = _store();\n        _wei = s.sendFeesWei;\n    }\n\n    function celerFeeHubDeployFeesWei() external view returns (uint256 _wei) {\n        Storage storage s = _store();\n        _wei = s.deployFeesWei;\n    }\n\n    /// internals\n\n    /// Store\n    function _store() internal pure returns (Storage storage s) {\n        bytes32 position = STORAGE_NAMESPACE;\n        assembly {\n            s.slot := position\n        }\n    }\n}\n"
    },
    "contracts/diamond/facets/DiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\n\n/// @custom:version 1.0.0\ncontract DiamondCutFacet is IDiamondCut {\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external override {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.diamondCut(_diamondCut, _init, _calldata);\n    }\n}\n"
    },
    "contracts/diamond/facets/DiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\nimport { IERC165 } from \"../interfaces/IERC165.sol\";\n\n// The functions in DiamondLoupeFacet MUST be added to a diamond.\n// The EIP-2535 Diamond standard requires these functions.\n\n/// @custom:version 1.0.0\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\n    // Diamond Loupe Functions\n    ////////////////////////////////////////////////////////////////////\n    /// These functions are expected to be called frequently by tools.\n    //\n    // struct Facet {\n    //     address facetAddress;\n    //     bytes4[] functionSelectors;\n    // }\n\n    /// @notice Gets all facets and their selectors.\n    /// @return facets_ Facet\n    function facets() external view override returns (Facet[] memory facets_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        uint256 numFacets = ds.facetAddresses.length;\n        facets_ = new Facet[](numFacets);\n        for (uint256 i; i < numFacets; i++) {\n            address facetAddress_ = ds.facetAddresses[i];\n            facets_[i].facetAddress = facetAddress_;\n            facets_[i].functionSelectors = ds.facetFunctionSelectors[facetAddress_].functionSelectors;\n        }\n    }\n\n    /// @notice Gets all the function selectors provided by a facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet) external view override returns (bytes4[] memory facetFunctionSelectors_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetFunctionSelectors_ = ds.facetFunctionSelectors[_facet].functionSelectors;\n    }\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external view override returns (address[] memory facetAddresses_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddresses_ = ds.facetAddresses;\n    }\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external view override returns (address facetAddress_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddress_ = ds.selectorToFacetAndPosition[_functionSelector].facetAddress;\n    }\n\n    // This implements ERC-165.\n    function supportsInterface(bytes4 _interfaceId) external view override returns (bool) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        return ds.supportedInterfaces[_interfaceId];\n    }\n}\n"
    },
    "contracts/diamond/facets/ERC20Facet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.19;\n\nimport { SolidStateERC20 } from \"@solidstate/contracts/token/ERC20/SolidStateERC20.sol\";\nimport { Pausable } from \"@solidstate/contracts/security/pausable/Pausable.sol\";\nimport { IERC20 } from \"@solidstate/contracts/interfaces/IERC20.sol\";\n\nimport { IERC20Facet } from \"../interfaces/IERC20Facet.sol\";\nimport { LibAccessControlEnumerable } from \"../libraries/LibAccessControlEnumerable.sol\";\nimport { LibFeeStoreStorage } from \"../libraries/LibFeeStoreStorage.sol\";\nimport { LibFeeStore } from \"../libraries/LibFeeStore.sol\";\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\nimport { NotAllowed } from \"../helpers/GenericErrors.sol\";\nimport { Constants } from \"../helpers/Constants.sol\";\n\n/// @title ERC20 Token Facet\n/// @author Daniel <danieldegendev@gmail.com>\n/// @notice Provides the functionality of an ERC20 token to an EIP-2535 based diamond\n/// @custom:version 1.1.0\ncontract ERC20Facet is SolidStateERC20, Pausable, IERC20Facet {\n    /// Storage Slot\n    bytes32 internal constant ERC20_FACET_STORAGE_SLOT = keccak256(\"degenx.erc20.storage.v1.1.0\");\n\n    event AddLP(address lp);\n    event RemoveLP(address lp);\n    event ExcludeAccountFromTax(address account);\n    event IncludeAccountToTax(address account);\n    event FeeAdded(bytes32 id, bool buyFee);\n    event FeeRemoved(bytes32 id, bool buyFee);\n    event BridgeSupplyCapUpdated(address bridge, uint256 cap);\n\n    error FeeIdAlreadySet(bytes32 id);\n    error FeeIdNotSet(bytes32 id);\n    error FeeIdMissing();\n    error InvalidFeeId(bytes32 id);\n    error NoBurnPossible();\n    error BridgeSupplyExceeded(uint256 candidate, uint256 supply);\n\n    /// @param cap maximum tokens to mint for a specific account/contract\n    /// @param total currently minted amount of tokens for a specific account/contract\n    struct BridgeSupply {\n        uint256 cap;\n        uint256 total;\n    }\n\n    /// @param initialized A flag that defines if the contract is initialized already\n    /// @param buyFee An array of bytes32 to configure buy fee ids\n    /// @param sellFee An array of bytes32 to configure sell fee ids\n    /// @param lps A map of addresses which are identified as a liquidity pool\n    /// @param excludes A map of addresses which can get flagged to be from paying fees\n    /// @param fees A map of fee ids to its charged amounts\n    /// @param bridges A map of fee ids to its charged amounts\n    struct ERC20FacetStorage {\n        bool initialized;\n        bytes32[] buyFee;\n        bytes32[] sellFee;\n        mapping(address => bool) lps;\n        mapping(address => bool) excludes;\n        mapping(bytes32 => uint256) fees;\n        mapping(address => BridgeSupply) bridges;\n    }\n\n    /// Initializes the contract\n    /// @param __name The name of the token\n    /// @param __symbol The symbol of the token\n    /// @param __decimals The number of decimals of the token\n    function initERC20Facet(string calldata __name, string calldata __symbol, uint8 __decimals) external {\n        LibAccessControlEnumerable.checkRole(Constants.DEPLOYER_ROLE);\n        ERC20FacetStorage storage s = _store();\n        if (s.initialized) revert(\"initialized\");\n        _pause();\n        _setName(__name);\n        _setSymbol(__symbol);\n        _setDecimals(__decimals);\n        s.initialized = true;\n    }\n\n    /// @inheritdoc IERC20Facet\n    function mint(address _to, uint256 _amount) external returns (bool _success) {\n        ERC20FacetStorage storage s = _store();\n        if (s.bridges[msg.sender].cap == 0) revert NotAllowed();\n        s.bridges[msg.sender].total += _amount;\n        if (s.bridges[msg.sender].total > s.bridges[msg.sender].cap) revert BridgeSupplyExceeded(_amount, s.bridges[msg.sender].cap);\n        _mint(_to, _amount);\n        _success = true;\n    }\n\n    /// @inheritdoc IERC20Facet\n    function burn(uint256 _amount) external returns (bool _success) {\n        _burn(msg.sender, _amount);\n        _success = true;\n    }\n\n    /// @inheritdoc IERC20Facet\n    function burn(address _from, uint256 _amount) external returns (bool _success) {\n        _success = _burnFrom(_from, _amount);\n    }\n\n    /// @inheritdoc IERC20Facet\n    function burnFrom(address _from, uint256 _amount) external returns (bool _success) {\n        _success = _burnFrom(_from, _amount);\n    }\n\n    /// @inheritdoc IERC20Facet\n    function enable() external {\n        LibAccessControlEnumerable.checkRole(Constants.ADMIN_ROLE);\n        _unpause();\n    }\n\n    /// @inheritdoc IERC20Facet\n    function disable() external {\n        LibAccessControlEnumerable.checkRole(Constants.ADMIN_ROLE);\n        _pause();\n    }\n\n    /// @inheritdoc IERC20Facet\n    function addLP(address _lp) external {\n        LibAccessControlEnumerable.checkRole(Constants.ADMIN_ROLE);\n        ERC20FacetStorage storage s = _store();\n        s.lps[_lp] = true;\n        emit AddLP(_lp);\n    }\n\n    /// @inheritdoc IERC20Facet\n    function removeLP(address _lp) external {\n        LibAccessControlEnumerable.checkRole(Constants.ADMIN_ROLE);\n        ERC20FacetStorage storage s = _store();\n        s.lps[_lp] = false;\n        emit RemoveLP(_lp);\n    }\n\n    /// @inheritdoc IERC20Facet\n    function excludeAccountFromTax(address _account) external {\n        LibAccessControlEnumerable.checkRole(Constants.ADMIN_ROLE);\n        ERC20FacetStorage storage s = _store();\n        s.excludes[_account] = true;\n        emit ExcludeAccountFromTax(_account);\n    }\n\n    /// @inheritdoc IERC20Facet\n    function includeAccountForTax(address _account) external {\n        LibAccessControlEnumerable.checkRole(Constants.ADMIN_ROLE);\n        ERC20FacetStorage storage s = _store();\n        delete s.excludes[_account];\n        emit IncludeAccountToTax(_account);\n    }\n\n    /// @inheritdoc IERC20Facet\n    function addBuyFee(bytes32 _id) external {\n        _addFee(_id, true);\n    }\n\n    /// Removes a buy fee based on a fee id\n    /// @param _id fee id\n    function removeBuyFee(bytes32 _id) external {\n        _removeFee(_id, true);\n    }\n\n    /// @inheritdoc IERC20Facet\n    function addSellFee(bytes32 _id) external {\n        _addFee(_id, false);\n    }\n\n    /// Removes a sell fee based on a fee id\n    /// @param _id fee id\n    function removeSellFee(bytes32 _id) external {\n        _removeFee(_id, false);\n    }\n\n    /// Updates a supply cap for a specified bridge\n    /// @param _bridge address of the bridge\n    /// @param _cap supply cap of the bridge\n    function updateBridgeSupplyCap(address _bridge, uint256 _cap) external {\n        LibAccessControlEnumerable.checkRole(Constants.ADMIN_ROLE);\n        ERC20FacetStorage storage s = _store();\n        // cap == 0 means revoking bridge role\n        s.bridges[_bridge].cap = _cap;\n        emit BridgeSupplyCapUpdated(_bridge, _cap);\n    }\n\n    /// viewables\n\n    /// Checks if an account is whether excluded from paying fees or not\n    /// @param _account account to check\n    function isExcluded(address _account) external view returns (bool _isExcluded) {\n        ERC20FacetStorage storage s = _store();\n        _isExcluded = s.excludes[_account];\n    }\n\n    /// Checks whether a fee id is a buy fee or not\n    /// @param _id fee id\n    function isBuyFee(bytes32 _id) external view returns (bool _itis) {\n        _itis = _isFee(_id, true);\n    }\n\n    /// Check whether a fee id is a sell fee or not\n    /// @param _id fee id\n    function isSellFee(bytes32 _id) external view returns (bool _itis) {\n        _itis = _isFee(_id, false);\n    }\n\n    /// @inheritdoc IERC20Facet\n    function hasLP(address _lp) external view returns (bool _has) {\n        ERC20FacetStorage storage s = _store();\n        _has = s.lps[_lp];\n    }\n\n    /// Returns all buy fee ids\n    /// @return _fees array of fee ids\n    function getBuyFees() external view returns (bytes32[] memory _fees) {\n        ERC20FacetStorage storage s = _store();\n        _fees = s.buyFee;\n    }\n\n    /// Returns all sell fee ids\n    /// @return _fees array of fee ids\n    function getSellFees() external view returns (bytes32[] memory _fees) {\n        ERC20FacetStorage storage s = _store();\n        _fees = s.sellFee;\n    }\n\n    /// Returns the supply information of the given bridge\n    /// @param _bridge address of the bridge\n    /// @return _supply bridge supply\n    function bridges(address _bridge) external view returns (BridgeSupply memory _supply) {\n        _supply = _store().bridges[_bridge];\n    }\n\n    /// @notice Returns the owner address\n    /// @return _owner owner address\n    function getOwner() external view returns (address _owner) {\n        _owner = LibDiamond.contractOwner();\n    }\n\n    /// internals\n\n    /// Returns if a fee is an actual fee from the buy fees or from the sell fees\n    /// @param _id fee id\n    /// @param _isBuyFee flag to decide whether it is a buy fee or not\n    /// @return _itis returns true if it is a fee\n    function _isFee(bytes32 _id, bool _isBuyFee) internal view returns (bool _itis) {\n        ERC20FacetStorage storage s = _store();\n        bytes32[] storage _fees = _isBuyFee ? s.buyFee : s.sellFee;\n        for (uint256 i = 0; i < _fees.length; ) {\n            if (_fees[i] == _id) {\n                _itis = true;\n                break;\n            }\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// Adds a fee based on a fee id and a flag if it should be added as buy fee or sell fee\n    /// @param _id fee id\n    /// @param _isBuyFee flag if fee id should be processed as buy fee or sell fee\n    function _addFee(bytes32 _id, bool _isBuyFee) internal {\n        LibAccessControlEnumerable.checkRole(Constants.ADMIN_ROLE);\n        ERC20FacetStorage storage s = _store();\n        LibFeeStoreStorage.FeeStoreStorage storage feeStore = LibFeeStoreStorage.feeStoreStorage();\n        if (_id == bytes32(\"\")) revert FeeIdMissing();\n        if (feeStore.feeConfigs[_id].id != _id) revert InvalidFeeId(_id);\n        bytes32[] storage _fees = _isBuyFee ? s.buyFee : s.sellFee;\n        for (uint256 i = 0; i < _fees.length; ) {\n            if (_fees[i] == _id) revert FeeIdAlreadySet(_id);\n            unchecked {\n                i++;\n            }\n        }\n        _fees.push(_id);\n        emit FeeAdded(_id, _isBuyFee);\n    }\n\n    /// Removes a fee based on a fee id and a flag if it should be removed as buy fee or sell fee\n    /// @param _id fee id\n    /// @param _isBuyFee flag if fee id should be processed as buy fee or sell fee\n    function _removeFee(bytes32 _id, bool _isBuyFee) internal {\n        LibAccessControlEnumerable.checkRole(Constants.ADMIN_ROLE);\n        ERC20FacetStorage storage s = _store();\n        if (!_isFee(_id, _isBuyFee)) revert FeeIdNotSet(_id);\n        bytes32[] storage _fees = _isBuyFee ? s.buyFee : s.sellFee;\n        for (uint256 i = 0; i < _fees.length; ) {\n            if (_fees[i] == _id) _fees[i] = _fees[_fees.length - 1];\n            unchecked {\n                i++;\n            }\n        }\n        _fees.pop();\n        emit FeeRemoved(_id, _isBuyFee);\n    }\n\n    /// Transfers the token from one address to another\n    /// @param _from holder address\n    /// @param _to receiver address\n    /// @param _amount amount of tokens to transfer\n    /// @notice During this process, it will be checked if the provided address are a liquidity pool address and then\n    ///         being marked as a buy transfer or sell transfer. During a buy or sell, desired fees will be charged.\n    ///         But only if non of the addresses is excluded from the fees and the router is set. Since swapping tokens\n    ///         during a buy process, it will be only done in a sell process. The charged fees are getting cut of from\n    ///         the initial amount of tokens and the rest is getting transfered.\n    function _transfer(address _from, address _to, uint256 _amount) internal override returns (bool) {\n        ERC20FacetStorage storage s = _store();\n        bool isBuy = s.lps[_from];\n        bool isSell = s.lps[_to];\n        if ((isBuy || isSell) && !s.excludes[_from] && !s.excludes[_to]) {\n            uint256 _totalFee = 0;\n            bytes32[] storage _fees = isBuy ? s.buyFee : s.sellFee;\n            for (uint256 i = 0; i < _fees.length; ) {\n                (, uint256 _singleFee, ) = LibFeeStore.calcFeesRelative(_fees[i], address(this), _amount);\n                LibFeeStore.putFees(_fees[i], _singleFee);\n                _totalFee += _singleFee;\n                unchecked {\n                    i++;\n                }\n            }\n            if (_totalFee > 0) {\n                super._transfer(_from, address(this), _totalFee);\n                _amount -= _totalFee;\n            }\n        }\n        return super._transfer(_from, _to, _amount);\n    }\n\n    /// Internal method to burn a specified amount of tokens for an address\n    /// @param _from address to burn from\n    /// @param _amount amount to burn\n    /// @return Returns true is it succeeds\n    /// @dev It checks if there is an exceeded amount of tokens tried to be burned for a specific bridge\n    function _burnFrom(address _from, uint256 _amount) internal returns (bool) {\n        ERC20FacetStorage storage s = _store();\n        if (s.bridges[msg.sender].cap > 0 || s.bridges[msg.sender].total > 0) {\n            if (_amount > s.bridges[msg.sender].total) revert BridgeSupplyExceeded(_amount, s.bridges[msg.sender].total);\n            unchecked {\n                s.bridges[msg.sender].total -= _amount;\n            }\n        }\n        _decreaseAllowance(_from, msg.sender, _amount);\n        _burn(_from, _amount);\n        return true;\n    }\n\n    /// @dev Store\n    function _store() internal pure returns (ERC20FacetStorage storage _s) {\n        bytes32 slot = ERC20_FACET_STORAGE_SLOT;\n        assembly {\n            _s.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/diamond/facets/FeeDistributorFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.19;\n\nimport { IERC20, SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { IFeeDistributorFacet } from \"./../interfaces/IFeeDistributorFacet.sol\";\nimport { IDepositable } from \"./../interfaces/IDepositable.sol\";\nimport { IRouter02 } from \"./../interfaces/IRouter02.sol\";\nimport { IWAVAX } from \"./../interfaces/IWAVAX.sol\";\nimport { LibAccessControlEnumerable } from \"./../libraries/LibAccessControlEnumerable.sol\";\nimport { LibFeeManagerStorage } from \"./../libraries/LibFeeManagerStorage.sol\";\nimport { LibFeeManager } from \"./../libraries/LibFeeManager.sol\";\nimport { FeeConfig, FeeConfigSyncHomeDTO, FeeConfigSyncHomeFees, AddReceiverParams } from \"./../helpers/Structs.sol\";\nimport { AlreadyInitialized, ZeroValueNotAllowed } from \"./../helpers/GenericErrors.sol\";\nimport { Constants } from \"./../helpers/Constants.sol\";\n\n/// @title Fee Distributor Facet\n/// @author Daniel <danieldegendev@gmail.com>\n/// @notice It is responsible for distributing received fees to its configured receivers\n/// @custom:version 1.0.0\ncontract FeeDistributorFacet is IFeeDistributorFacet {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using Address for address payable;\n\n    bytes32 constant STORAGE_NAMESPACE = keccak256(\"degenx.fee-distributor.storage.v1\");\n\n    event ReceiverAdded(address account, uint64 points);\n    event ReceiverRemoved(address account);\n    event DistributionStarted();\n    event DistributionStopped();\n    event TriggerDistributionWhileNotRunning();\n    event Distributed(address account, uint256 amount);\n    event UpdatedDistributionShares(address[] receivers, uint64[] shares);\n    event BountyEnabled();\n    event BountyDisabled();\n    event BountyShareUpdated(uint64 share);\n    event PushFeesGasCompensationForCallerUpdate(uint256 amountInWei);\n    event BountyPaid(uint256 amount, address receiver);\n    event BountyPaidFailed(uint256 amount, address receiver);\n    event EnableBountyInToken();\n    event DisableBountyInToken();\n\n    error ReceiverNotExisting(address receiver);\n    error WrongData();\n    error WrongToken();\n    error MissingData();\n    error FailedStartMissingShares();\n    error InvalidSwapPath();\n\n    /// @param name the name of the fee share for the UI\n    /// @param points the fee share points\n    /// @param receiver the receiver of the fee share\n    /// @param swap a dedicated swapping path for the fee share\n    struct Share {\n        string name;\n        uint64 points;\n        address receiver;\n        address[] swap;\n    }\n\n    /// @param shares stores the shares in an array\n    /// @param queue stores a queue of fees that can be send home\n    /// @param shareIndex store the share index of the shares array\n    /// @param totalPoints cumulative share points\n    /// @param baseToken the expected token from the bridge\n    /// @param router uniswap v2 based router\n    /// @param bountyShare share of the bounty\n    /// @param bountyReceiver bounty receiver for processing purposes\n    /// @param lastBountyReceiver last recent bounty receiver\n    /// @param lastBountyAmount last recent bounty amount that receiver got\n    /// @param totalBounties total amount of bounties paid out\n    /// @param running running state of the fee distributor\n    /// @param bountyActive is a bounty active or not\n    /// @param initialized initialize state of the facet\n    struct Storage {\n        Share[] shares;\n        FeeConfigSyncHomeDTO[] queue;\n        mapping(address => uint256) shareIndex;\n        uint64 totalPoints;\n        address baseToken;\n        address nativeWrapper;\n        address router;\n        uint256 pushFeesGasCompensationForCaller;\n        // bounties\n        uint64 bountyShare;\n        address bountyReceiver;\n        address lastBountyReceiver;\n        uint256 lastBountyAmount;\n        uint256 totalBounties;\n        // flags\n        bool running;\n        bool bountyActive;\n        bool bountyInToken;\n        bool initialized;\n    }\n\n    /// Initializes the facet\n    /// @param _baseToken address of the expected token we get from the bridge\n    /// @param _nativeWrapper address of native wrapper token on the operating chain\n    /// @param _router uniswap v2 based router\n    /// @param _bountyShare share of bounty  (10000 = 1%, 1000 = 0.1%)\n    /// @dev only available to DEPLOYER_ROLE\n    function initFeeDistributorFacet(address _baseToken, address _nativeWrapper, address _router, uint64 _bountyShare) external {\n        LibAccessControlEnumerable.checkRole(Constants.DEPLOYER_ROLE);\n        Storage storage s = _store();\n        if (s.initialized) revert AlreadyInitialized();\n        s.bountyShare = _bountyShare;\n        s.baseToken = _baseToken;\n        s.nativeWrapper = _nativeWrapper;\n        s.router = _router;\n        s.bountyInToken = false;\n        s.initialized = true;\n    }\n\n    /// @inheritdoc IFeeDistributorFacet\n    function pushFees(address _token, uint256 _amount, FeeConfigSyncHomeDTO calldata _dto) external payable {\n        LibAccessControlEnumerable.checkRole(Constants.FEE_DISTRIBUTOR_PUSH_ROLE);\n        Storage storage s = _store();\n\n        if (s.baseToken != _token) revert WrongToken();\n        if (_amount == 0) revert ZeroValueNotAllowed();\n\n        // before native swap\n        if (s.bountyInToken) _amount = _payoutBountyInToken(_token, _amount, _dto.bountyReceiver);\n\n        // swap basetoken to native\n        address[] memory _path = new address[](2);\n        _path[0] = s.baseToken;\n        _path[1] = s.nativeWrapper;\n        IERC20(s.baseToken).approve(s.router, _amount);\n        uint256[] memory _amounts = IRouter02(s.router).swapExactTokensForAVAX(\n            _amount,\n            (_amount * 997) / 1000,\n            _path,\n            address(this),\n            block.timestamp\n        );\n        _amount = _amounts[_amounts.length - 1];\n\n        // pay gas compensation to EOA\n        if (s.pushFeesGasCompensationForCaller > 0 && _amount > s.pushFeesGasCompensationForCaller && !msg.sender.isContract()) {\n            payable(msg.sender).sendValue(s.pushFeesGasCompensationForCaller);\n            _amount -= s.pushFeesGasCompensationForCaller;\n        }\n\n        // after native swap\n        if (!s.bountyInToken) _amount = _payoutBountyInNative(_amount, _dto.bountyReceiver);\n\n        // generate new dto and redraw shares based on _amount and original send amount (_dto.totalFees) because we substract some stuff and bridged funds will differ from initial funds anyway\n        // slither-disable-next-line uninitialized-local-variables\n        FeeConfigSyncHomeDTO memory _updatedDto = FeeConfigSyncHomeDTO({\n            totalFees: _amount,\n            bountyReceiver: _dto.bountyReceiver,\n            fees: new FeeConfigSyncHomeFees[](_dto.fees.length)\n        });\n        for (uint256 i = 0; i < _dto.fees.length; ) {\n            uint256 _feeAmount = (_amount * _dto.fees[i].amount) / _dto.totalFees;\n            _updatedDto.fees[i] = FeeConfigSyncHomeFees({ id: _dto.fees[i].id, amount: _feeAmount });\n            unchecked {\n                i++;\n            }\n        }\n\n        _pushFees(_updatedDto);\n    }\n\n    /// Adds a fee receiver\n    /// @param _params contains the name, points, account address und swapPath for the receiver\n    /// @dev swapPath[] needs to have the base token address on position 0\n    /// @dev This method also checks if there is a valid swap path existing, otherwise it will be reverted by the aggregator\n    /// @dev only available to FEE_DISTRIBUTIOR_MANAGER role\n    function addFeeDistributionReceiver(AddReceiverParams calldata _params) external {\n        LibAccessControlEnumerable.checkRole(Constants.FEE_DISTRIBUTOR_MANAGER);\n        Storage storage s = _store();\n        // check if it is a valid pair\n        if (_params.swapPath.length > 1) IRouter02(s.router).getAmountsOut(10 ** 6, _params.swapPath);\n        s.shareIndex[_params.account] = s.shares.length;\n        s.shares.push(Share({ name: _params.name, points: _params.points, receiver: _params.account, swap: _params.swapPath }));\n        s.totalPoints += _params.points;\n        emit ReceiverAdded(_params.account, _params.points);\n    }\n\n    /// Removes a receiver based on the receiver address\n    /// @param _account address of the receiver\n    /// @dev only available to FEE_DISTRIBUTIOR_MANAGER role\n    function removeFeeDistributionReceiver(address _account) external {\n        LibAccessControlEnumerable.checkRole(Constants.FEE_DISTRIBUTOR_MANAGER);\n        Storage storage s = _store();\n        if (s.shares.length == 0) {\n            revert ReceiverNotExisting(_account);\n        } else if (s.shares.length == 1) {\n            delete s.shares;\n            delete s.shareIndex[_account];\n            s.totalPoints = 0;\n            s.running = false; // stop when there is no share available anymore\n        } else {\n            for (uint256 i = 0; i < s.shares.length; ) {\n                if (s.shares[i].receiver == _account) {\n                    delete s.shareIndex[_account];\n                    s.shareIndex[s.shares[s.shares.length - 1].receiver] = i;\n                    s.totalPoints -= s.shares[i].points;\n                    s.shares[i] = s.shares[s.shares.length - 1];\n                }\n                unchecked {\n                    i++;\n                }\n            }\n            s.shares.pop();\n        }\n        emit ReceiverRemoved(_account);\n    }\n\n    /// Updates the shares of existing receivers\n    /// @param _receivers array of existing receivers\n    /// @param _shares array of new shares to be set\n    /// @dev if a receiver is not existing, it'll be reverted\n    /// @dev only available to FEE_DISTRIBUTIOR_MANAGER role\n    function updateFeeDistributionShares(address[] calldata _receivers, uint64[] calldata _shares) external {\n        LibAccessControlEnumerable.checkRole(Constants.FEE_DISTRIBUTOR_MANAGER);\n        if (_receivers.length == 0 || _shares.length == 0 || _receivers.length != _shares.length) revert WrongData();\n        Storage storage s = _store();\n        if (s.shares.length == 0) revert MissingData();\n        for (uint256 i = 0; i < _receivers.length; ) {\n            if (s.shares[s.shareIndex[_receivers[i]]].receiver != _receivers[i]) revert ReceiverNotExisting(_receivers[i]);\n            s.totalPoints -= s.shares[s.shareIndex[_receivers[i]]].points;\n            s.shares[s.shareIndex[_receivers[i]]].points = _shares[i];\n            s.totalPoints += _shares[i];\n            unchecked {\n                i++;\n            }\n        }\n        emit UpdatedDistributionShares(_receivers, _shares);\n    }\n\n    /// Starts the fee distribution\n    /// @dev It will be also check if the bounties are being activated and if there are already fees in the queue to process. If so, it'll be process on activating the fee distribution.\n    /// @dev only available to FEE_DISTRIBUTIOR_MANAGER role\n    function startFeeDistribution() external {\n        LibAccessControlEnumerable.checkRole(Constants.FEE_DISTRIBUTOR_MANAGER);\n        Storage storage s = _store();\n\n        if (s.shares.length == 0) revert FailedStartMissingShares();\n\n        _setRunning(true);\n\n        bool _initialState = s.bountyActive;\n        if (_initialState) s.bountyActive = false;\n        if (s.queue.length > 0) {\n            for (uint256 i = 0; i < s.queue.length; ) {\n                _pushFees(s.queue[i]);\n                unchecked {\n                    i++;\n                }\n            }\n            delete s.queue;\n        }\n\n        if (_initialState) s.bountyActive = true;\n\n        emit DistributionStarted();\n    }\n\n    /// Stops the fee distribution\n    /// @dev only available to FEE_DISTRIBUTIOR_MANAGER role\n    function stopFeeDistribution() external {\n        LibAccessControlEnumerable.checkRole(Constants.FEE_DISTRIBUTOR_MANAGER);\n        _setRunning(false);\n        emit DistributionStopped();\n    }\n\n    /// @dev Enables the bounty possibility\n    /// @dev only available to FEE_DISTRIBUTIOR_MANAGER role\n    function enableFeeDistributorBounty() external {\n        LibAccessControlEnumerable.checkRole(Constants.FEE_DISTRIBUTOR_MANAGER);\n        Storage storage s = _store();\n        s.bountyActive = true;\n        emit BountyEnabled();\n    }\n\n    /// @dev Disables the bounty possibility\n    /// @dev only available to FEE_DISTRIBUTIOR_MANAGER role\n    function disableFeeDistributorBounty() external {\n        LibAccessControlEnumerable.checkRole(Constants.FEE_DISTRIBUTOR_MANAGER);\n        Storage storage s = _store();\n        s.bountyActive = false;\n        emit BountyDisabled();\n    }\n\n    /// Sets the share of the bounty\n    /// @param _share share of the bounty\n    /// @dev only available to FEE_DISTRIBUTIOR_MANAGER role\n    function setFeeDistributorBountyShare(uint64 _share) external {\n        LibAccessControlEnumerable.checkRole(Constants.FEE_DISTRIBUTOR_MANAGER);\n        Storage storage s = _store();\n        s.bountyShare = _share;\n        emit BountyShareUpdated(_share);\n    }\n\n    /// Sets the gas compensation for the caller of the push fee method\n    /// @param _amountInWei share of the bounty\n    /// @dev only available to FEE_DISTRIBUTIOR_MANAGER role\n    function setPushFeesGasCompensationForCaller(uint256 _amountInWei) external {\n        LibAccessControlEnumerable.checkRole(Constants.FEE_DISTRIBUTOR_MANAGER);\n        Storage storage s = _store();\n        s.pushFeesGasCompensationForCaller = _amountInWei;\n        emit PushFeesGasCompensationForCallerUpdate(_amountInWei);\n    }\n\n    /// Enables  or disables the bountyInToken flag based on the given parameter\n    /// @param _bountyInToken flag if enabled or not\n    /// @dev only available to FEE_DISTRIBUTIOR_MANAGER role\n    function enableBountyInToken(bool _bountyInToken) external {\n        LibAccessControlEnumerable.checkRole(Constants.FEE_DISTRIBUTOR_MANAGER);\n        Storage storage s = _store();\n        s.bountyInToken = _bountyInToken;\n        if (_bountyInToken) emit EnableBountyInToken();\n        else emit DisableBountyInToken();\n    }\n\n    /// viewables\n\n    /// @dev check whether the bounty is active of not\n    /// @return _is if true, it's on\n    function isFeeDistributorBountyActive() external view returns (bool _is) {\n        Storage storage s = _store();\n        _is = s.bountyActive;\n    }\n\n    /// @dev check whether the distributor is running of not\n    /// @return _is if true, it's on\n    function isFeeDistributorRunning() external view returns (bool _is) {\n        Storage storage s = _store();\n        _is = s.running;\n    }\n\n    /// @dev check whether the distributors bounty is paid in the token or not\n    /// @return _is if true, it's paid in token\n    function isFeeDistributorBountyInToken() external view returns (bool _is) {\n        Storage storage s = _store();\n        _is = s.bountyInToken;\n    }\n\n    /// @dev Gets the current total points of all shares\n    /// @return _totalPoints points\n    function getFeeDistributorTotalPoints() external view returns (uint64 _totalPoints) {\n        Storage storage s = _store();\n        _totalPoints = s.totalPoints;\n    }\n\n    /// @dev Gets all items in queue\n    /// @return _queue array of sync items\n    function getFeeDistributorQueue() external view returns (FeeConfigSyncHomeDTO[] memory _queue) {\n        Storage storage s = _store();\n        _queue = s.queue;\n    }\n\n    /// @dev Gets all shares\n    /// @return _shares array of configured shares\n    function getFeeDistributorReceivers() external view returns (Share[] memory _shares) {\n        Storage storage s = _store();\n        _shares = s.shares;\n    }\n\n    /// @dev Gets last bounty information\n    /// @return _receiver address of recent receiver\n    /// @return _payout amount being paid to recent receiver\n    function getFeeDistributorLastBounty() external view returns (address _receiver, uint256 _payout) {\n        Storage storage s = _store();\n        _receiver = s.lastBountyReceiver;\n        _payout = s.lastBountyAmount;\n    }\n\n    /// @dev Gets the bounty share\n    /// @return _share current bounty share\n    function getFeeDistributorBountyShare() external view returns (uint64 _share) {\n        Storage storage s = _store();\n        _share = s.bountyShare;\n    }\n\n    /// @dev Gets the total bounties being paid\n    /// @return _totalBounties total bounties\n    function getFeeDistributorTotalBounties() external view returns (uint256 _totalBounties) {\n        Storage storage s = _store();\n        _totalBounties = s.totalBounties;\n    }\n\n    /// internals\n\n    /// Distributes the fees to the desired receivers based on their share\n    /// @param _dto a dto that needs to be synced\n    /// @dev If the distribution is running, it'll distribute it directly, otherwise it will be queued up and distributed once the distirbution is enabled\n    function _pushFees(FeeConfigSyncHomeDTO memory _dto) internal {\n        Storage storage s = _store();\n        if (_dto.fees.length == 0) revert MissingData();\n        // more efficient way to check this before and not in loop\n        if (s.running) {\n            for (uint256 i = 0; i < _dto.fees.length; ) {\n                _distribute(LibFeeManager.getFeeConfigById(_dto.fees[i].id).receiver, _dto.fees[i].amount);\n                unchecked {\n                    i++;\n                }\n            }\n        } else {\n            FeeConfigSyncHomeDTO storage _q = s.queue.push();\n            _q.totalFees = _dto.totalFees;\n            _q.bountyReceiver = _dto.bountyReceiver;\n            for (uint256 i = 0; i < _dto.fees.length; ) {\n                _q.fees.push(FeeConfigSyncHomeFees({ id: _dto.fees[i].id, amount: _dto.fees[i].amount }));\n                unchecked {\n                    i++;\n                }\n            }\n            emit TriggerDistributionWhileNotRunning();\n        }\n    }\n\n    /// Distributes the fees to the desired addresses\n    /// @param _receiver address of the receiver, can be address(0)\n    /// @param _amount amount of tokens being distributed\n    /// @dev If the receiver is address(0), the funds will be distributed to all defined shares based on their points and desired swap\n    /// @dev If the receiver is not address(0), the funds will be directly send to the address\n    function _distribute(address _receiver, uint256 _amount) internal {\n        Storage storage s = _store();\n        if (_receiver == address(0) && s.totalPoints > 0) {\n            uint256 _rest = _amount;\n            for (uint256 i = 0; i < s.shares.length; i++) {\n                bool _useRest = s.shares.length == i + 1;\n                uint256 _share = _useRest ? _rest : (_amount * uint256(s.shares[i].points)) / uint256(s.totalPoints);\n                _rest = _useRest ? 0 : _rest - _share;\n                if (s.shares[i].swap.length > 1) {\n                    address _token = s.shares[i].swap[s.shares[i].swap.length - 1];\n                    uint256[] memory amounts = IRouter02(s.router).swapExactAVAXForTokens{ value: _share }(\n                        0,\n                        s.shares[i].swap,\n                        s.shares[i].receiver.isContract() ? address(this) : s.shares[i].receiver,\n                        block.timestamp\n                    );\n                    _share = amounts[amounts.length - 1];\n                    if (s.shares[i].receiver.isContract()) {\n                        IERC20(_token).approve(s.shares[i].receiver, _share);\n                        IDepositable(s.shares[i].receiver).deposit(_token, _share);\n                    }\n                    emit Distributed(s.shares[i].receiver, _share);\n                } else if (s.shares[i].receiver.isContract()) {\n                    IWAVAX(s.nativeWrapper).deposit{ value: _share }();\n                    IERC20(s.nativeWrapper).approve(s.shares[i].receiver, _share);\n                    IDepositable(s.shares[i].receiver).deposit(s.nativeWrapper, _share);\n                    emit Distributed(s.shares[i].receiver, _share);\n                } else {\n                    payable(s.shares[i].receiver).sendValue(_share);\n                    emit Distributed(s.shares[i].receiver, _share);\n                }\n            }\n        } else {\n            payable(_receiver).sendValue(_amount);\n            emit Distributed(_receiver, _amount);\n        }\n    }\n\n    /// Set the the running state of the distributor\n    /// @param _running flag\n    function _setRunning(bool _running) internal {\n        LibAccessControlEnumerable.checkRole(Constants.FEE_MANAGER_ROLE);\n        Storage storage s = _store();\n        s.running = _running;\n    }\n\n    function _payoutBountyInToken(address _token, uint256 _amount, address _receiver) internal returns (uint256 _amountLeft) {\n        Storage storage s = _store();\n        _amountLeft = _amount;\n        if (s.bountyActive && s.bountyShare > 0 && _receiver != address(0) && _amountLeft > 0) {\n            uint256 _bountyAmount = (_amountLeft * s.bountyShare) / 10 ** 6;\n            _amountLeft -= _bountyAmount;\n            s.totalBounties += _bountyAmount;\n            s.lastBountyAmount = _bountyAmount;\n            s.lastBountyReceiver = _receiver;\n            // slither-disable-next-line unchecked-transfer\n            IERC20(_token).transfer(_receiver, _bountyAmount);\n            emit BountyPaid(_bountyAmount, _receiver);\n        }\n    }\n\n    function _payoutBountyInNative(uint256 _amount, address _receiver) internal returns (uint256 _amountLeft) {\n        Storage storage s = _store();\n        _amountLeft = _amount;\n        if (s.bountyActive && s.bountyShare > 0 && _receiver != address(0) && _amountLeft > 0) {\n            uint256 _bountyAmount = (_amountLeft * s.bountyShare) / 10 ** 6;\n            _amountLeft -= _bountyAmount;\n            s.totalBounties += _bountyAmount;\n            s.lastBountyAmount = _bountyAmount;\n            s.lastBountyReceiver = _receiver;\n            payable(_receiver).sendValue(_bountyAmount);\n            emit BountyPaid(_bountyAmount, _receiver);\n        }\n    }\n\n    /// Store\n    function _store() internal pure returns (Storage storage s) {\n        bytes32 position = STORAGE_NAMESPACE;\n        assembly {\n            s.slot := position\n        }\n    }\n}\n"
    },
    "contracts/diamond/facets/FeeManagerFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.19;\n\nimport { LibAccessControlEnumerable } from \"./../libraries/LibAccessControlEnumerable.sol\";\nimport { LibFeeManagerStorage } from \"./../libraries/LibFeeManagerStorage.sol\";\nimport { LibFeeManager } from \"./../libraries/LibFeeManager.sol\";\nimport {\n    AddChainParams,\n    AddFeeConfigParams,\n    AssignFeeConfigToChainParams,\n    FeeConfig,\n    FeeConfigDeployState,\n    FeeSyncQueue,\n    RemoveChainParams,\n    RemoveFeeConfigParams,\n    UnassignFeeConfigFromAllChainsParams,\n    UnassignFeeConfigFromChainParams,\n    UpdateFeeConfigParams\n} from \"./../helpers/Structs.sol\";\nimport { addressZeroCheck } from \"./../helpers/Functions.sol\";\nimport { FeeSyncAction, FeeDeployState } from \"./../helpers/Enums.sol\";\nimport { Constants } from \"./../helpers/Constants.sol\";\n\n/// @title Fee Manager Facet\n/// @author Daniel <danieldegendev@gmail.com>\n/// @notice It's responsible for managing fees and its state of deployment. This contract supposed to be deployed only on the home chain, not on the target chain.\n/// @custom:version 1.0.0\ncontract FeeManagerFacet {\n    error ChainIdZero();\n    error ChainIdExists(uint256 chainId);\n    error ChainIdNotExisting(uint256 chainId);\n    error ConfigAlreadyAssignedToChain(bytes32 id, uint256 chainId);\n    error ConfigNotAssignedToChain(bytes32 id, uint256 chainId);\n    error ConfigsAssignedToChain(uint256 chainId);\n    error ConfigInUse(bytes32 id);\n    error FeeZero();\n    error ConfigExists(bytes32 id);\n    error ConfigNotExisting(bytes32 id);\n    error SyncQueueEmpty();\n\n    event FeeConfigAdded(bytes32 indexed id, AddFeeConfigParams params, address sender);\n    event FeeConfigUpdated(bytes32 indexed id, UpdateFeeConfigParams params, address sender);\n    event FeeConfigRemoved(bytes32 indexed id, address sender);\n    event ChainAdded(uint256 chainId, address target);\n    event ChainRemoved(uint256 chainId);\n    event ConfigAssignedToChain(bytes32 indexed id, uint256 chainId);\n    event ConfigUnassignedFromChain(bytes32 indexed id, uint256 chainId);\n    event ConfigUnassignedFromAllChains(bytes32 indexed id);\n    event ClearQueue();\n    event ManuallyQueued();\n\n    /// Adds a corresponding chain\n    /// @param _params consists of the chain id and target addess\n    /// @dev the target address is the desired contract address receiving the fee config information\n    function addChain(AddChainParams calldata _params) external {\n        LibAccessControlEnumerable.checkRole(Constants.FEE_MANAGER_ROLE);\n        if (_params.chainId == 0) revert ChainIdZero();\n        addressZeroCheck(_params.target);\n        LibFeeManagerStorage.FeeManagerStorage storage _store = LibFeeManagerStorage.feeManagerStorage();\n        if (_store.isChainSupported[_params.chainId]) revert ChainIdExists(_params.chainId);\n        _store.isChainSupported[_params.chainId] = true;\n        _store.chainTargets[_params.chainId] = _params.target;\n        _store.chainIds.push(_params.chainId);\n        emit ChainAdded(_params.chainId, _params.target);\n    }\n\n    /// Removes a corresponding chain\n    /// @param _params consists only of the chain id\n    function removeChain(RemoveChainParams calldata _params) external {\n        LibAccessControlEnumerable.checkRole(Constants.FEE_MANAGER_ROLE);\n        LibFeeManagerStorage.FeeManagerStorage storage _store = LibFeeManagerStorage.feeManagerStorage();\n        if (!_store.isChainSupported[_params.chainId]) revert ChainIdNotExisting(_params.chainId);\n        if (_store.chainIdFeeConfigMap[_params.chainId].length > 0) revert ConfigsAssignedToChain(_params.chainId);\n        delete _store.chainTargets[_params.chainId];\n        delete _store.isChainSupported[_params.chainId];\n        emit ChainRemoved(_params.chainId);\n    }\n\n    /// Adds a fee config\n    /// @param _params see {contracts/diamond/helpers/Structs.sol#AddFeeConfigParams}\n    /// @dev will fail if a config id is already existing or the fee value is zero\n    function addFeeConfig(AddFeeConfigParams calldata _params) external {\n        LibAccessControlEnumerable.checkRole(Constants.FEE_MANAGER_ROLE);\n        if (LibFeeManager.exists(_params.id)) revert ConfigExists(_params.id);\n        if (_params.fee == 0) revert FeeZero();\n        LibFeeManagerStorage.FeeManagerStorage storage _store = LibFeeManagerStorage.feeManagerStorage();\n        _store.feeConfigs[_params.id] = FeeConfig({\n            fee: _params.fee,\n            receiver: _params.receiver,\n            ftype: _params.ftype,\n            currency: _params.currency\n        });\n        _store.feeConfigIds.push(_params.id);\n        emit FeeConfigAdded(_params.id, _params, msg.sender);\n    }\n\n    /// Updates a fee config partially\n    /// @param _params see {contracts/diamond/helpers/Structs.sol#UpdateFeeConfigParams}\n    /// @dev if you need more data changed than _params in providing, remove and add a fee\n    function updateFeeConfig(UpdateFeeConfigParams calldata _params) external {\n        LibAccessControlEnumerable.checkRole(Constants.FEE_MANAGER_ROLE);\n        if (!LibFeeManager.exists(_params.id)) revert ConfigNotExisting(_params.id);\n        if (_params.fee == 0) revert FeeZero();\n        LibFeeManagerStorage.FeeManagerStorage storage _store = LibFeeManagerStorage.feeManagerStorage();\n        LibFeeManager.archiveFeeConfig(_params.id);\n        _store.feeConfigs[_params.id].fee = _params.fee;\n        _store.feeConfigs[_params.id].receiver = _params.receiver;\n        for (uint256 i = 0; i < _store.chainIds.length; i++) {\n            for (uint256 j = 0; j < _store.chainIdFeeConfigMap[_store.chainIds[i]].length; j++) {\n                if (_store.chainIdFeeConfigMap[_store.chainIds[i]][j] == _params.id) {\n                    LibFeeManager.queue(_params.id, _store.chainIds[i], FeeSyncAction.Update);\n                }\n            }\n        }\n        emit FeeConfigUpdated(_params.id, _params, msg.sender);\n    }\n\n    /// Removes a fee config\n    /// @param _params params consist of a fee id that should be removed\n    function removeFeeConfig(RemoveFeeConfigParams calldata _params) external {\n        LibAccessControlEnumerable.checkRole(Constants.FEE_MANAGER_ROLE);\n        if (!LibFeeManager.exists(_params.id)) revert ConfigNotExisting(_params.id);\n        if (LibFeeManager.isFeeConfigInUse(_params.id)) revert ConfigInUse(_params.id);\n        LibFeeManagerStorage.FeeManagerStorage storage _store = LibFeeManagerStorage.feeManagerStorage();\n        LibFeeManager.archiveFeeConfig(_params.id);\n        for (uint256 i = 0; i < _store.feeConfigIds.length; i++) {\n            if (_store.feeConfigIds[i] == _params.id) {\n                _store.feeConfigIds[i] = _store.feeConfigIds[_store.feeConfigIds.length - 1];\n                break;\n            }\n        }\n        _store.feeConfigIds.pop();\n        delete _store.feeConfigs[_params.id];\n        emit FeeConfigRemoved(_params.id, msg.sender);\n    }\n\n    /// Adds a fee config to chain connection\n    /// @param _params see {contracts/diamond/helpers/Structs.sol#AssignFeeConfigToChainParams}\n    /// @dev after the assignment, the fee config is added to a queue with an add action\n    function assignFeeConfigToChain(AssignFeeConfigToChainParams calldata _params) external {\n        LibAccessControlEnumerable.checkRole(Constants.FEE_MANAGER_ROLE);\n        if (!LibFeeManager.exists(_params.id)) revert ConfigNotExisting(_params.id);\n        LibFeeManagerStorage.FeeManagerStorage storage _store = LibFeeManagerStorage.feeManagerStorage();\n        if (!_store.isChainSupported[_params.chainId]) revert ChainIdNotExisting(_params.chainId);\n        if (_store.chainIdFeeConfig[_params.chainId][_params.id]) revert ConfigAlreadyAssignedToChain(_params.id, _params.chainId);\n        _store.chainIdFeeConfig[_params.chainId][_params.id] = true;\n        _store.chainIdFeeConfigMap[_params.chainId].push(_params.id);\n        LibFeeManager.queue(_params.id, _params.chainId, FeeSyncAction.Add);\n        emit ConfigAssignedToChain(_params.id, _params.chainId);\n    }\n\n    /// Removes a fee config to chain connection\n    /// @param _params see {contracts/diamond/helpers/Structs.sol#UnassignFeeConfigFromChainParams}\n    /// @dev the main task will be done in {_decoupleFeeConfigFromChain}\n    function unassignFeeConfigFromChain(UnassignFeeConfigFromChainParams calldata _params) external {\n        LibAccessControlEnumerable.checkRole(Constants.FEE_MANAGER_ROLE);\n        if (!LibFeeManager.exists(_params.id)) revert ConfigNotExisting(_params.id);\n        LibFeeManagerStorage.FeeManagerStorage storage _store = LibFeeManagerStorage.feeManagerStorage();\n        if (!_store.isChainSupported[_params.chainId]) revert ChainIdNotExisting(_params.chainId);\n        if (!_store.chainIdFeeConfig[_params.chainId][_params.id]) revert ConfigNotAssignedToChain(_params.id, _params.chainId);\n        _decoupleFeeConfigFromChain(_params.id, _params.chainId);\n        emit ConfigUnassignedFromChain(_params.id, _params.chainId);\n    }\n\n    /// Removes all existing fee config to chain connections\n    /// @param _params see {contracts/diamond/helpers/Structs.sol#UnassignFeeConfigFromAllChainsParams}\n    /// @dev it will iteration through all chains and removes the connections. The main task will be done in {_decoupleFeeConfigFromChain}\n    function unassignFeeConfigFromAllChains(UnassignFeeConfigFromAllChainsParams calldata _params) external {\n        LibAccessControlEnumerable.checkRole(Constants.FEE_MANAGER_ROLE);\n        if (!LibFeeManager.exists(_params.id)) revert ConfigNotExisting(_params.id);\n        LibFeeManagerStorage.FeeManagerStorage storage _store = LibFeeManagerStorage.feeManagerStorage();\n        for (uint256 i = 0; i < _store.chainIds.length; i++) _decoupleFeeConfigFromChain(_params.id, _store.chainIds[i]);\n        emit ConfigUnassignedFromAllChains(_params.id);\n    }\n\n    /// Clears the queue and removes all current jobs\n    /// @dev the deployment state is set to pending while doing\n    function clearQueue() external {\n        LibAccessControlEnumerable.checkRole(Constants.FEE_MANAGER_ROLE);\n        LibFeeManagerStorage.FeeManagerStorage storage s = LibFeeManagerStorage.feeManagerStorage();\n        uint256[] memory _chainIds = s.chainIds;\n        for (uint256 i = 0; i < _chainIds.length; i++) {\n            for (uint256 j = 0; j < s.feeSyncQueue[_chainIds[i]].length; j++) {\n                delete s.feeDeployState[_chainIds[i]][s.feeSyncQueue[_chainIds[i]][j].id];\n            }\n            delete s.feeSyncQueue[_chainIds[i]];\n        }\n        emit ClearQueue();\n    }\n\n    /// Queues up fee configs manually\n    /// @param _syncQueue list of FeeSyncQueue data\n    function queueUpManually(FeeSyncQueue[] calldata _syncQueue) external {\n        LibAccessControlEnumerable.checkRole(Constants.FEE_MANAGER_ROLE);\n        LibFeeManagerStorage.FeeManagerStorage storage s = LibFeeManagerStorage.feeManagerStorage();\n        for (uint256 i = 0; i < _syncQueue.length; i++) {\n            if (!LibFeeManager.exists(_syncQueue[i].id)) revert ConfigNotExisting(_syncQueue[i].id);\n            if (!s.isChainSupported[_syncQueue[i].chainId]) revert ChainIdNotExisting(_syncQueue[i].chainId);\n            LibFeeManager.queue(_syncQueue[i].id, _syncQueue[i].chainId, _syncQueue[i].action);\n        }\n        emit ManuallyQueued();\n    }\n\n    /// viewables\n\n    /// Gets the fee config ids\n    /// @return _feeConfigIds returns an arrayf of fee config ids\n    function getFeeConfigIds() external view returns (bytes32[] memory _feeConfigIds) {\n        _feeConfigIds = LibFeeManagerStorage.feeManagerStorage().feeConfigIds;\n    }\n\n    /// Gets the fee config by fee config id\n    /// @param _id fee config id\n    /// @return _feeConfig fee config\n    function getFeeConfig(bytes32 _id) external view returns (FeeConfig memory _feeConfig) {\n        _feeConfig = LibFeeManagerStorage.feeManagerStorage().feeConfigs[_id];\n    }\n\n    /// Gets all previous fee config states by fee config id\n    /// @param _id fee config id\n    /// @return _feeConfig array of fee configs\n    function getArchivedFeeConfigs(bytes32 _id) external view returns (FeeConfig[] memory _feeConfig) {\n        _feeConfig = LibFeeManagerStorage.feeManagerStorage().feeConfigsArchive[_id];\n    }\n\n    /// Gets all fee config ids by chain id\n    /// @param _chainId chain id\n    /// @return _feeConfigs array of fee config ids\n    function getFeeConfigsByChain(uint256 _chainId) external view returns (bytes32[] memory _feeConfigs) {\n        _feeConfigs = LibFeeManagerStorage.feeManagerStorage().chainIdFeeConfigMap[_chainId];\n    }\n\n    /// Gets the current queue for a chain\n    /// @param _chainId chain id\n    /// @return _feeSyncQueue returns an array of queue items. See {contracts/diamond/helpers/Structs.sol#FeeSyncQueue}\n    function getFeeSyncQueueByChain(uint256 _chainId) external view returns (FeeSyncQueue[] memory _feeSyncQueue) {\n        _feeSyncQueue = LibFeeManagerStorage.feeManagerStorage().feeSyncQueue[_chainId];\n    }\n\n    /// Gets the current deployment state of a fee config id\n    /// @param _chainId chain id\n    /// @param _id fee config id\n    /// @return _state deployment state of a fee config\n    function getFeeConfigDeployState(uint256 _chainId, bytes32 _id) external view returns (FeeDeployState _state) {\n        _state = LibFeeManagerStorage.feeManagerStorage().feeDeployState[_chainId][_id];\n    }\n\n    /// Gets the current deployment state of all fee config ids from a given chain id\n    /// @param _chainId chain id\n    /// @return _states all deployment states of config ids for a specific chain\n    function getDeployStatesForChain(uint256 _chainId) external view returns (FeeConfigDeployState[] memory _states) {\n        LibFeeManagerStorage.FeeManagerStorage storage _s = LibFeeManagerStorage.feeManagerStorage();\n        if (_s.chainIdFeeConfigMap[_chainId].length > 0) {\n            _states = new FeeConfigDeployState[](_s.chainIdFeeConfigMap[_chainId].length);\n            for (uint256 i = 0; i < _s.chainIdFeeConfigMap[_chainId].length; i++) {\n                _states[i] = FeeConfigDeployState({\n                    id: _s.chainIdFeeConfigMap[_chainId][i],\n                    state: _s.feeDeployState[_chainId][_s.chainIdFeeConfigMap[_chainId][i]]\n                });\n            }\n        }\n    }\n\n    /// internals\n\n    /// Removes a fee config to chain connection and queues it\n    /// @param _id fee config id\n    /// @param _chainId chain id\n    function _decoupleFeeConfigFromChain(bytes32 _id, uint256 _chainId) internal {\n        LibFeeManagerStorage.FeeManagerStorage storage _store = LibFeeManagerStorage.feeManagerStorage();\n        if (_store.chainIdFeeConfigMap[_chainId].length > 0) {\n            for (uint256 i = 0; i < _store.chainIdFeeConfigMap[_chainId].length; i++) {\n                if (_store.chainIdFeeConfigMap[_chainId][i] == _id) {\n                    _store.chainIdFeeConfigMap[_chainId][i] = _store.chainIdFeeConfigMap[_chainId][\n                        _store.chainIdFeeConfigMap[_chainId].length - 1\n                    ];\n                    break;\n                }\n            }\n            _store.chainIdFeeConfigMap[_chainId].pop();\n            delete _store.chainIdFeeConfig[_chainId][_id];\n            LibFeeManager.queue(_id, _chainId, FeeSyncAction.Delete);\n        }\n    }\n}\n"
    },
    "contracts/diamond/facets/FeeStoreFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.19;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { IFeeStoreFacet } from \"./../interfaces/IFeeStoreFacet.sol\";\nimport { LibAccessControlEnumerable } from \"./../libraries/LibAccessControlEnumerable.sol\";\nimport { LibFeeStoreStorage } from \"./../libraries/LibFeeStoreStorage.sol\";\nimport { LibFeeStore } from \"./../libraries/LibFeeStore.sol\";\nimport { FeeConfig, FeeConfigSyncDTO, FeeConfigSyncHomeDTO, FeeStoreConfig, FeeConfigSyncHomeFees } from \"./../helpers/Structs.sol\";\nimport { AlreadyInitialized } from \"./../helpers/GenericErrors.sol\";\nimport { addressZeroCheck } from \"./../helpers/Functions.sol\";\nimport { FeeSyncAction } from \"./../helpers/Enums.sol\";\nimport { Constants } from \"./../helpers/Constants.sol\";\n\n/// @title Fee Store Facet\n/// @author Daniel <danieldegendev@gmail.com>\n/// @notice every contract needs to take care of the fees they collect. ITS JUST STORAGE HERE\n/// @custom:version 1.0.0\ncontract FeeStoreFacet is IFeeStoreFacet {\n    bytes32 constant STORAGE_NAMESPACE = keccak256(\"degenx.fee-store-internal.storage.v1\");\n\n    event FeeConfigAdded(bytes32 indexed id);\n    event FeeConfigUpdated(bytes32 indexed id);\n    event FeeConfigDeleted(bytes32 indexed id);\n    event FeeConfigMarkedAsDeleted(bytes32 indexed id);\n    event FeesPrepared(uint256 amount, FeeConfigSyncHomeDTO candidate);\n    event FeesSynced(FeeConfigSyncDTO[] candidates);\n    event FeesRestored(FeeConfigSyncHomeDTO candidate);\n    event FeesCollected(FeeConfigSyncHomeDTO candidate);\n    event UpdatedOperator(address operator);\n    event UpdatedIntermediateAsset(address intermediateAsset);\n    event FeeAmountDeposited(address indexed _asset, bytes32 indexed _feeConfigId, uint256 _amount);\n    event Initialized();\n\n    error InvalidFee(bytes32 id);\n    error DataMissing();\n    error TransferFailed();\n\n    struct Storage {\n        // initialized flag\n        bool initialized;\n    }\n\n    /// Initializes the facet\n    /// @param _operator address of account that is receiving fees if this contracts automations are failing\n    function initFeeStoreFacet(address _operator, address _intermediateAsset) external {\n        LibAccessControlEnumerable.checkRole(Constants.DEPLOYER_ROLE);\n        LibFeeStoreStorage.FeeStoreStorage storage s = _store();\n        Storage storage si = _storeInternal();\n        if (si.initialized) revert AlreadyInitialized();\n        s.operator = _operator;\n        s.intermediateAsset = _intermediateAsset;\n        si.initialized = true;\n        emit Initialized();\n    }\n\n    /// @inheritdoc IFeeStoreFacet\n    /// @dev it will check wheter an array is sufficient and add, updates or removes fee configs based on the fee sync action create by the fee manager\n    function syncFees(FeeConfigSyncDTO[] calldata _feeConfigSyncDTO) external payable {\n        LibAccessControlEnumerable.checkRole(Constants.FEE_STORE_MANAGER_ROLE);\n        if (_feeConfigSyncDTO.length == 0) revert DataMissing();\n        for (uint256 i = 0; i < _feeConfigSyncDTO.length; ) {\n            FeeConfigSyncDTO memory _dto = _feeConfigSyncDTO[i];\n            if (_dto.id == bytes32(0)) revert InvalidFee(_dto.id);\n            if (_dto.fee == 0) revert InvalidFee(_dto.id);\n            if (_dto.action == FeeSyncAction.Add) {\n                _addFee(_dto.id, _dto.fee, _dto.target);\n            }\n            if (_dto.action == FeeSyncAction.Update) {\n                _updateFee(_dto.id, _dto.fee, _dto.target);\n            }\n            if (_dto.action == FeeSyncAction.Delete) {\n                _deleteFee(_dto.id);\n            }\n            unchecked {\n                i++;\n            }\n        }\n        emit FeesSynced(_feeConfigSyncDTO);\n    }\n\n    /// @dev this function restores the fees based on refunds from bridge providers, in case someone starts try to sync fees home and it's failing on the bridge side\n    /// @dev if the fee config is not configured anymore, the funds that are getting restored, will be send to the operator\n    /// @inheritdoc IFeeStoreFacet\n    function restoreFeesFromSendFees(FeeConfigSyncHomeDTO memory _dto) external payable {\n        LibAccessControlEnumerable.checkRole(Constants.FEE_STORE_MANAGER_ROLE);\n        LibFeeStoreStorage.FeeStoreStorage storage s = _store();\n        try IERC20(s.intermediateAsset).transferFrom(msg.sender, address(this), _dto.totalFees) returns (bool _success) {\n            if (_success) {\n                for (uint256 i = 0; i < _dto.fees.length; ) {\n                    if (s.feeConfigs[_dto.fees[i].id].id == bytes32(\"\")) {\n                        IERC20(s.intermediateAsset).transfer(s.operator, _dto.fees[i].amount);\n                    } else {\n                        s.collectedFeesTotal += _dto.fees[i].amount;\n                        s.collectedFees[_dto.fees[i].id] += _dto.fees[i].amount;\n                    }\n                    unchecked {\n                        i++;\n                    }\n                }\n                emit FeesRestored(_dto);\n            } else revert TransferFailed();\n        } catch Error(string memory reason) {\n            revert(reason);\n        }\n    }\n\n    /// @notice Sends the current collected fees to the Manager in case no bridge provider is working and the job needs to be done manually\n    function collectFeesFromFeeStore() external {\n        LibAccessControlEnumerable.checkRole(Constants.FEE_STORE_MANAGER_ROLE);\n        LibFeeStoreStorage.FeeStoreStorage storage s = _store();\n        addressZeroCheck(s.operator);\n        FeeConfigSyncHomeDTO memory _dto = LibFeeStore.prepareToSendFees();\n        // slither-disable-next-line unchecked-transfer\n        IERC20(s.intermediateAsset).transfer(s.operator, _dto.totalFees);\n        emit FeesCollected(_dto);\n    }\n\n    /// Sets a new operator\n    /// @param _operator address of the operator\n    /// @dev _operator can't be a zero address\n    function setOperator(address _operator) external {\n        LibAccessControlEnumerable.checkRole(Constants.DEPLOYER_ROLE);\n        addressZeroCheck(_operator);\n        LibFeeStore.setOperator(_operator);\n        emit UpdatedOperator(_operator);\n    }\n\n    /// Sets the intermediate asset\n    /// @param _intermediateAsset address of the asset\n    /// @dev _intermediateAsset can't be a zero address\n    function setIntermediateAsset(address _intermediateAsset) external {\n        LibAccessControlEnumerable.checkRole(Constants.DEPLOYER_ROLE);\n        addressZeroCheck(_intermediateAsset);\n        LibFeeStore.setIntermediateAsset(_intermediateAsset);\n        emit UpdatedIntermediateAsset(_intermediateAsset);\n    }\n\n    /// Deposit a fee manually\n    /// @param _feeConfigId fee config id\n    /// @param _amount amount to deposit\n    /// @dev can only be executed from the fee store manager role\n    function feeStoreDepositFeeAmount(bytes32 _feeConfigId, uint256 _amount) external {\n        LibAccessControlEnumerable.checkRole(Constants.FEE_STORE_MANAGER_ROLE);\n        address _asset = LibFeeStore.getIntermediateAsset();\n        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);\n        LibFeeStore.putFees(_feeConfigId, _amount);\n        emit FeeAmountDeposited(_asset, _feeConfigId, _amount);\n    }\n\n    /// viewables\n\n    /// Gets a fee store config based on the fee id\n    /// @param _id fee config id\n    /// @return _feeStoreConfig FeeStoreConfig, see {contracts/diamond/helpers/Structs.sol#FeeStoreConfig}\n    function getFeeStoreConfig(bytes32 _id) external view returns (FeeStoreConfig memory _feeStoreConfig) {\n        LibFeeStoreStorage.FeeStoreStorage storage s = _store();\n        _feeStoreConfig = s.feeConfigs[_id];\n    }\n\n    /// Gets the current collected total fees on this store\n    /// @return _collectedFeesTotal amount of total fees collected\n    /// @dev this is a cumulative number of all fees collected on this store until it get's send to the home chain\n    function getCollectedFeesTotal() external view returns (uint256 _collectedFeesTotal) {\n        LibFeeStoreStorage.FeeStoreStorage storage s = _store();\n        _collectedFeesTotal = s.collectedFeesTotal;\n    }\n\n    /// Gets the collected fees for a specific fee id\n    /// @param _id fee config id\n    /// @return _collectedFees amount of fees collected\n    function getCollectedFeesByConfigId(bytes32 _id) external view returns (uint256 _collectedFees) {\n        LibFeeStoreStorage.FeeStoreStorage storage s = _store();\n        _collectedFees = s.collectedFees[_id];\n    }\n\n    /// Gets all fee config ids defined on this fee store\n    /// @return _feeConfigIds array of fee ids\n    function getFeeConfigIds() external view returns (bytes32[] memory _feeConfigIds) {\n        LibFeeStoreStorage.FeeStoreStorage storage s = _store();\n        _feeConfigIds = s.feeConfigIds;\n    }\n\n    /// Gets the current operator\n    /// @return _operator address of the operator\n    function getOperator() external view returns (address _operator) {\n        _operator = LibFeeStore.getOperator();\n    }\n\n    /// Gets the current intermediate asset\n    /// @return _intermediateAsset address of the intermadiate asset\n    function getIntermediateAsset() external view returns (address _intermediateAsset) {\n        _intermediateAsset = LibFeeStore.getIntermediateAsset();\n    }\n\n    /// internals\n\n    /// Wrapper function to add a fee to the store\n    /// @param _id fee id\n    /// @param _fee fee value\n    /// @param _target the target address\n    function _addFee(bytes32 _id, uint256 _fee, address _target) internal {\n        LibFeeStore.addFee(_id, _fee, _target);\n    }\n\n    /// Wrapper function to update a fee in the store\n    /// @param _id fee id\n    /// @param _fee fee value\n    /// @param _target the target address\n    function _updateFee(bytes32 _id, uint256 _fee, address _target) internal {\n        LibFeeStore.updateFee(_id, _fee, _target);\n    }\n\n    /// Removes a fee from the store\n    /// @param _id fee id\n    function _deleteFee(bytes32 _id) internal {\n        LibFeeStore.deleteFee(_id);\n    }\n\n    /// Store\n    function _store() internal pure returns (LibFeeStoreStorage.FeeStoreStorage storage s) {\n        s = LibFeeStoreStorage.feeStoreStorage();\n    }\n\n    /// InternalStore\n    function _storeInternal() internal pure returns (Storage storage s) {\n        bytes32 position = STORAGE_NAMESPACE;\n        assembly {\n            s.slot := position\n        }\n    }\n}\n"
    },
    "contracts/diamond/helpers/Constants.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\nlibrary Constants {\n    /*-------------------------------- Role --------------------------------*/\n    // 0x0000000000000000000000000000000000000000000000000000000000000000\n    bytes32 constant DEFAULT_ADMIN_ROLE = 0x00;\n    // 0xa49807205ce4d355092ef5a8a18f56e8913cf4a201fbe287825b095693c21775\n    bytes32 constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    // 0xfc425f2263d0df187444b70e47283d622c70181c5baebb1306a01edba1ce184c\n    bytes32 constant DEPLOYER_ROLE = keccak256(\"DEPLOYER_ROLE\");\n    // 0x6c0757dc3e6b28b2580c03fd9e96c274acf4f99d91fbec9b418fa1d70604ff1c\n    bytes32 constant FEE_MANAGER_ROLE = keccak256(\"FEE_MANAGER_ROLE\");\n    // 0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6\n    bytes32 constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    // 0x3c11d16cbaffd01df69ce1c404f6340ee057498f5f00246190ea54220576a848\n    bytes32 constant BURNER_ROLE = keccak256(\"BURNER_ROLE\");\n    // 0x63eb04268b235ac1afacf3bcf4b19c5c175d0417a1555fb3ff79ae190f71ee7c\n    bytes32 constant FEE_STORE_MANAGER_ROLE = keccak256(\"FEE_STORE_MANAGER_ROLE\");\n    // 0x77f52ccf2f32e71a0cff8f14ad8c8303b7d2e4c7609b8fba963114f4db2af767\n    bytes32 constant FEE_DISTRIBUTOR_PUSH_ROLE = keccak256(\"FEE_DISTRIBUTOR_PUSH_ROLE\");\n    // 0xe85d5f1f8338cb18f500856d1568d0f3b0d0971f25b3ccd134475e991354edbf\n    bytes32 constant FEE_DISTRIBUTOR_MANAGER = keccak256(\"FEE_DISTRIBUTOR_MANAGER\");\n    /*----------------------------------------------------------------------*/\n\n    /*------------------------------- Fee ID -------------------------------*/\n    // 0xacfc432e98ad100d9f8c385f3782bc88a17e1de7e53f69678cbcc41e8ffe72b0\n    bytes32 constant ERC20_MARKETING_FEE = keccak256(\"ERC20_MARKETING_FEE\");\n    // 0x6b78196f16f828b24a5a6584d4a1bcc5ce2f3154ba57839db273e6a4ebbe92c2\n    bytes32 constant ERC20_REWARD_FEE = keccak256(\"ERC20_REWARD_FEE\");\n    // 0x6e3678bee6f77c8a6179922c9a518b08407e6d9d2593ac683a87c979c8b31a12\n    bytes32 constant ERC20_PLATFORM_FEE = keccak256(\"ERC20_PLATFORM_FEE\");\n    // 0x6e2178bb28988b4c92cd3092e9e342e7639bfda2f68a02ac478cb084759607cf\n    bytes32 constant ERC20_DEVELOPER_FEE = keccak256(\"ERC20_DEVELOPER_FEE\");\n    /*----------------------------------------------------------------------*/\n\n    /*--------------------------- Relayer Actions --------------------------*/\n    // 0xf145583e6e33d9da99af75b579493b11db4229a339336b82c748312f152b29a9\n    bytes32 constant RELAYER_ACTION_DEPLOY_FEES = keccak256(\"RELAYER_ACTION_DEPLOY_FEES\");\n    // 0xf375f410a0dc135af0d9a16e273eac999064981d8813a68af762e93567a43aac\n    bytes32 constant RELAYER_ACTION_DEPLOY_FEES_CONFIRM = keccak256(\"RELAYER_ACTION_DEPLOY_FEES_CONFIRM\");\n    // 0x9d62257b25ea052fe7cd5123fd6b791268b8673b073aae5de4a823c4dc7d7607\n    bytes32 constant RELAYER_ACTION_SEND_FEES = keccak256(\"RELAYER_ACTION_SEND_FEES\");\n    /*----------------------------------------------------------------------*/\n}\n"
    },
    "contracts/diamond/helpers/Enums.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\n/// enums\nenum FeeCurrency {\n    Null,\n    // L1\n    Native,\n    // different asset\n    Token\n}\n\nenum FeeType {\n    Null,\n    // absolute/onetime\n    Default,\n    // buy/sell depending on target\n    From,\n    // buy/sell depending on target\n    To\n}\n\nenum FeeSyncAction {\n    Null,\n    // adding a fee\n    Add,\n    // updating a fee\n    Update,\n    // removing a fee\n    Delete\n}\n\nenum FeeDeployState {\n    Null,\n    // a fee is recently added, updated or removed\n    Queued,\n    // a fee config is deployed\n    Pending,\n    // a fee gets receives information about being deployed\n    Deployed\n}\n"
    },
    "contracts/diamond/helpers/Functions.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.17;\n\nimport { AddressZero } from \"./GenericErrors.sol\";\n\nfunction addressZeroCheck(address _candidate) pure {\n    if (_candidate == address(0)) revert AddressZero();\n}\n"
    },
    "contracts/diamond/helpers/GenericErrors.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\nerror AddressZero();\nerror ZeroValueNotAllowed();\nerror InsufficientAllowance();\nerror InsufficientBalance();\nerror InsufficientFunds();\nerror NotAllowed();\nerror AlreadyInitialized();\nerror NoReetrancy();\nerror WrongChain();\nerror UnexpectedBalance();\nerror FailToSendNative();\n"
    },
    "contracts/diamond/helpers/Structs.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\nimport { FeeCurrency, FeeType, FeeSyncAction, FeeDeployState } from \"./Enums.sol\";\n\n/// General Fee Config\n\nstruct FeeConfig {\n    // relative: 10000 = 1% or 100 = 0.01%\n    // absolute: 10000 = 1 or 1 = 0.0001\n    uint256 fee;\n    // Assets are always going to the fee distributor on the home chain. This config is necessary to define which receiver gets this asset.\n    // It's purpose can be overwritten by the FeeDistributor. So it will serve as a fallback.\n    address receiver;\n    // defines the type. It does not have a purpose yet but may have in the future\n    // see {Enums->FeeType}\n    FeeType ftype;\n    // type of how the fees should be handles\n    // see {Enums->FeeCurrency}\n    FeeCurrency currency;\n    // // Deploy state of a fee config\n    // // see {Enums->FeeDeployState}\n    // FeeDeployState deployState;\n}\n\n/// Fee Management\n\nstruct AddFeeConfigParams {\n    // fee id which can be defined elsewhere but needs to be a bytes32\n    bytes32 id;\n    // see {struct FeeConfig->fee}\n    uint256 fee;\n    // see {struct FeeConfig->receiver}\n    address receiver;\n    // see {struct FeeConfig->ftype}\n    FeeType ftype;\n    // see {struct FeeConfig->currency}\n    FeeCurrency currency;\n}\n\nstruct UpdateFeeConfigParams {\n    // see {struct AddFeeConfigParams->id}\n    bytes32 id;\n    // see {struct FeeConfig->fee}\n    uint256 fee;\n    // see {struct FeeConfig->fee}\n    address receiver;\n}\n\nstruct RemoveFeeConfigParams {\n    // see {struct AddFeeConfigParams->id}\n    bytes32 id;\n}\n\n/// Chain Management\n\nstruct AddChainParams {\n    // chain id\n    uint256 chainId;\n    // address of the participant, most likely the diamon address of the target chain\n    address target;\n}\nstruct RemoveChainParams {\n    // chain id\n    uint256 chainId;\n}\n\n/// Fee & Chain Management\n\nstruct AssignFeeConfigToChainParams {\n    // fee config id\n    bytes32 id;\n    // chain id to assign the fee config id to\n    uint256 chainId;\n}\nstruct UnassignFeeConfigFromChainParams {\n    // fee config id\n    bytes32 id;\n    // chain id to unassign the fee config id from\n    uint256 chainId;\n}\nstruct UnassignFeeConfigFromAllChainsParams {\n    // fee config id\n    bytes32 id;\n}\n\n/// Syncing\n\nstruct FeeSyncQueue {\n    // fee config id\n    bytes32 id;\n    // chain id\n    uint256 chainId;\n    // action to execute on the target chain\n    FeeSyncAction action;\n}\n\nstruct FeeConfigDeployState {\n    bytes32 id;\n    FeeDeployState state;\n}\n\n/// Data Transfer Objects\n\nstruct FeeConfigSyncDTO {\n    // fee config id\n    bytes32 id;\n    // fee value\n    uint256 fee;\n    // address to make conditional charged based on a specific token\n    // a contract can decide by itself whether to it or not\n    // if defined and used, this fee should be restricted and charged onto a specific token\n    address target;\n    // desired action to execute on the target chain\n    FeeSyncAction action;\n}\nstruct FeeConfigSyncHomeFees {\n    // fee config id\n    bytes32 id;\n    // amount of the collected fees of this if\n    uint256 amount;\n}\nstruct FeeConfigSyncHomeDTO {\n    // total amount of collected fees\n    uint256 totalFees;\n    // address of the bounty receiver on the home chain\n    address bountyReceiver;\n    // containing fee information that will moved to the home chain\n    FeeConfigSyncHomeFees[] fees;\n}\n\nstruct CelerRelayerData {\n    // bytes32 hash which defined the action that should be taken\n    bytes32 what;\n    // address of the contract which what is being executed to\n    address target;\n    // encoded message of the desired scope\n    bytes message;\n}\n\n/// Fee Store\n\nstruct FeeStoreConfig {\n    // fee config id\n    bytes32 id;\n    // fee\n    uint256 fee;\n    // address of the contract which what is being executed to\n    address target;\n    // flag for being markes as deleted\n    bool deleted;\n}\n\n/// Fee Distributor\n\nstruct AddReceiverParams {\n    // public name for the receiver\n    // can be \"Staking\", \"Liquidity Backing\" or whatever\n    string name;\n    // potion of share in points. Points will be summarized in the distribution to calculate the relative share\n    uint64 points;\n    // address of the contract/account that receives the share\n    address account;\n    // swap path in case a share receiver expects another token then the intermediate token of the bridge\n    address[] swapPath;\n}\n"
    },
    "contracts/diamond/interfaces/IAggregator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.17;\n\nstruct SwapPaths {\n    address[] tjoePath;\n    address[] pangoPath;\n}\n\nstruct OptimalSwapBalance {\n    uint256 inputAmountTjoe;\n    uint256 inputAmountPango;\n    uint256 outputAmountBalanced;\n    uint256 outputAmountUnbalanced;\n}\n\nstruct MultiswapBalanced {\n    uint256 inputAmount;\n    uint256 outputAmountMin;\n    address[] tjoePath;\n    address[] pangoPath;\n}\n\ninterface IAggregator {\n    function determineOptimalSwaps(\n        uint256 inputAmount,\n        SwapPaths memory swapPaths\n    ) external view returns (OptimalSwapBalance memory optimalSwap);\n\n    function multiswapBalanced(\n        MultiswapBalanced calldata swapData\n    ) external payable returns (uint256 outputAmountNet, uint256 outputAmountGross, uint256 commissionAmount);\n\n    function isValidPair(address from, address to) external view returns (bool isPair);\n}\n"
    },
    "contracts/diamond/interfaces/ICelerFeeHubFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.17;\n\n/// @title CelerFeeHubFacet Interface\n/// @author Daniel <danieldegendev@gmail.com>\ninterface ICelerFeeHubFacet {\n    /// Registers the successful deployment of the fees to the given chain\n    /// @param _chainId chain id\n    /// @param _message encoded message\n    function deployFeesWithCelerConfirm(uint64 _chainId, bytes memory _message) external;\n}\n"
    },
    "contracts/diamond/interfaces/IDepositable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.19;\n\n/// @title Depositable Interface\n/// @author Daniel <danieldegendev@gmail.com>\ninterface IDepositable {\n    /// Deposits a token into corresponding contracts like \"Liquidity Backing\" and \"Staking\"\n    /// @param _token address of the token that should be deposited\n    /// @param _amount amount of token\n    function deposit(address _token, uint256 _amount) external;\n}\n"
    },
    "contracts/diamond/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\n\n}\n"
    },
    "contracts/diamond/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupe {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}\n"
    },
    "contracts/diamond/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/diamond/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\n/// @title ERC-173 Contract Ownership Standard\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\n/* is ERC165 */\ninterface IERC173 {\n    /// @dev This emits when ownership of a contract changes.\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice Get the address of the owner\n    /// @return owner_ The address of the owner.\n    function owner() external view returns (address owner_);\n\n    /// @notice Set the address of the new owner of the contract\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\n    /// @param _newOwner The address of the new owner of the contract\n    function transferOwnership(address _newOwner) external;\n}\n"
    },
    "contracts/diamond/interfaces/IERC20Facet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.19;\n\n/// @title ERC20 Facet Interface\n/// @author Daniel <danieldegendev@gmail.com>\ninterface IERC20Facet {\n    /// Minting an amount of tokens for a designated receiver\n    /// @param _to receiver address of the token\n    /// @param _amount receiving amount\n    /// @return _success Returns true is operation succeeds\n    /// @notice It allows to mint specified amount until the bridge supply cap is reached\n    function mint(address _to, uint256 _amount) external returns (bool _success);\n\n    /// Burning an amount of tokens from sender\n    /// @param _amount burnable amount\n    /// @return _success Returns true is operation succeeds\n    /// @notice It allows to burn a bridge supply until its supply is 0, even if the cap is already set to 0\n    function burn(uint256 _amount) external returns (bool _success);\n\n    /// Burning an amount of tokens from a designated holder\n    /// @param _from holder address to burn the tokens from\n    /// @param _amount burnable amount\n    /// @return _success Returns true is operation succeeds\n    /// @notice It allows to burn a bridge supply until its supply is 0, even if the cap is already set to 0\n    function burn(address _from, uint256 _amount) external returns (bool _success);\n\n    /// Burning an amount of tokens from a designated holder\n    /// @param _from holder address to burn the tokens from\n    /// @param _amount burnable amount\n    /// @return _success Returns true is operation succeeds\n    /// @notice It allows to burn a bridge supply until its supply is 0, even if the cap is already set to 0\n    function burnFrom(address _from, uint256 _amount) external returns (bool _success);\n\n    /// @notice This enables the transfers of this tokens\n    function enable() external;\n\n    /// @notice This disables the transfers of this tokens\n    function disable() external;\n\n    /// Exclude an account from being charged on fees\n    /// @param _account address to exclude\n    function excludeAccountFromTax(address _account) external;\n\n    /// Includes an account againt to pay fees\n    /// @param _account address to include\n    function includeAccountForTax(address _account) external;\n\n    /// Adds a liquidity pool address\n    /// @param _lp address of the liquidity pool of the token\n    function addLP(address _lp) external;\n\n    /// Removes a liquidity pool address\n    /// @param _lp address of the liquidity pool of the token\n    function removeLP(address _lp) external;\n\n    /// Returns the existence of an lp address\n    /// @return _has has lp or not\n    function hasLP(address _lp) external view returns (bool _has);\n\n    /// Adds a buy fee based on a fee id\n    /// @param _id fee id\n    function addBuyFee(bytes32 _id) external;\n\n    /// Adds a sell fee based on a fee id\n    /// @param _id fee id\n    function addSellFee(bytes32 _id) external;\n}\n"
    },
    "contracts/diamond/interfaces/IFeeDistributorFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.17;\n\nimport { FeeConfigSyncHomeDTO } from \"./../helpers/Structs.sol\";\n\n/// @title Fee Distributor Interface\n/// @author Daniel <danieldegendev@gmail.com>\ninterface IFeeDistributorFacet {\n    // this is guarateed to get the tokens before being executed\n    /// Pushes the fee to the desired receivers\n    /// @param _token the token address being received\n    /// @param _amount amount of tokens being received\n    /// @param _dto the dto of the fee store to determine the split of _amount\n    /// @dev an updated dto needs to be created since the receiving amount is not\n    ///      matching the sent amount anymore. The contract will 100% receive the\n    ///      _token _amount before being executed\n    /// @dev only available to FEE_DISTRIBUTOR_PUSH_ROLE role\n    /// @dev if the token doesn't match, it will fail.\n    function pushFees(address _token, uint256 _amount, FeeConfigSyncHomeDTO calldata _dto) external payable;\n}\n"
    },
    "contracts/diamond/interfaces/IFeeStoreFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.17;\n\nimport { FeeStoreConfig, FeeConfigSyncDTO, FeeConfigSyncHomeDTO } from \"./../helpers/Structs.sol\";\n\n/// @title Fee Store Facet Interface\n/// @author Daniel <danieldegendev@gmail.com>\ninterface IFeeStoreFacet {\n    /// Synchronizes fee configs\n    /// @param _feeConfigSyncDTO array of fee configs to process in the fee store\n    function syncFees(FeeConfigSyncDTO[] calldata _feeConfigSyncDTO) external payable;\n\n    /// Restores fees which are actually intended to be sent to the home chain\n    /// @param _dto data which is primarily used for sending fees to the home chain\n    function restoreFeesFromSendFees(FeeConfigSyncHomeDTO memory _dto) external payable;\n}\n"
    },
    "contracts/diamond/interfaces/IRelayerCeler.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.17;\n\n/// @title Relayer Celer Interface\n/// @author Daniel <danieldegendev@gmail.com>\ninterface IRelayerCeler {\n    /// Deploys the fees to the desired chain\n    /// @param _receiver relayer on target chain\n    /// @param _target diamond address on target chain\n    /// @param _chainId target chain id\n    /// @param _message message to send to the message bus\n    function deployFees(address _receiver, address _target, uint256 _chainId, bytes calldata _message) external payable;\n\n    /// Pre calculates upcoming fees for deploying fees\n    /// @param _target diamond address on target chain\n    /// @param _message message to send to the message bus\n    function deployFeesFeeCalc(address _target, bytes calldata _message) external view returns (uint256 _wei);\n\n    /// Sends the fees to the home chain\n    /// @param _asset asset that get send\n    /// @param _amount amount of assets that gets send\n    /// @param minMaxSlippage calculated slippage by celer\n    /// @param _message message to send to the message bus\n    function sendFees(address _asset, uint256 _amount, uint32 minMaxSlippage, bytes calldata _message) external payable;\n\n    /// Pre calculates upcoming fees for sending fees\n    /// @param _message message to send to the message bus\n    function sendFeesFeeCalc(bytes calldata _message) external view returns (uint256 _wei);\n}\n"
    },
    "contracts/diamond/interfaces/IRouter02.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.17;\n\n/// @title Partial Interface of a Uniswap V2 based router\n/// @author Daniel <danieldegendev@gmail.com>\ninterface IRouter02 {\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForAVAX(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactAVAXForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n}\n"
    },
    "contracts/diamond/interfaces/IWAVAX.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\ninterface IWAVAX {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/diamond/libraries/LibAccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nlibrary LibAccessControlEnumerable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    bytes32 constant ACCESS_CONTROL_STORAGE_POSITION = keccak256(\"degenx.access.control.storage\");\n\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    struct AccessControlStorage {\n        mapping(bytes32 => RoleData) roles;\n        mapping(bytes32 => EnumerableSet.AddressSet) roleMembers;\n        mapping(bytes4 => bool) supportedInterfaces;\n    }\n\n    function accessControlStorage() internal pure returns (AccessControlStorage storage acs) {\n        bytes32 position = ACCESS_CONTROL_STORAGE_POSITION;\n        assembly {\n            acs.slot := position\n        }\n    }\n\n    function checkRole(bytes32 role) internal view {\n        checkRole(role, msg.sender);\n    }\n\n    function checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    function hasRole(bytes32 role, address account) internal view returns (bool) {\n        AccessControlStorage storage acs = accessControlStorage();\n        return acs.roles[role].members[account];\n    }\n\n    function grantRole(bytes32 role, address account) internal {\n        AccessControlStorage storage acs = accessControlStorage();\n        if (!hasRole(role, account)) {\n            acs.roles[role].members[account] = true;\n            emit RoleGranted(role, account, msg.sender);\n            acs.roleMembers[role].add(account);\n        }\n    }\n\n    function revokeRole(bytes32 role, address account) internal {\n        AccessControlStorage storage acs = accessControlStorage();\n        if (hasRole(role, account)) {\n            acs.roles[role].members[account] = false;\n            emit RoleRevoked(role, account, msg.sender);\n            acs.roleMembers[role].remove(account);\n        }\n    }\n\n    function setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\n        AccessControlStorage storage acs = accessControlStorage();\n        bytes32 previousAdminRole = acs.roles[role].adminRole;\n        acs.roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n}\n"
    },
    "contracts/diamond/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    struct DiamondStorage {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    // Internal function version of diamondCut\n    function diamondCut(IDiamondCut.FacetCut[] memory _diamondCut, address _init, bytes memory _calldata) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n            removeFunction(ds, oldFacetAddress, selector);\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(ds, oldFacetAddress, selector);\n        }\n    }\n\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\n        enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\n        ds.facetAddresses.push(_facetAddress);\n    }\n\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {\n        require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n        // an immutable function is a function defined directly in a diamond\n        require(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete ds.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            ds.facetAddresses.pop();\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            return;\n        }\n        enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                // bubble up error\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(error)\n                    revert(add(32, error), returndata_size)\n                }\n            } else {\n                revert InitializationFunctionReverted(_init, _calldata);\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "contracts/diamond/libraries/LibFeeManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.19;\n\nimport \"./LibFeeManagerStorage.sol\";\nimport { FeeConfig, FeeSyncQueue } from \"./../helpers/Structs.sol\";\nimport { FeeType, FeeSyncAction, FeeDeployState } from \"./../helpers/Enums.sol\";\n\n/// @title Lib Fee Manager\n/// @author Daniel <danieldegendev@gmail.com>\n/// @notice Helper functions for the Fee Manager Facet\nlibrary LibFeeManager {\n    /// viewables\n\n    /// Checks whether a fee config exsists or not\n    /// @param _id fee config id\n    function exists(bytes32 _id) internal view returns (bool _exists) {\n        _exists = LibFeeManagerStorage.feeManagerStorage().feeConfigs[_id].ftype != FeeType.Null;\n    }\n\n    /// Checks whether a fee config is in use on a specific chain or not\n    /// @param _id fee config id\n    function isFeeConfigInUse(bytes32 _id) internal view returns (bool _exists) {\n        for (uint256 i = 0; i < store().chainIds.length; i++) {\n            for (uint256 j = 0; j < store().chainIdFeeConfigMap[store().chainIds[i]].length; j++) {\n                if (store().chainIdFeeConfigMap[store().chainIds[i]][j] == _id) {\n                    _exists = true;\n                    break;\n                }\n            }\n        }\n    }\n\n    /// Gets the target address for a specific chain\n    /// @param _chainId chain id\n    /// @dev normally the address of the diamond on the target chain\n    function getChainTarget(uint256 _chainId) internal view returns (address _target) {\n        _target = store().chainTargets[_chainId];\n    }\n\n    /// Gets the fee config by a given id\n    /// @param _id fee config id\n    function getFeeConfigById(bytes32 _id) internal view returns (FeeConfig memory _feeConfig) {\n        LibFeeManagerStorage.FeeManagerStorage storage s = LibFeeManagerStorage.feeManagerStorage();\n        _feeConfig = s.feeConfigs[_id];\n    }\n\n    /// internals\n\n    /// Queues up a specific fee config for a specific chain with a specific action\n    /// @param _id fee config id\n    /// @param _chainId chain id\n    /// @param _action action to execute on the target chain\n    function queue(bytes32 _id, uint256 _chainId, FeeSyncAction _action) internal {\n        LibFeeManagerStorage.FeeManagerStorage storage s = LibFeeManagerStorage.feeManagerStorage();\n        bool alreadInQueue = false;\n        for (uint256 i = 0; i < s.feeSyncQueue[_chainId].length; i++)\n            alreadInQueue = alreadInQueue || (s.feeSyncQueue[_chainId][i].id == _id && s.feeSyncQueue[_chainId][i].chainId == _chainId);\n\n        if (!alreadInQueue) {\n            s.feeSyncQueue[_chainId].push(FeeSyncQueue({ id: _id, chainId: _chainId, action: _action }));\n            s.feeDeployState[_chainId][_id] = FeeDeployState.Queued;\n        }\n    }\n\n    /// Simple archiving of fee configs\n    /// @param _id fee config id\n    /// will be called on update and delete of a fee config\n    function archiveFeeConfig(bytes32 _id) internal {\n        FeeConfig storage feeConfigToArchive = LibFeeManagerStorage.feeManagerStorage().feeConfigs[_id];\n        LibFeeManagerStorage.feeManagerStorage().feeConfigsArchive[_id].push(feeConfigToArchive);\n    }\n\n    /// store\n    function store() internal pure returns (LibFeeManagerStorage.FeeManagerStorage storage _store) {\n        _store = LibFeeManagerStorage.feeManagerStorage();\n    }\n}\n"
    },
    "contracts/diamond/libraries/LibFeeManagerStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.19;\n\nimport { FeeDeployState } from \"./../helpers/Enums.sol\";\nimport { FeeConfig, FeeSyncQueue } from \"./../helpers/Structs.sol\";\n\n/// @title Lib Fee Manager Storage\n/// @author Daniel <danieldegendev@gmail.com>\n/// @notice Storage for the Fee Manager Facet\nlibrary LibFeeManagerStorage {\n    bytes32 constant FEE_MANAGER_STORAGE_POSITION = keccak256(\"degenx.fee-manager.storage.v1\");\n\n    struct FeeManagerStorage {\n        // all available chains\n        uint256[] chainIds;\n        // all available configs\n        bytes32[] feeConfigIds;\n        // contract to chain assignments\n        // chainId => contract\n        mapping(uint256 => address) chainTargets;\n        // fee config to chain assignment to store which config should be available on which chain\n        // chainId => list of fee config ids\n        mapping(uint256 => bytes32[]) chainIdFeeConfigMap;\n        // flags for quick checks to avoid looping through chainIdFeeConfigMap\n        // chainId => feeConfigId\n        mapping(uint256 => mapping(bytes32 => bool)) chainIdFeeConfig;\n        // flag if a specific chain is being supported\n        // chainId => true/false\n        mapping(uint256 => bool) isChainSupported;\n        // fee config id to fee config mapping. The fee config itself doesn't need to know its id\n        // feeConfigId => FeeConfig\n        mapping(bytes32 => FeeConfig) feeConfigs;\n        // fee config archive of recent fee config settings to a specific fee config id\n        // feeConfigId => list of fee config variants\n        mapping(bytes32 => FeeConfig[]) feeConfigsArchive;\n        // queue for syncing configs with the target contracts\n        // chainId => list of fee sync data\n        mapping(uint256 => FeeSyncQueue[]) feeSyncQueue;\n        // deployment state per chain per fee config id\n        // chainId => fee config id => deployment state of a fee config\n        mapping(uint256 => mapping(bytes32 => FeeDeployState)) feeDeployState;\n    }\n\n    /// store\n    function feeManagerStorage() internal pure returns (FeeManagerStorage storage fms) {\n        bytes32 position = FEE_MANAGER_STORAGE_POSITION;\n        assembly {\n            fms.slot := position\n        }\n    }\n}\n"
    },
    "contracts/diamond/libraries/LibFeeStore.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.17;\n\nimport { IERC20Metadata } from \"@solidstate/contracts/token/ERC20/metadata/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@solidstate/contracts/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@solidstate/contracts/interfaces/IERC20.sol\";\n\nimport { LibFeeStoreStorage } from \"./LibFeeStoreStorage.sol\";\nimport { ZeroValueNotAllowed, NotAllowed } from \"./../helpers/GenericErrors.sol\";\nimport { FeeStoreConfig, FeeConfigSyncHomeDTO, FeeConfigSyncHomeFees } from \"./../helpers/Structs.sol\";\n\n/// @title Fee Store Library\n/// @author Daniel <danieldegendev@gmail.com>\n/// @notice Functions to help with the fee store for other instances\nlibrary LibFeeStore {\n    using SafeERC20 for IERC20;\n    uint256 constant DENOMINATOR_RELATIVE = 10 ** 5; // bps denominator\n    uint256 constant DENOMINATOR_ABSOLUTE = 10 ** 4;\n\n    error ZeroFees();\n    error FeeNotExisting(bytes32 id);\n    error FeeExists(bytes32 id);\n\n    event FeeConfigAdded(bytes32 indexed id);\n    event FeeConfigUpdated(bytes32 indexed id);\n    event FeeConfigDeleted(bytes32 indexed id);\n    event FeeConfigMarkedAsDeleted(bytes32 indexed id);\n    event FeesPrepared(uint256 amount, FeeConfigSyncHomeDTO candidate);\n\n    /// Store a specific amount of fees in the store\n    /// @param _feeConfigId fee config id\n    /// @param _amount amount of tokens\n    function putFees(bytes32 _feeConfigId, uint256 _amount) internal {\n        if (_amount == 0) revert ZeroValueNotAllowed();\n        LibFeeStoreStorage.FeeStoreStorage storage s = LibFeeStoreStorage.feeStoreStorage();\n        FeeStoreConfig memory _config = s.feeConfigs[_feeConfigId];\n        if (_config.id == bytes32(\"\")) revert NotAllowed();\n        s.collectedFees[_config.id] += _amount;\n        s.collectedFeesTotal += _amount;\n    }\n\n    /// Prepares the fees collected on the store to be send to the home chain\n    /// @return _dto the dto that will be used on the home chain for receiving and process fees\n    /// @dev this method will also clean up every fee collected and sets it to 0\n    function prepareToSendFees() internal returns (FeeConfigSyncHomeDTO memory _dto) {\n        LibFeeStoreStorage.FeeStoreStorage storage s = LibFeeStoreStorage.feeStoreStorage();\n        if (s.collectedFeesTotal == 0) revert ZeroFees();\n\n        uint256 _feeIndex = 0;\n        uint256 _noOfExpectedFees = 0;\n\n        // get how many fees need to get sent\n        for (uint256 i = 0; i < s.feeConfigIds.length; ) {\n            if (s.collectedFees[s.feeConfigIds[i]] > 0) _noOfExpectedFees++;\n            unchecked {\n                i++;\n            }\n        }\n\n        // collect amounts and gathers configs\n        _dto.fees = new FeeConfigSyncHomeFees[](_noOfExpectedFees);\n        for (uint256 i = 0; i < s.feeConfigIds.length; ) {\n            bytes32 _id = s.feeConfigIds[i];\n            if (s.collectedFees[_id] > 0) {\n                uint256 _amount = s.collectedFees[_id];\n                s.collectedFees[_id] = 0;\n                if (s.feeConfigs[_id].deleted) deleteFee(_id);\n                _dto.totalFees += _amount;\n                _dto.fees[_feeIndex] = FeeConfigSyncHomeFees({ id: _id, amount: _amount });\n                unchecked {\n                    _feeIndex++;\n                }\n            }\n            unchecked {\n                i++;\n            }\n        }\n        s.collectedFeesTotal = 0;\n        emit FeesPrepared(_dto.totalFees, _dto);\n    }\n\n    /// Removes a fee from the store\n    /// @param _id fee id\n    /// @dev if a fee is still in use, it will be marked as deleted. Once fees get moved to home chain, it will be deleted properly\n    function deleteFee(bytes32 _id) internal {\n        LibFeeStoreStorage.FeeStoreStorage storage s = LibFeeStoreStorage.feeStoreStorage();\n        if (s.feeConfigs[_id].id == bytes32(0)) revert FeeNotExisting(_id);\n        if (s.collectedFees[_id] > 0) {\n            s.feeConfigs[_id].deleted = true;\n            emit FeeConfigMarkedAsDeleted(_id);\n        } else {\n            delete s.collectedFees[_id];\n            delete s.feeConfigs[_id];\n            for (uint256 i = 0; i < s.feeConfigIds.length; ) {\n                if (s.feeConfigIds[i] == _id) {\n                    s.feeConfigIds[i] = s.feeConfigIds[s.feeConfigIds.length - 1];\n                    break;\n                }\n                unchecked {\n                    i++;\n                }\n            }\n            s.feeConfigIds.pop();\n            emit FeeConfigDeleted(_id);\n        }\n    }\n\n    /// Adds a fee to the store\n    /// @param _id fee id\n    /// @param _fee fee value\n    /// @param _target the target address\n    function addFee(bytes32 _id, uint256 _fee, address _target) internal {\n        LibFeeStoreStorage.FeeStoreStorage storage s = LibFeeStoreStorage.feeStoreStorage();\n        if (s.feeConfigs[_id].id != bytes32(0)) revert FeeExists(_id);\n        s.feeConfigs[_id] = FeeStoreConfig({ id: _id, fee: _fee, target: _target, deleted: false });\n        s.feeConfigIds.push(_id);\n        emit FeeConfigAdded(_id);\n    }\n\n    /// Updates a fee on the store\n    /// @param _id fee id\n    /// @param _fee fee value\n    /// @param _target the target address\n    function updateFee(bytes32 _id, uint256 _fee, address _target) internal {\n        LibFeeStoreStorage.FeeStoreStorage storage s = LibFeeStoreStorage.feeStoreStorage();\n        if (s.feeConfigs[_id].id == bytes32(0)) revert FeeNotExisting(_id);\n        s.feeConfigs[_id] = FeeStoreConfig({ id: _id, fee: _fee, target: _target, deleted: false });\n        emit FeeConfigUpdated(_id);\n    }\n\n    /// viewables\n\n    /// Calculates the relative fee based on the inserted amount\n    /// @param _feeConfigId fee config id\n    /// @param _asset address of the token\n    /// @param _amount amount that fees are based on\n    /// @return _amountNet amount excluding fee\n    /// @return _fee amount of fee\n    /// @return _feePoints fee value that is applied\n    function calcFeesRelative(\n        bytes32 _feeConfigId,\n        address _asset,\n        uint256 _amount\n    ) internal view returns (uint256 _amountNet, uint256 _fee, uint256 _feePoints) {\n        return calcFees(_feeConfigId, _asset, _amount, false);\n    }\n\n    /// Calculates the absolute fee based on the inserted amount\n    /// @param _feeConfigId fee config id\n    /// @param _asset address of the token\n    /// @param _amount amount that fees are based on\n    /// @return _amountNet amount excluding fee\n    /// @return _fee amount of fee\n    /// @return _feePoints fee value that is applied\n    function calcFeesAbsolute(\n        bytes32 _feeConfigId,\n        address _asset,\n        uint256 _amount\n    ) internal view returns (uint256 _amountNet, uint256 _fee, uint256 _feePoints) {\n        return calcFees(_feeConfigId, _asset, _amount, true);\n    }\n\n    /// Calculates the relative or absolute fees based on the inserted amount\n    /// @param _feeConfigId fee config id\n    /// @param _asset address of the token\n    /// @param _amount amount that fees are based on\n    /// @param _absolute whether a calculation is relative or absolute\n    /// @return _amountNet amount excluding fee\n    /// @return _fee amount of fee\n    /// @return _feePoints fee value that is applied\n    function calcFees(\n        bytes32 _feeConfigId,\n        address _asset,\n        uint256 _amount,\n        bool _absolute\n    ) internal view returns (uint256 _amountNet, uint256 _fee, uint256 _feePoints) {\n        if (_amount == 0) revert ZeroValueNotAllowed();\n        LibFeeStoreStorage.FeeStoreStorage storage s = LibFeeStoreStorage.feeStoreStorage();\n        FeeStoreConfig memory _config = s.feeConfigs[_feeConfigId];\n        if (_config.id == bytes32(\"\")) return (_amount, 0, 0);\n        _feePoints = _config.fee;\n        _fee = _absolute\n            ? ((_feePoints * (10 ** IERC20Metadata(_asset).decimals())) / DENOMINATOR_ABSOLUTE)\n            : ((_amount * _feePoints) / DENOMINATOR_RELATIVE);\n        _amountNet = _amount - _fee;\n    }\n\n    function getOperator() internal view returns (address _operator) {\n        LibFeeStoreStorage.FeeStoreStorage storage s = LibFeeStoreStorage.feeStoreStorage();\n        _operator = s.operator;\n    }\n\n    function setOperator(address _operator) internal {\n        LibFeeStoreStorage.FeeStoreStorage storage s = LibFeeStoreStorage.feeStoreStorage();\n        s.operator = _operator;\n    }\n\n    function getIntermediateAsset() internal view returns (address _intermediateAsset) {\n        LibFeeStoreStorage.FeeStoreStorage storage s = LibFeeStoreStorage.feeStoreStorage();\n        _intermediateAsset = s.intermediateAsset;\n    }\n\n    function setIntermediateAsset(address _intermediateAsset) internal {\n        LibFeeStoreStorage.FeeStoreStorage storage s = LibFeeStoreStorage.feeStoreStorage();\n        s.intermediateAsset = _intermediateAsset;\n    }\n}\n"
    },
    "contracts/diamond/libraries/LibFeeStoreStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.19;\n\nimport { FeeStoreConfig } from \"./../helpers/Structs.sol\";\n\nlibrary LibFeeStoreStorage {\n    bytes32 constant FEE_STORE_STORAGE_POSITION = keccak256(\"degenx.fee-store.storage.v1\");\n\n    struct FeeStoreStorage {\n        // feeConfigId => FeeStoreConfig\n        mapping(bytes32 => FeeStoreConfig) feeConfigs;\n        // feeConfigId => amount of fees collected\n        mapping(bytes32 => uint256) collectedFees;\n        // represents a sum of each amount in collectedFees\n        uint256 collectedFeesTotal;\n        bytes32[] feeConfigIds;\n        address operator;\n        address intermediateAsset;\n    }\n\n    function feeStoreStorage() internal pure returns (FeeStoreStorage storage fss) {\n        bytes32 position = FEE_STORE_STORAGE_POSITION;\n        assembly {\n            fss.slot := position\n        }\n    }\n}\n"
    },
    "contracts/diamond/upgradeInitializers/DiamondInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\nimport { IERC165 } from \"../interfaces/IERC165.sol\";\nimport { LibAccessControlEnumerable } from \"./../libraries/LibAccessControlEnumerable.sol\";\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\nimport { Constants } from \"./../helpers/Constants.sol\";\n\n/// @custom:version 1.0.0\ncontract DiamondInit {\n    function init() external {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\n        ds.supportedInterfaces[type(IERC173).interfaceId] = true;\n\n        // set and grant admin roles\n\n        LibAccessControlEnumerable.grantRole(Constants.DEFAULT_ADMIN_ROLE, msg.sender);\n\n        LibAccessControlEnumerable.setRoleAdmin(Constants.ADMIN_ROLE, Constants.DEFAULT_ADMIN_ROLE);\n        LibAccessControlEnumerable.setRoleAdmin(Constants.FEE_DISTRIBUTOR_PUSH_ROLE, Constants.ADMIN_ROLE);\n        LibAccessControlEnumerable.setRoleAdmin(Constants.FEE_DISTRIBUTOR_MANAGER, Constants.ADMIN_ROLE);\n        LibAccessControlEnumerable.setRoleAdmin(Constants.FEE_STORE_MANAGER_ROLE, Constants.ADMIN_ROLE);\n        LibAccessControlEnumerable.setRoleAdmin(Constants.FEE_MANAGER_ROLE, Constants.ADMIN_ROLE);\n        LibAccessControlEnumerable.setRoleAdmin(Constants.DEPLOYER_ROLE, Constants.ADMIN_ROLE);\n        LibAccessControlEnumerable.setRoleAdmin(Constants.MINTER_ROLE, Constants.ADMIN_ROLE);\n        LibAccessControlEnumerable.setRoleAdmin(Constants.BURNER_ROLE, Constants.ADMIN_ROLE);\n        LibAccessControlEnumerable.grantRole(Constants.FEE_DISTRIBUTOR_PUSH_ROLE, msg.sender);\n        LibAccessControlEnumerable.grantRole(Constants.FEE_DISTRIBUTOR_MANAGER, msg.sender);\n        LibAccessControlEnumerable.grantRole(Constants.FEE_STORE_MANAGER_ROLE, msg.sender);\n        LibAccessControlEnumerable.grantRole(Constants.FEE_MANAGER_ROLE, msg.sender);\n        LibAccessControlEnumerable.grantRole(Constants.DEPLOYER_ROLE, msg.sender);\n        LibAccessControlEnumerable.grantRole(Constants.MINTER_ROLE, msg.sender);\n        LibAccessControlEnumerable.grantRole(Constants.BURNER_ROLE, msg.sender);\n        LibAccessControlEnumerable.grantRole(Constants.ADMIN_ROLE, msg.sender);\n    }\n}\n"
    },
    "contracts/interfaces/IFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.19;\n\ninterface IFactory {\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n}\n"
    },
    "contracts/interfaces/IRouter02.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.19;\n\ninterface IRouter02 {\n    function factory() external returns (address);\n\n    function WETH() external returns (address);\n\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n}\n"
    },
    "contracts/LaunchControl.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { IERC20Facet } from \"./diamond/interfaces/IERC20Facet.sol\";\nimport { Constants } from \"./diamond/helpers/Constants.sol\";\nimport { IRouter02 } from \"./interfaces/IRouter02.sol\";\nimport { IFactory } from \"./interfaces/IFactory.sol\";\n\n/// @custom:version 1.0.0\ncontract LaunchControl is Ownable {\n    using Address for address payable;\n\n    bool public launched = false;\n    bool public liquidity = false;\n    uint256 public startPoolWithToken = 0;\n    uint256 public startPoolWithNative = 0;\n    address public router;\n    address public lp;\n    address public lpTokenReceiver;\n    address public token; // diamond address is token address\n\n    /// admin\n\n    function recover(address _asset) external onlyOwner {\n        uint256 _balanceA = address(this).balance;\n        if (_balanceA > 0) payable(owner()).sendValue(_balanceA);\n        uint256 _balanceB = IERC20(_asset).balanceOf(address(this));\n        if (_balanceB > 0) IERC20(_asset).transfer(owner(), _balanceB);\n    }\n\n    function setRouter(address _router) external onlyOwner {\n        router = _router;\n    }\n\n    function setToken(address _token) external onlyOwner {\n        if (router == address(0)) revert(\"missing router\");\n        token = _token;\n        lp = IFactory(IRouter02(router).factory()).createPair(token, IRouter02(router).WETH());\n        IERC20Facet(token).addLP(lp);\n    }\n\n    function setStartPoolWithToken(uint256 _amount) external onlyOwner {\n        startPoolWithToken = _amount;\n    }\n\n    function setStartPoolWithNative(uint256 _amount) external onlyOwner {\n        startPoolWithNative = _amount;\n    }\n\n    function setLpTokenReceiver(address _account) external onlyOwner {\n        lpTokenReceiver = _account;\n    }\n\n    function addLiquidity() external onlyOwner {\n        if (token == address(0)) revert(\"set token first\");\n        if (lpTokenReceiver == address(0)) revert(\"lp token receiver not set\");\n\n        uint256 _balanceA = address(this).balance;\n        if (_balanceA == 0 || startPoolWithNative == 0 || startPoolWithNative > _balanceA) revert(\"not enough native\");\n\n        uint256 _balanceB = IERC20(token).balanceOf(address(this));\n        if (_balanceB == 0 || startPoolWithToken == 0 || startPoolWithToken > _balanceB) revert(\"not enough token\");\n\n        IERC20Facet(token).excludeAccountFromTax(address(this));\n        IERC20(token).approve(router, startPoolWithToken);\n        (uint256 amountToken, uint256 amountETH, ) = IRouter02(router).addLiquidityETH{ value: startPoolWithNative }(\n            token,\n            startPoolWithToken,\n            startPoolWithToken,\n            startPoolWithNative,\n            lpTokenReceiver,\n            block.timestamp + 60\n        );\n        IERC20Facet(token).disable();\n        IERC20Facet(token).includeAccountForTax(address(this));\n\n        if (amountToken != startPoolWithToken) revert(\"wrong amount of token\");\n        if (amountETH != startPoolWithNative) revert(\"wrong amount of native\");\n\n        liquidity = true;\n    }\n\n    function startTrading() external onlyOwner {\n        if (token == address(0)) revert(\"no token\");\n        if (!liquidity) revert(\"no liquidity\");\n        IERC20Facet(token).enable();\n        launched = true;\n    }\n\n    /// receiver\n    receive() external payable {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 99999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}