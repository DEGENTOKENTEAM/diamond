{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n        _transferOwnership(sender);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "celer/contracts/interfaces/IBridge.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\ninterface IBridge {\n    function send(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        uint64 _dstChainId,\n        uint64 _nonce,\n        uint32 _maxSlippage\n    ) external;\n\n    function sendNative(\n        address _receiver,\n        uint256 _amount,\n        uint64 _dstChainId,\n        uint64 _nonce,\n        uint32 _maxSlippage\n    ) external payable;\n\n    function relay(\n        bytes calldata _relayRequest,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external;\n\n    function transfers(bytes32 transferId) external view returns (bool);\n\n    function withdraws(bytes32 withdrawId) external view returns (bool);\n\n    function withdraw(\n        bytes calldata _wdmsg,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external;\n\n    /**\n     * @notice Verifies that a message is signed by a quorum among the signers.\n     * @param _msg signed message\n     * @param _sigs list of signatures sorted by signer addresses in ascending order\n     * @param _signers sorted list of current signers\n     * @param _powers powers of current signers\n     */\n    function verifySigs(\n        bytes memory _msg,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external view;\n}\n"
    },
    "celer/contracts/interfaces/IDelayedTransfer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.9;\n\ninterface IDelayedTransfer {\n    struct delayedTransfer {\n        address receiver;\n        address token;\n        uint256 amount;\n        uint256 timestamp;\n    }\n\n    function delayedTransfers(bytes32 transferId) external view returns (delayedTransfer memory);\n}\n"
    },
    "celer/contracts/interfaces/IOriginalTokenVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\ninterface IOriginalTokenVault {\n    /**\n     * @notice Lock original tokens to trigger mint at a remote chain's PeggedTokenBridge\n     * @param _token local token address\n     * @param _amount locked token amount\n     * @param _mintChainId destination chainId to mint tokens\n     * @param _mintAccount destination account to receive minted tokens\n     * @param _nonce user input to guarantee unique depositId\n     */\n    function deposit(\n        address _token,\n        uint256 _amount,\n        uint64 _mintChainId,\n        address _mintAccount,\n        uint64 _nonce\n    ) external;\n\n    /**\n     * @notice Lock native token as original token to trigger mint at a remote chain's PeggedTokenBridge\n     * @param _amount locked token amount\n     * @param _mintChainId destination chainId to mint tokens\n     * @param _mintAccount destination account to receive minted tokens\n     * @param _nonce user input to guarantee unique depositId\n     */\n    function depositNative(\n        uint256 _amount,\n        uint64 _mintChainId,\n        address _mintAccount,\n        uint64 _nonce\n    ) external payable;\n\n    /**\n     * @notice Withdraw locked original tokens triggered by a burn at a remote chain's PeggedTokenBridge.\n     * @param _request The serialized Withdraw protobuf.\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\n     * +2/3 of the bridge's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function withdraw(\n        bytes calldata _request,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external;\n\n    function records(bytes32 recordId) external view returns (bool);\n}\n"
    },
    "celer/contracts/interfaces/IOriginalTokenVaultV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\ninterface IOriginalTokenVaultV2 {\n    /**\n     * @notice Lock original tokens to trigger mint at a remote chain's PeggedTokenBridge\n     * @param _token local token address\n     * @param _amount locked token amount\n     * @param _mintChainId destination chainId to mint tokens\n     * @param _mintAccount destination account to receive minted tokens\n     * @param _nonce user input to guarantee unique depositId\n     */\n    function deposit(\n        address _token,\n        uint256 _amount,\n        uint64 _mintChainId,\n        address _mintAccount,\n        uint64 _nonce\n    ) external returns (bytes32);\n\n    /**\n     * @notice Lock native token as original token to trigger mint at a remote chain's PeggedTokenBridge\n     * @param _amount locked token amount\n     * @param _mintChainId destination chainId to mint tokens\n     * @param _mintAccount destination account to receive minted tokens\n     * @param _nonce user input to guarantee unique depositId\n     */\n    function depositNative(\n        uint256 _amount,\n        uint64 _mintChainId,\n        address _mintAccount,\n        uint64 _nonce\n    ) external payable returns (bytes32);\n\n    /**\n     * @notice Withdraw locked original tokens triggered by a burn at a remote chain's PeggedTokenBridge.\n     * @param _request The serialized Withdraw protobuf.\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\n     * +2/3 of the bridge's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function withdraw(\n        bytes calldata _request,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external returns (bytes32);\n\n    function records(bytes32 recordId) external view returns (bool);\n}\n"
    },
    "celer/contracts/interfaces/IPeggedTokenBridge.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\ninterface IPeggedTokenBridge {\n    /**\n     * @notice Burn tokens to trigger withdrawal at a remote chain's OriginalTokenVault\n     * @param _token local token address\n     * @param _amount locked token amount\n     * @param _withdrawAccount account who withdraw original tokens on the remote chain\n     * @param _nonce user input to guarantee unique depositId\n     */\n    function burn(\n        address _token,\n        uint256 _amount,\n        address _withdrawAccount,\n        uint64 _nonce\n    ) external;\n\n    /**\n     * @notice Mint tokens triggered by deposit at a remote chain's OriginalTokenVault.\n     * @param _request The serialized Mint protobuf.\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\n     * +2/3 of the sigsVerifier's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function mint(\n        bytes calldata _request,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external;\n\n    function records(bytes32 recordId) external view returns (bool);\n}\n"
    },
    "celer/contracts/interfaces/IPeggedTokenBridgeV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\ninterface IPeggedTokenBridgeV2 {\n    /**\n     * @notice Burn pegged tokens to trigger a cross-chain withdrawal of the original tokens at a remote chain's\n     * OriginalTokenVault, or mint at another remote chain\n     * @param _token The pegged token address.\n     * @param _amount The amount to burn.\n     * @param _toChainId If zero, withdraw from original vault; otherwise, the remote chain to mint tokens.\n     * @param _toAccount The account to receive tokens on the remote chain\n     * @param _nonce A number to guarantee unique depositId. Can be timestamp in practice.\n     */\n    function burn(\n        address _token,\n        uint256 _amount,\n        uint64 _toChainId,\n        address _toAccount,\n        uint64 _nonce\n    ) external returns (bytes32);\n\n    // same with `burn` above, use openzeppelin ERC20Burnable interface\n    function burnFrom(\n        address _token,\n        uint256 _amount,\n        uint64 _toChainId,\n        address _toAccount,\n        uint64 _nonce\n    ) external returns (bytes32);\n\n    /**\n     * @notice Mint tokens triggered by deposit at a remote chain's OriginalTokenVault.\n     * @param _request The serialized Mint protobuf.\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\n     * +2/3 of the sigsVerifier's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function mint(\n        bytes calldata _request,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external returns (bytes32);\n\n    function records(bytes32 recordId) external view returns (bool);\n}\n"
    },
    "celer/contracts/interfaces/ISigsVerifier.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\ninterface ISigsVerifier {\n    /**\n     * @notice Verifies that a message is signed by a quorum among the signers.\n     * @param _msg signed message\n     * @param _sigs list of signatures sorted by signer addresses in ascending order\n     * @param _signers sorted list of current signers\n     * @param _powers powers of current signers\n     */\n    function verifySigs(\n        bytes memory _msg,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external view;\n}\n"
    },
    "celer/contracts/libraries/Utils.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\nlibrary Utils {\n    // https://ethereum.stackexchange.com/a/83577\n    // https://github.com/Uniswap/v3-periphery/blob/v1.0.0/contracts/base/Multicall.sol\n    function getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"Transaction reverted silently\";\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n}\n"
    },
    "celer/contracts/message/framework/MessageApp.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\nimport \"./MessageSenderApp.sol\";\nimport \"./MessageReceiverApp.sol\";\n\nabstract contract MessageApp is MessageSenderApp, MessageReceiverApp {\n    constructor(address _messageBus) {\n        messageBus = _messageBus;\n    }\n}\n"
    },
    "celer/contracts/message/framework/MessageBusAddress.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\nabstract contract MessageBusAddress {\n    address public messageBus;\n}\n"
    },
    "celer/contracts/message/framework/MessageReceiverApp.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\nimport \"../interfaces/IMessageReceiverApp.sol\";\nimport \"../libraries/MsgDataTypes.sol\";\nimport \"./MessageBusAddress.sol\";\n\nabstract contract MessageReceiverApp is IMessageReceiverApp, MessageBusAddress {\n    modifier onlyMessageBus() {\n        require(msg.sender == messageBus, \"caller is not message bus\");\n        _;\n    }\n\n    // Add abort prefix in the reason string for require or revert.\n    // This will abort (revert) the message execution without markig it as failed state,\n    // making it possible to retry later.\n    function _abortReason(string memory reason) internal pure returns (string memory) {\n        return MsgDataTypes.abortReason(reason);\n    }\n\n    /**\n     * @notice Called by MessageBus to execute a message\n     * @param _sender The address of the source app contract\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessage(\n        address _sender,\n        uint64 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external payable virtual override onlyMessageBus returns (ExecutionStatus) {}\n\n    // execute message from non-evm chain with bytes for sender address,\n    // otherwise same as above.\n    function executeMessage(\n        bytes calldata _sender,\n        uint64 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external payable virtual override onlyMessageBus returns (ExecutionStatus) {}\n\n    /**\n     * @notice Called by MessageBus to execute a message with an associated token transfer.\n     * The contract is guaranteed to have received the right amount of tokens before this function is called.\n     * @param _sender The address of the source app contract\n     * @param _token The address of the token that comes out of the bridge\n     * @param _amount The amount of tokens received at this contract through the cross-chain bridge.\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessageWithTransfer(\n        address _sender,\n        address _token,\n        uint256 _amount,\n        uint64 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external payable virtual override onlyMessageBus returns (ExecutionStatus) {}\n\n    /**\n     * @notice Only called by MessageBus if\n     *         1. executeMessageWithTransfer reverts, or\n     *         2. executeMessageWithTransfer returns ExecutionStatus.Fail\n     * The contract is guaranteed to have received the right amount of tokens before this function is called.\n     * @param _sender The address of the source app contract\n     * @param _token The address of the token that comes out of the bridge\n     * @param _amount The amount of tokens received at this contract through the cross-chain bridge.\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessageWithTransferFallback(\n        address _sender,\n        address _token,\n        uint256 _amount,\n        uint64 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external payable virtual override onlyMessageBus returns (ExecutionStatus) {}\n\n    /**\n     * @notice Called by MessageBus to process refund of the original transfer from this contract.\n     * The contract is guaranteed to have received the refund before this function is called.\n     * @param _token The token address of the original transfer\n     * @param _amount The amount of the original transfer\n     * @param _message The same message associated with the original transfer\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessageWithTransferRefund(\n        address _token,\n        uint256 _amount,\n        bytes calldata _message,\n        address _executor\n    ) external payable virtual override onlyMessageBus returns (ExecutionStatus) {}\n}\n"
    },
    "celer/contracts/message/framework/MessageSenderApp.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../libraries/MsgDataTypes.sol\";\nimport \"../libraries/MessageSenderLib.sol\";\nimport \"../messagebus/MessageBus.sol\";\nimport \"./MessageBusAddress.sol\";\n\nabstract contract MessageSenderApp is MessageBusAddress {\n    using SafeERC20 for IERC20;\n\n    // ============== Utility functions called by apps ==============\n\n    /**\n     * @notice Sends a message to a contract on another chain.\n     * Sender needs to make sure the uniqueness of the message Id, which is computed as\n     * hash(type.MessageOnly, sender, receiver, srcChainId, srcTxHash, dstChainId, message).\n     * If messages with the same Id are sent, only one of them will succeed at dst chain.\n     * @param _receiver The address of the destination app contract.\n     * @param _dstChainId The destination chain ID.\n     * @param _message Arbitrary message bytes to be decoded by the destination app contract.\n     * @param _fee The fee amount to pay to MessageBus.\n     */\n    function sendMessage(\n        address _receiver,\n        uint64 _dstChainId,\n        bytes memory _message,\n        uint256 _fee\n    ) internal {\n        MessageSenderLib.sendMessage(_receiver, _dstChainId, _message, messageBus, _fee);\n    }\n\n    // Send message to non-evm chain with bytes for receiver address,\n    // otherwise same as above.\n    function sendMessage(\n        bytes calldata _receiver,\n        uint64 _dstChainId,\n        bytes memory _message,\n        uint256 _fee\n    ) internal {\n        MessageSenderLib.sendMessage(_receiver, _dstChainId, _message, messageBus, _fee);\n    }\n\n    /**\n     * @notice Sends a message associated with a transfer to a contract on another chain.\n     * @param _receiver The address of the destination app contract.\n     * @param _token The address of the token to be sent.\n     * @param _amount The amount of tokens to be sent.\n     * @param _dstChainId The destination chain ID.\n     * @param _nonce A number input to guarantee uniqueness of transferId. Can be timestamp in practice.\n     * @param _maxSlippage The max slippage accepted, given as percentage in point (pip). Eg. 5000 means 0.5%.\n     *        Must be greater than minimalMaxSlippage. Receiver is guaranteed to receive at least\n     *        (100% - max slippage percentage) * amount or the transfer can be refunded.\n     *        Only applicable to the {MsgDataTypes.BridgeSendType.Liquidity}.\n     * @param _message Arbitrary message bytes to be decoded by the destination app contract.\n     *        If message is empty, only the token transfer will be sent\n     * @param _bridgeSendType One of the {BridgeSendType} enum.\n     * @param _fee The fee amount to pay to MessageBus.\n     * @return The transfer ID.\n     */\n    function sendMessageWithTransfer(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        uint64 _dstChainId,\n        uint64 _nonce,\n        uint32 _maxSlippage,\n        bytes memory _message,\n        MsgDataTypes.BridgeSendType _bridgeSendType,\n        uint256 _fee\n    ) internal returns (bytes32) {\n        return\n            MessageSenderLib.sendMessageWithTransfer(\n                _receiver,\n                _token,\n                _amount,\n                _dstChainId,\n                _nonce,\n                _maxSlippage,\n                _message,\n                _bridgeSendType,\n                messageBus,\n                _fee\n            );\n    }\n\n    /**\n     * @notice Sends a token transfer via a bridge.\n     * @dev sendMessageWithTransfer with empty message\n     * @param _receiver The address of the destination app contract.\n     * @param _token The address of the token to be sent.\n     * @param _amount The amount of tokens to be sent.\n     * @param _dstChainId The destination chain ID.\n     * @param _nonce A number input to guarantee uniqueness of transferId. Can be timestamp in practice.\n     * @param _maxSlippage The max slippage accepted, given as percentage in point (pip). Eg. 5000 means 0.5%.\n     *        Must be greater than minimalMaxSlippage. Receiver is guaranteed to receive at least\n     *        (100% - max slippage percentage) * amount or the transfer can be refunded.\n     *        Only applicable to the {MsgDataTypes.BridgeSendType.Liquidity}.\n     * @param _bridgeSendType One of the {BridgeSendType} enum.\n     */\n    function sendTokenTransfer(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        uint64 _dstChainId,\n        uint64 _nonce,\n        uint32 _maxSlippage,\n        MsgDataTypes.BridgeSendType _bridgeSendType\n    ) internal returns (bytes32) {\n        return\n            MessageSenderLib.sendMessageWithTransfer(\n                _receiver,\n                _token,\n                _amount,\n                _dstChainId,\n                _nonce,\n                _maxSlippage,\n                \"\", // empty message, which will not trigger sendMessage\n                _bridgeSendType,\n                messageBus,\n                0\n            );\n    }\n}\n"
    },
    "celer/contracts/message/interfaces/IMessageBus.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\nimport \"../libraries/MsgDataTypes.sol\";\n\ninterface IMessageBus {\n    /**\n     * @notice Send a message to a contract on another chain.\n     * Sender needs to make sure the uniqueness of the message Id, which is computed as\n     * hash(type.MessageOnly, sender, receiver, srcChainId, srcTxHash, dstChainId, message).\n     * If messages with the same Id are sent, only one of them will succeed at dst chain..\n     * A fee is charged in the native gas token.\n     * @param _receiver The address of the destination app contract.\n     * @param _dstChainId The destination chain ID.\n     * @param _message Arbitrary message bytes to be decoded by the destination app contract.\n     */\n    function sendMessage(\n        address _receiver,\n        uint256 _dstChainId,\n        bytes calldata _message\n    ) external payable;\n\n    // same as above, except that receiver is an non-evm chain address,\n    function sendMessage(\n        bytes calldata _receiver,\n        uint256 _dstChainId,\n        bytes calldata _message\n    ) external payable;\n\n    /**\n     * @notice Send a message associated with a token transfer to a contract on another chain.\n     * If messages with the same srcTransferId are sent, only one of them will succeed at dst chain..\n     * A fee is charged in the native token.\n     * @param _receiver The address of the destination app contract.\n     * @param _dstChainId The destination chain ID.\n     * @param _srcBridge The bridge contract to send the transfer with.\n     * @param _srcTransferId The transfer ID.\n     * @param _dstChainId The destination chain ID.\n     * @param _message Arbitrary message bytes to be decoded by the destination app contract.\n     */\n    function sendMessageWithTransfer(\n        address _receiver,\n        uint256 _dstChainId,\n        address _srcBridge,\n        bytes32 _srcTransferId,\n        bytes calldata _message\n    ) external payable;\n\n    /**\n     * @notice Execute a message not associated with a transfer.\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\n     * +2/3 of the sigsVerifier's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function executeMessage(\n        bytes calldata _message,\n        MsgDataTypes.RouteInfo calldata _route,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external payable;\n\n    /**\n     * @notice Execute a message with a successful transfer.\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _transfer The transfer info.\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\n     * +2/3 of the sigsVerifier's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function executeMessageWithTransfer(\n        bytes calldata _message,\n        MsgDataTypes.TransferInfo calldata _transfer,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external payable;\n\n    /**\n     * @notice Execute a message with a refunded transfer.\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _transfer The transfer info.\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\n     * +2/3 of the sigsVerifier's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function executeMessageWithTransferRefund(\n        bytes calldata _message, // the same message associated with the original transfer\n        MsgDataTypes.TransferInfo calldata _transfer,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external payable;\n\n    /**\n     * @notice Withdraws message fee in the form of native gas token.\n     * @param _account The address receiving the fee.\n     * @param _cumulativeFee The cumulative fee credited to the account. Tracked by SGN.\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A withdrawal must be\n     * signed-off by +2/3 of the sigsVerifier's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function withdrawFee(\n        address _account,\n        uint256 _cumulativeFee,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external;\n\n    /**\n     * @notice Calculates the required fee for the message.\n     * @param _message Arbitrary message bytes to be decoded by the destination app contract.\n     @ @return The required fee.\n     */\n    function calcFee(bytes calldata _message) external view returns (uint256);\n\n    function liquidityBridge() external view returns (address);\n\n    function pegBridge() external view returns (address);\n\n    function pegBridgeV2() external view returns (address);\n\n    function pegVault() external view returns (address);\n\n    function pegVaultV2() external view returns (address);\n}\n"
    },
    "celer/contracts/message/interfaces/IMessageReceiverApp.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\ninterface IMessageReceiverApp {\n    enum ExecutionStatus {\n        Fail, // execution failed, finalized\n        Success, // execution succeeded, finalized\n        Retry // execution rejected, can retry later\n    }\n\n    /**\n     * @notice Called by MessageBus to execute a message\n     * @param _sender The address of the source app contract\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessage(\n        address _sender,\n        uint64 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external payable returns (ExecutionStatus);\n\n    // same as above, except that sender is an non-evm chain address,\n    // otherwise same as above.\n    function executeMessage(\n        bytes calldata _sender,\n        uint64 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external payable returns (ExecutionStatus);\n\n    /**\n     * @notice Called by MessageBus to execute a message with an associated token transfer.\n     * The contract is guaranteed to have received the right amount of tokens before this function is called.\n     * @param _sender The address of the source app contract\n     * @param _token The address of the token that comes out of the bridge\n     * @param _amount The amount of tokens received at this contract through the cross-chain bridge.\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessageWithTransfer(\n        address _sender,\n        address _token,\n        uint256 _amount,\n        uint64 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external payable returns (ExecutionStatus);\n\n    /**\n     * @notice Only called by MessageBus if\n     *         1. executeMessageWithTransfer reverts, or\n     *         2. executeMessageWithTransfer returns ExecutionStatus.Fail\n     * The contract is guaranteed to have received the right amount of tokens before this function is called.\n     * @param _sender The address of the source app contract\n     * @param _token The address of the token that comes out of the bridge\n     * @param _amount The amount of tokens received at this contract through the cross-chain bridge.\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessageWithTransferFallback(\n        address _sender,\n        address _token,\n        uint256 _amount,\n        uint64 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external payable returns (ExecutionStatus);\n\n    /**\n     * @notice Called by MessageBus to process refund of the original transfer from this contract.\n     * The contract is guaranteed to have received the refund before this function is called.\n     * @param _token The token address of the original transfer\n     * @param _amount The amount of the original transfer\n     * @param _message The same message associated with the original transfer\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessageWithTransferRefund(\n        address _token,\n        uint256 _amount,\n        bytes calldata _message,\n        address _executor\n    ) external payable returns (ExecutionStatus);\n}\n"
    },
    "celer/contracts/message/libraries/MessageSenderLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../../interfaces/IBridge.sol\";\nimport \"../../interfaces/IOriginalTokenVault.sol\";\nimport \"../../interfaces/IOriginalTokenVaultV2.sol\";\nimport \"../../interfaces/IPeggedTokenBridge.sol\";\nimport \"../../interfaces/IPeggedTokenBridgeV2.sol\";\nimport \"../interfaces/IMessageBus.sol\";\nimport \"./MsgDataTypes.sol\";\n\nlibrary MessageSenderLib {\n    using SafeERC20 for IERC20;\n\n    // ============== Internal library functions called by apps ==============\n\n    /**\n     * @notice Sends a message to an app on another chain via MessageBus without an associated transfer.\n     * @param _receiver The address of the destination app contract.\n     * @param _dstChainId The destination chain ID.\n     * @param _message Arbitrary message bytes to be decoded by the destination app contract.\n     * @param _messageBus The address of the MessageBus on this chain.\n     * @param _fee The fee amount to pay to MessageBus.\n     */\n    function sendMessage(\n        address _receiver,\n        uint64 _dstChainId,\n        bytes memory _message,\n        address _messageBus,\n        uint256 _fee\n    ) internal {\n        IMessageBus(_messageBus).sendMessage{value: _fee}(_receiver, _dstChainId, _message);\n    }\n\n    // Send message to non-evm chain with bytes for receiver address,\n    // otherwise same as above.\n    function sendMessage(\n        bytes calldata _receiver,\n        uint64 _dstChainId,\n        bytes memory _message,\n        address _messageBus,\n        uint256 _fee\n    ) internal {\n        IMessageBus(_messageBus).sendMessage{value: _fee}(_receiver, _dstChainId, _message);\n    }\n\n    /**\n     * @notice Sends a message to an app on another chain via MessageBus with an associated transfer.\n     * @param _receiver The address of the destination app contract.\n     * @param _token The address of the token to be sent.\n     * @param _amount The amount of tokens to be sent.\n     * @param _dstChainId The destination chain ID.\n     * @param _nonce A number input to guarantee uniqueness of transferId. Can be timestamp in practice.\n     * @param _maxSlippage The max slippage accepted, given as percentage in point (pip). Eg. 5000 means 0.5%.\n     * Must be greater than minimalMaxSlippage. Receiver is guaranteed to receive at least (100% - max slippage percentage) * amount or the\n     * transfer can be refunded. Only applicable to the {MsgDataTypes.BridgeSendType.Liquidity}.\n     * @param _message Arbitrary message bytes to be decoded by the destination app contract.\n     * @param _bridgeSendType One of the {MsgDataTypes.BridgeSendType} enum.\n     * @param _messageBus The address of the MessageBus on this chain.\n     * @param _fee The fee amount to pay to MessageBus.\n     * @return The transfer ID.\n     */\n    function sendMessageWithTransfer(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        uint64 _dstChainId,\n        uint64 _nonce,\n        uint32 _maxSlippage,\n        bytes memory _message,\n        MsgDataTypes.BridgeSendType _bridgeSendType,\n        address _messageBus,\n        uint256 _fee\n    ) internal returns (bytes32) {\n        (bytes32 transferId, address bridge) = sendTokenTransfer(\n            _receiver,\n            _token,\n            _amount,\n            _dstChainId,\n            _nonce,\n            _maxSlippage,\n            _bridgeSendType,\n            _messageBus\n        );\n        if (_message.length > 0) {\n            IMessageBus(_messageBus).sendMessageWithTransfer{value: _fee}(\n                _receiver,\n                _dstChainId,\n                bridge,\n                transferId,\n                _message\n            );\n        }\n        return transferId;\n    }\n\n    /**\n     * @notice Sends a token transfer via a bridge.\n     * @param _receiver The address of the destination app contract.\n     * @param _token The address of the token to be sent.\n     * @param _amount The amount of tokens to be sent.\n     * @param _dstChainId The destination chain ID.\n     * @param _nonce A number input to guarantee uniqueness of transferId. Can be timestamp in practice.\n     * @param _maxSlippage The max slippage accepted, given as percentage in point (pip). Eg. 5000 means 0.5%.\n     * Must be greater than minimalMaxSlippage. Receiver is guaranteed to receive at least (100% - max slippage percentage) * amount or the\n     * transfer can be refunded.\n     * @param _bridgeSendType One of the {MsgDataTypes.BridgeSendType} enum.\n     */\n    function sendTokenTransfer(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        uint64 _dstChainId,\n        uint64 _nonce,\n        uint32 _maxSlippage,\n        MsgDataTypes.BridgeSendType _bridgeSendType,\n        address _messageBus\n    ) internal returns (bytes32 transferId, address bridge) {\n        if (_bridgeSendType == MsgDataTypes.BridgeSendType.Liquidity) {\n            bridge = IMessageBus(_messageBus).liquidityBridge();\n            IERC20(_token).safeIncreaseAllowance(bridge, _amount);\n            IBridge(bridge).send(_receiver, _token, _amount, _dstChainId, _nonce, _maxSlippage);\n            transferId = computeLiqBridgeTransferId(_receiver, _token, _amount, _dstChainId, _nonce);\n        } else if (_bridgeSendType == MsgDataTypes.BridgeSendType.PegDeposit) {\n            bridge = IMessageBus(_messageBus).pegVault();\n            IERC20(_token).safeIncreaseAllowance(bridge, _amount);\n            IOriginalTokenVault(bridge).deposit(_token, _amount, _dstChainId, _receiver, _nonce);\n            transferId = computePegV1DepositId(_receiver, _token, _amount, _dstChainId, _nonce);\n        } else if (_bridgeSendType == MsgDataTypes.BridgeSendType.PegBurn) {\n            bridge = IMessageBus(_messageBus).pegBridge();\n            IERC20(_token).safeIncreaseAllowance(bridge, _amount);\n            IPeggedTokenBridge(bridge).burn(_token, _amount, _receiver, _nonce);\n            // handle cases where certain tokens do not spend allowance for role-based burn\n            IERC20(_token).safeApprove(bridge, 0);\n            transferId = computePegV1BurnId(_receiver, _token, _amount, _nonce);\n        } else if (_bridgeSendType == MsgDataTypes.BridgeSendType.PegV2Deposit) {\n            bridge = IMessageBus(_messageBus).pegVaultV2();\n            IERC20(_token).safeIncreaseAllowance(bridge, _amount);\n            transferId = IOriginalTokenVaultV2(bridge).deposit(_token, _amount, _dstChainId, _receiver, _nonce);\n        } else if (_bridgeSendType == MsgDataTypes.BridgeSendType.PegV2Burn) {\n            bridge = IMessageBus(_messageBus).pegBridgeV2();\n            IERC20(_token).safeIncreaseAllowance(bridge, _amount);\n            transferId = IPeggedTokenBridgeV2(bridge).burn(_token, _amount, _dstChainId, _receiver, _nonce);\n            // handle cases where certain tokens do not spend allowance for role-based burn\n            IERC20(_token).safeApprove(bridge, 0);\n        } else if (_bridgeSendType == MsgDataTypes.BridgeSendType.PegV2BurnFrom) {\n            bridge = IMessageBus(_messageBus).pegBridgeV2();\n            IERC20(_token).safeIncreaseAllowance(bridge, _amount);\n            transferId = IPeggedTokenBridgeV2(bridge).burnFrom(_token, _amount, _dstChainId, _receiver, _nonce);\n            // handle cases where certain tokens do not spend allowance for role-based burn\n            IERC20(_token).safeApprove(bridge, 0);\n        } else {\n            revert(\"bridge type not supported\");\n        }\n    }\n\n    function computeLiqBridgeTransferId(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        uint64 _dstChainId,\n        uint64 _nonce\n    ) internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(address(this), _receiver, _token, _amount, _dstChainId, _nonce, uint64(block.chainid))\n            );\n    }\n\n    function computePegV1DepositId(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        uint64 _dstChainId,\n        uint64 _nonce\n    ) internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(address(this), _token, _amount, _dstChainId, _receiver, _nonce, uint64(block.chainid))\n            );\n    }\n\n    function computePegV1BurnId(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        uint64 _nonce\n    ) internal view returns (bytes32) {\n        return keccak256(abi.encodePacked(address(this), _token, _amount, _receiver, _nonce, uint64(block.chainid)));\n    }\n}\n"
    },
    "celer/contracts/message/libraries/MsgDataTypes.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\nlibrary MsgDataTypes {\n    string constant ABORT_PREFIX = \"MSG::ABORT:\";\n\n    // Add abort prefix in the reason string for require or revert.\n    // This will abort (revert) the message execution without markig it as failed state,\n    // making it possible to retry later.\n    function abortReason(string memory reason) internal pure returns (string memory) {\n        return string.concat(MsgDataTypes.ABORT_PREFIX, reason);\n    }\n\n    // bridge operation type at the sender side (src chain)\n    enum BridgeSendType {\n        Null,\n        Liquidity,\n        PegDeposit,\n        PegBurn,\n        PegV2Deposit,\n        PegV2Burn,\n        PegV2BurnFrom\n    }\n\n    // bridge operation type at the receiver side (dst chain)\n    enum TransferType {\n        Null,\n        LqRelay, // relay through liquidity bridge\n        LqWithdraw, // withdraw from liquidity bridge\n        PegMint, // mint through pegged token bridge\n        PegWithdraw, // withdraw from original token vault\n        PegV2Mint, // mint through pegged token bridge v2\n        PegV2Withdraw // withdraw from original token vault v2\n    }\n\n    enum MsgType {\n        MessageWithTransfer,\n        MessageOnly\n    }\n\n    enum TxStatus {\n        Null,\n        Success,\n        Fail,\n        Fallback,\n        Pending // transient state within a transaction\n    }\n\n    struct TransferInfo {\n        TransferType t;\n        address sender;\n        address receiver;\n        address token;\n        uint256 amount;\n        uint64 wdseq; // only needed for LqWithdraw (refund)\n        uint64 srcChainId;\n        bytes32 refId;\n        bytes32 srcTxHash; // src chain msg tx hash\n    }\n\n    struct RouteInfo {\n        address sender;\n        address receiver;\n        uint64 srcChainId;\n        bytes32 srcTxHash; // src chain msg tx hash\n    }\n\n    // used for msg from non-evm chains with longer-bytes address\n    struct RouteInfo2 {\n        bytes sender;\n        address receiver;\n        uint64 srcChainId;\n        bytes32 srcTxHash;\n    }\n\n    // combination of RouteInfo and RouteInfo2 for easier processing\n    struct Route {\n        address sender; // from RouteInfo\n        bytes senderBytes; // from RouteInfo2\n        address receiver;\n        uint64 srcChainId;\n        bytes32 srcTxHash;\n    }\n\n    struct MsgWithTransferExecutionParams {\n        bytes message;\n        TransferInfo transfer;\n        bytes[] sigs;\n        address[] signers;\n        uint256[] powers;\n    }\n\n    struct BridgeTransferParams {\n        bytes request;\n        bytes[] sigs;\n        address[] signers;\n        uint256[] powers;\n    }\n}\n"
    },
    "celer/contracts/message/messagebus/MessageBus.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.17;\n\nimport \"./MessageBusSender.sol\";\nimport \"./MessageBusReceiver.sol\";\n\ncontract MessageBus is MessageBusSender, MessageBusReceiver {\n    constructor(\n        ISigsVerifier _sigsVerifier,\n        address _liquidityBridge,\n        address _pegBridge,\n        address _pegVault,\n        address _pegBridgeV2,\n        address _pegVaultV2\n    )\n        MessageBusSender(_sigsVerifier)\n        MessageBusReceiver(_liquidityBridge, _pegBridge, _pegVault, _pegBridgeV2, _pegVaultV2)\n    {}\n\n    // this is only to be called by Proxy via delegateCall as initOwner will require _owner is 0.\n    // so calling init on this contract directly will guarantee to fail\n    function init(\n        address _liquidityBridge,\n        address _pegBridge,\n        address _pegVault,\n        address _pegBridgeV2,\n        address _pegVaultV2\n    ) external {\n        // MUST manually call ownable init and must only call once\n        initOwner();\n        // we don't need sender init as _sigsVerifier is immutable so already in the deployed code\n        initReceiver(_liquidityBridge, _pegBridge, _pegVault, _pegBridgeV2, _pegVaultV2);\n    }\n}\n"
    },
    "celer/contracts/message/messagebus/MessageBusReceiver.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.9;\n\nimport \"../libraries/MsgDataTypes.sol\";\nimport \"../interfaces/IMessageReceiverApp.sol\";\nimport \"../../interfaces/IBridge.sol\";\nimport \"../../interfaces/IOriginalTokenVault.sol\";\nimport \"../../interfaces/IOriginalTokenVaultV2.sol\";\nimport \"../../interfaces/IPeggedTokenBridge.sol\";\nimport \"../../interfaces/IPeggedTokenBridgeV2.sol\";\nimport \"../../interfaces/IDelayedTransfer.sol\";\nimport \"../../safeguard/Ownable.sol\";\nimport \"../../libraries/Utils.sol\";\n\ncontract MessageBusReceiver is Ownable {\n    mapping(bytes32 => MsgDataTypes.TxStatus) public executedMessages;\n\n    address public liquidityBridge; // liquidity bridge address\n    address public pegBridge; // peg bridge address\n    address public pegVault; // peg original vault address\n    address public pegBridgeV2; // peg bridge address\n    address public pegVaultV2; // peg original vault address\n\n    // minimum amount of gas needed by this contract before it tries to\n    // deliver a message to the target contract.\n    uint256 public preExecuteMessageGasUsage;\n\n    event Executed(\n        MsgDataTypes.MsgType msgType,\n        bytes32 msgId,\n        MsgDataTypes.TxStatus status,\n        address indexed receiver,\n        uint64 srcChainId,\n        bytes32 srcTxHash\n    );\n    event NeedRetry(MsgDataTypes.MsgType msgType, bytes32 msgId, uint64 srcChainId, bytes32 srcTxHash);\n    event CallReverted(string reason); // help debug\n\n    event LiquidityBridgeUpdated(address liquidityBridge);\n    event PegBridgeUpdated(address pegBridge);\n    event PegVaultUpdated(address pegVault);\n    event PegBridgeV2Updated(address pegBridgeV2);\n    event PegVaultV2Updated(address pegVaultV2);\n\n    constructor(\n        address _liquidityBridge,\n        address _pegBridge,\n        address _pegVault,\n        address _pegBridgeV2,\n        address _pegVaultV2\n    ) {\n        liquidityBridge = _liquidityBridge;\n        pegBridge = _pegBridge;\n        pegVault = _pegVault;\n        pegBridgeV2 = _pegBridgeV2;\n        pegVaultV2 = _pegVaultV2;\n    }\n\n    function initReceiver(\n        address _liquidityBridge,\n        address _pegBridge,\n        address _pegVault,\n        address _pegBridgeV2,\n        address _pegVaultV2\n    ) internal {\n        require(liquidityBridge == address(0), \"liquidityBridge already set\");\n        liquidityBridge = _liquidityBridge;\n        pegBridge = _pegBridge;\n        pegVault = _pegVault;\n        pegBridgeV2 = _pegBridgeV2;\n        pegVaultV2 = _pegVaultV2;\n    }\n\n    // ============== functions called by executor ==============\n\n    /**\n     * @notice Execute a message with a successful transfer.\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _transfer The transfer info.\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\n     * +2/3 of the sigsVerifier's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function executeMessageWithTransfer(\n        bytes calldata _message,\n        MsgDataTypes.TransferInfo calldata _transfer,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) public payable {\n        // For message with token transfer, message Id is computed through transfer info\n        // in order to guarantee that each transfer can only be used once.\n        bytes32 messageId = verifyTransfer(_transfer);\n        require(executedMessages[messageId] == MsgDataTypes.TxStatus.Null, \"transfer already executed\");\n        executedMessages[messageId] = MsgDataTypes.TxStatus.Pending;\n\n        bytes32 domain = keccak256(abi.encodePacked(block.chainid, address(this), \"MessageWithTransfer\"));\n        IBridge(liquidityBridge).verifySigs(\n            abi.encodePacked(domain, messageId, _message, _transfer.srcTxHash),\n            _sigs,\n            _signers,\n            _powers\n        );\n        MsgDataTypes.TxStatus status;\n        IMessageReceiverApp.ExecutionStatus est = executeMessageWithTransfer(_transfer, _message);\n        if (est == IMessageReceiverApp.ExecutionStatus.Success) {\n            status = MsgDataTypes.TxStatus.Success;\n        } else if (est == IMessageReceiverApp.ExecutionStatus.Retry) {\n            executedMessages[messageId] = MsgDataTypes.TxStatus.Null;\n            emit NeedRetry(\n                MsgDataTypes.MsgType.MessageWithTransfer,\n                messageId,\n                _transfer.srcChainId,\n                _transfer.srcTxHash\n            );\n            return;\n        } else {\n            est = executeMessageWithTransferFallback(_transfer, _message);\n            if (est == IMessageReceiverApp.ExecutionStatus.Success) {\n                status = MsgDataTypes.TxStatus.Fallback;\n            } else {\n                status = MsgDataTypes.TxStatus.Fail;\n            }\n        }\n        executedMessages[messageId] = status;\n        emitMessageWithTransferExecutedEvent(messageId, status, _transfer);\n    }\n\n    /**\n     * @notice Execute a message with a refunded transfer.\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _transfer The transfer info.\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\n     * +2/3 of the sigsVerifier's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function executeMessageWithTransferRefund(\n        bytes calldata _message, // the same message associated with the original transfer\n        MsgDataTypes.TransferInfo calldata _transfer,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) public payable {\n        // similar to executeMessageWithTransfer\n        bytes32 messageId = verifyTransfer(_transfer);\n        require(executedMessages[messageId] == MsgDataTypes.TxStatus.Null, \"transfer already executed\");\n        executedMessages[messageId] = MsgDataTypes.TxStatus.Pending;\n\n        bytes32 domain = keccak256(abi.encodePacked(block.chainid, address(this), \"MessageWithTransferRefund\"));\n        IBridge(liquidityBridge).verifySigs(\n            abi.encodePacked(domain, messageId, _message, _transfer.srcTxHash),\n            _sigs,\n            _signers,\n            _powers\n        );\n        MsgDataTypes.TxStatus status;\n        IMessageReceiverApp.ExecutionStatus est = executeMessageWithTransferRefund(_transfer, _message);\n        if (est == IMessageReceiverApp.ExecutionStatus.Success) {\n            status = MsgDataTypes.TxStatus.Success;\n        } else if (est == IMessageReceiverApp.ExecutionStatus.Retry) {\n            executedMessages[messageId] = MsgDataTypes.TxStatus.Null;\n            emit NeedRetry(\n                MsgDataTypes.MsgType.MessageWithTransfer,\n                messageId,\n                _transfer.srcChainId,\n                _transfer.srcTxHash\n            );\n            return;\n        } else {\n            status = MsgDataTypes.TxStatus.Fail;\n        }\n        executedMessages[messageId] = status;\n        emitMessageWithTransferExecutedEvent(messageId, status, _transfer);\n    }\n\n    /**\n     * @notice Execute a message not associated with a transfer.\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _route The info about the sender and the receiver.\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\n     * +2/3 of the sigsVerifier's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function executeMessage(\n        bytes calldata _message,\n        MsgDataTypes.RouteInfo calldata _route,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external payable {\n        MsgDataTypes.Route memory route = getRouteInfo(_route);\n        executeMessage(_message, route, _sigs, _signers, _powers, \"Message\");\n    }\n\n    // execute message from non-evm chain with bytes for sender address,\n    // otherwise same as above.\n    function executeMessage(\n        bytes calldata _message,\n        MsgDataTypes.RouteInfo2 calldata _route,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external payable {\n        MsgDataTypes.Route memory route = getRouteInfo(_route);\n        executeMessage(_message, route, _sigs, _signers, _powers, \"Message2\");\n    }\n\n    function executeMessage(\n        bytes calldata _message,\n        MsgDataTypes.Route memory _route,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers,\n        string memory domainName\n    ) private {\n        // For message without associated token transfer, message Id is computed through message info,\n        // in order to guarantee that each message can only be applied once\n        bytes32 messageId = computeMessageOnlyId(_route, _message);\n        require(executedMessages[messageId] == MsgDataTypes.TxStatus.Null, \"message already executed\");\n        executedMessages[messageId] = MsgDataTypes.TxStatus.Pending;\n\n        bytes32 domain = keccak256(abi.encodePacked(block.chainid, address(this), domainName));\n        IBridge(liquidityBridge).verifySigs(abi.encodePacked(domain, messageId), _sigs, _signers, _powers);\n        MsgDataTypes.TxStatus status;\n        IMessageReceiverApp.ExecutionStatus est = executeMessage(_route, _message);\n        if (est == IMessageReceiverApp.ExecutionStatus.Success) {\n            status = MsgDataTypes.TxStatus.Success;\n        } else if (est == IMessageReceiverApp.ExecutionStatus.Retry) {\n            executedMessages[messageId] = MsgDataTypes.TxStatus.Null;\n            emit NeedRetry(MsgDataTypes.MsgType.MessageOnly, messageId, _route.srcChainId, _route.srcTxHash);\n            return;\n        } else {\n            status = MsgDataTypes.TxStatus.Fail;\n        }\n        executedMessages[messageId] = status;\n        emitMessageOnlyExecutedEvent(messageId, status, _route);\n    }\n\n    // ================= utils (to avoid stack too deep) =================\n\n    function emitMessageWithTransferExecutedEvent(\n        bytes32 _messageId,\n        MsgDataTypes.TxStatus _status,\n        MsgDataTypes.TransferInfo calldata _transfer\n    ) private {\n        emit Executed(\n            MsgDataTypes.MsgType.MessageWithTransfer,\n            _messageId,\n            _status,\n            _transfer.receiver,\n            _transfer.srcChainId,\n            _transfer.srcTxHash\n        );\n    }\n\n    function emitMessageOnlyExecutedEvent(\n        bytes32 _messageId,\n        MsgDataTypes.TxStatus _status,\n        MsgDataTypes.Route memory _route\n    ) private {\n        emit Executed(\n            MsgDataTypes.MsgType.MessageOnly,\n            _messageId,\n            _status,\n            _route.receiver,\n            _route.srcChainId,\n            _route.srcTxHash\n        );\n    }\n\n    function executeMessageWithTransfer(MsgDataTypes.TransferInfo calldata _transfer, bytes calldata _message)\n        private\n        returns (IMessageReceiverApp.ExecutionStatus)\n    {\n        uint256 gasLeftBeforeExecution = gasleft();\n        (bool ok, bytes memory res) = address(_transfer.receiver).call{value: msg.value}(\n            abi.encodeWithSelector(\n                IMessageReceiverApp.executeMessageWithTransfer.selector,\n                _transfer.sender,\n                _transfer.token,\n                _transfer.amount,\n                _transfer.srcChainId,\n                _message,\n                msg.sender\n            )\n        );\n        if (ok) {\n            return abi.decode((res), (IMessageReceiverApp.ExecutionStatus));\n        }\n        handleExecutionRevert(gasLeftBeforeExecution, res);\n        return IMessageReceiverApp.ExecutionStatus.Fail;\n    }\n\n    function executeMessageWithTransferFallback(MsgDataTypes.TransferInfo calldata _transfer, bytes calldata _message)\n        private\n        returns (IMessageReceiverApp.ExecutionStatus)\n    {\n        uint256 gasLeftBeforeExecution = gasleft();\n        (bool ok, bytes memory res) = address(_transfer.receiver).call{value: msg.value}(\n            abi.encodeWithSelector(\n                IMessageReceiverApp.executeMessageWithTransferFallback.selector,\n                _transfer.sender,\n                _transfer.token,\n                _transfer.amount,\n                _transfer.srcChainId,\n                _message,\n                msg.sender\n            )\n        );\n        if (ok) {\n            return abi.decode((res), (IMessageReceiverApp.ExecutionStatus));\n        }\n        handleExecutionRevert(gasLeftBeforeExecution, res);\n        return IMessageReceiverApp.ExecutionStatus.Fail;\n    }\n\n    function executeMessageWithTransferRefund(MsgDataTypes.TransferInfo calldata _transfer, bytes calldata _message)\n        private\n        returns (IMessageReceiverApp.ExecutionStatus)\n    {\n        uint256 gasLeftBeforeExecution = gasleft();\n        (bool ok, bytes memory res) = address(_transfer.receiver).call{value: msg.value}(\n            abi.encodeWithSelector(\n                IMessageReceiverApp.executeMessageWithTransferRefund.selector,\n                _transfer.token,\n                _transfer.amount,\n                _message,\n                msg.sender\n            )\n        );\n        if (ok) {\n            return abi.decode((res), (IMessageReceiverApp.ExecutionStatus));\n        }\n        handleExecutionRevert(gasLeftBeforeExecution, res);\n        return IMessageReceiverApp.ExecutionStatus.Fail;\n    }\n\n    function verifyTransfer(MsgDataTypes.TransferInfo calldata _transfer) private view returns (bytes32) {\n        bytes32 transferId;\n        address bridgeAddr;\n        MsgDataTypes.TransferType t = _transfer.t;\n        if (t == MsgDataTypes.TransferType.LqRelay) {\n            bridgeAddr = liquidityBridge;\n            transferId = keccak256(\n                abi.encodePacked(\n                    _transfer.sender,\n                    _transfer.receiver,\n                    _transfer.token,\n                    _transfer.amount,\n                    _transfer.srcChainId,\n                    uint64(block.chainid),\n                    _transfer.refId\n                )\n            );\n            require(IBridge(bridgeAddr).transfers(transferId) == true, \"relay not exist\");\n        } else if (t == MsgDataTypes.TransferType.LqWithdraw) {\n            bridgeAddr = liquidityBridge;\n            transferId = keccak256(\n                abi.encodePacked(\n                    uint64(block.chainid),\n                    _transfer.wdseq,\n                    _transfer.receiver,\n                    _transfer.token,\n                    _transfer.amount\n                )\n            );\n            require(IBridge(bridgeAddr).withdraws(transferId) == true, \"withdraw not exist\");\n        } else {\n            if (t == MsgDataTypes.TransferType.PegMint || t == MsgDataTypes.TransferType.PegWithdraw) {\n                bridgeAddr = (t == MsgDataTypes.TransferType.PegMint) ? pegBridge : pegVault;\n                transferId = keccak256(\n                    abi.encodePacked(\n                        _transfer.receiver,\n                        _transfer.token,\n                        _transfer.amount,\n                        _transfer.sender,\n                        _transfer.srcChainId,\n                        _transfer.refId\n                    )\n                );\n            } else {\n                bridgeAddr = (t == MsgDataTypes.TransferType.PegV2Mint) ? pegBridgeV2 : pegVaultV2;\n                transferId = keccak256(\n                    abi.encodePacked(\n                        _transfer.receiver,\n                        _transfer.token,\n                        _transfer.amount,\n                        _transfer.sender,\n                        _transfer.srcChainId,\n                        _transfer.refId,\n                        bridgeAddr\n                    )\n                );\n            }\n            // function is same for peg, peg2, vault, vault2\n            require(IPeggedTokenBridge(bridgeAddr).records(transferId) == true, \"record not exist\");\n        }\n        require(IDelayedTransfer(bridgeAddr).delayedTransfers(transferId).timestamp == 0, \"transfer delayed\");\n        return keccak256(abi.encodePacked(MsgDataTypes.MsgType.MessageWithTransfer, bridgeAddr, transferId));\n    }\n\n    function computeMessageOnlyId(MsgDataTypes.Route memory _route, bytes calldata _message)\n        private\n        view\n        returns (bytes32)\n    {\n        bytes memory sender = _route.senderBytes;\n        if (sender.length == 0) {\n            sender = abi.encodePacked(_route.sender);\n        }\n        return\n            keccak256(\n                abi.encodePacked(\n                    MsgDataTypes.MsgType.MessageOnly,\n                    sender,\n                    _route.receiver,\n                    _route.srcChainId,\n                    _route.srcTxHash,\n                    uint64(block.chainid),\n                    _message\n                )\n            );\n    }\n\n    function executeMessage(MsgDataTypes.Route memory _route, bytes calldata _message)\n        private\n        returns (IMessageReceiverApp.ExecutionStatus)\n    {\n        uint256 gasLeftBeforeExecution = gasleft();\n        bool ok;\n        bytes memory res;\n        if (_route.senderBytes.length == 0) {\n            (ok, res) = address(_route.receiver).call{value: msg.value}(\n                abi.encodeWithSelector(\n                    bytes4(keccak256(bytes(\"executeMessage(address,uint64,bytes,address)\"))),\n                    _route.sender,\n                    _route.srcChainId,\n                    _message,\n                    msg.sender\n                )\n            );\n        } else {\n            (ok, res) = address(_route.receiver).call{value: msg.value}(\n                abi.encodeWithSelector(\n                    bytes4(keccak256(bytes(\"executeMessage(bytes,uint64,bytes,address)\"))),\n                    _route.senderBytes,\n                    _route.srcChainId,\n                    _message,\n                    msg.sender\n                )\n            );\n        }\n        if (ok) {\n            return abi.decode((res), (IMessageReceiverApp.ExecutionStatus));\n        }\n        handleExecutionRevert(gasLeftBeforeExecution, res);\n        return IMessageReceiverApp.ExecutionStatus.Fail;\n    }\n\n    function handleExecutionRevert(uint256 _gasLeftBeforeExecution, bytes memory _returnData) private {\n        uint256 gasLeftAfterExecution = gasleft();\n        uint256 maxTargetGasLimit = block.gaslimit - preExecuteMessageGasUsage;\n        if (_gasLeftBeforeExecution < maxTargetGasLimit && gasLeftAfterExecution <= _gasLeftBeforeExecution / 64) {\n            // if this happens, the executor must have not provided sufficient gas limit,\n            // then the tx should revert instead of recording a non-retryable failure status\n            // https://github.com/wolflo/evm-opcodes/blob/main/gas.md#aa-f-gas-to-send-with-call-operations\n            assembly {\n                invalid()\n            }\n        }\n        string memory revertMsg = Utils.getRevertMsg(_returnData);\n        // revert the execution if the revert message has the ABORT prefix\n        checkAbortPrefix(revertMsg);\n        // otherwiase, emit revert message, return and mark the execution as failed (non-retryable)\n        emit CallReverted(revertMsg);\n    }\n\n    function checkAbortPrefix(string memory _revertMsg) private pure {\n        bytes memory prefixBytes = bytes(MsgDataTypes.ABORT_PREFIX);\n        bytes memory msgBytes = bytes(_revertMsg);\n        if (msgBytes.length >= prefixBytes.length) {\n            for (uint256 i = 0; i < prefixBytes.length; i++) {\n                if (msgBytes[i] != prefixBytes[i]) {\n                    return; // prefix not match, return\n                }\n            }\n            revert(_revertMsg); // prefix match, revert\n        }\n    }\n\n    function getRouteInfo(MsgDataTypes.RouteInfo calldata _route) private pure returns (MsgDataTypes.Route memory) {\n        return MsgDataTypes.Route(_route.sender, \"\", _route.receiver, _route.srcChainId, _route.srcTxHash);\n    }\n\n    function getRouteInfo(MsgDataTypes.RouteInfo2 calldata _route) private pure returns (MsgDataTypes.Route memory) {\n        return MsgDataTypes.Route(address(0), _route.sender, _route.receiver, _route.srcChainId, _route.srcTxHash);\n    }\n\n    // ================= helper functions =====================\n\n    /**\n     * @notice combine bridge transfer and msg execution calls into a single tx\n     * @dev caller needs to get the required input params from SGN\n     * @param _tp params to call bridge transfer\n     * @param _mp params to execute message\n     */\n    function transferAndExecuteMsg(\n        MsgDataTypes.BridgeTransferParams calldata _tp,\n        MsgDataTypes.MsgWithTransferExecutionParams calldata _mp\n    ) external {\n        _bridgeTransfer(_mp.transfer.t, _tp);\n        executeMessageWithTransfer(_mp.message, _mp.transfer, _mp.sigs, _mp.signers, _mp.powers);\n    }\n\n    /**\n     * @notice combine bridge refund and msg execution calls into a single tx\n     * @dev caller needs to get the required input params from SGN\n     * @param _tp params to call bridge transfer for refund\n     * @param _mp params to execute message for refund\n     */\n    function refundAndExecuteMsg(\n        MsgDataTypes.BridgeTransferParams calldata _tp,\n        MsgDataTypes.MsgWithTransferExecutionParams calldata _mp\n    ) external {\n        _bridgeTransfer(_mp.transfer.t, _tp);\n        executeMessageWithTransferRefund(_mp.message, _mp.transfer, _mp.sigs, _mp.signers, _mp.powers);\n    }\n\n    function _bridgeTransfer(MsgDataTypes.TransferType t, MsgDataTypes.BridgeTransferParams calldata _params) private {\n        if (t == MsgDataTypes.TransferType.LqRelay) {\n            IBridge(liquidityBridge).relay(_params.request, _params.sigs, _params.signers, _params.powers);\n        } else if (t == MsgDataTypes.TransferType.LqWithdraw) {\n            IBridge(liquidityBridge).withdraw(_params.request, _params.sigs, _params.signers, _params.powers);\n        } else if (t == MsgDataTypes.TransferType.PegMint) {\n            IPeggedTokenBridge(pegBridge).mint(_params.request, _params.sigs, _params.signers, _params.powers);\n        } else if (t == MsgDataTypes.TransferType.PegV2Mint) {\n            IPeggedTokenBridgeV2(pegBridgeV2).mint(_params.request, _params.sigs, _params.signers, _params.powers);\n        } else if (t == MsgDataTypes.TransferType.PegWithdraw) {\n            IOriginalTokenVault(pegVault).withdraw(_params.request, _params.sigs, _params.signers, _params.powers);\n        } else if (t == MsgDataTypes.TransferType.PegV2Withdraw) {\n            IOriginalTokenVaultV2(pegVaultV2).withdraw(_params.request, _params.sigs, _params.signers, _params.powers);\n        }\n    }\n\n    // ================= contract config =================\n\n    function setLiquidityBridge(address _addr) public onlyOwner {\n        require(_addr != address(0), \"invalid address\");\n        liquidityBridge = _addr;\n        emit LiquidityBridgeUpdated(liquidityBridge);\n    }\n\n    function setPegBridge(address _addr) public onlyOwner {\n        require(_addr != address(0), \"invalid address\");\n        pegBridge = _addr;\n        emit PegBridgeUpdated(pegBridge);\n    }\n\n    function setPegVault(address _addr) public onlyOwner {\n        require(_addr != address(0), \"invalid address\");\n        pegVault = _addr;\n        emit PegVaultUpdated(pegVault);\n    }\n\n    function setPegBridgeV2(address _addr) public onlyOwner {\n        require(_addr != address(0), \"invalid address\");\n        pegBridgeV2 = _addr;\n        emit PegBridgeV2Updated(pegBridgeV2);\n    }\n\n    function setPegVaultV2(address _addr) public onlyOwner {\n        require(_addr != address(0), \"invalid address\");\n        pegVaultV2 = _addr;\n        emit PegVaultV2Updated(pegVaultV2);\n    }\n\n    function setPreExecuteMessageGasUsage(uint256 _usage) public onlyOwner {\n        preExecuteMessageGasUsage = _usage;\n    }\n}\n"
    },
    "celer/contracts/message/messagebus/MessageBusSender.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.17;\n\nimport \"../../safeguard/Ownable.sol\";\nimport \"../../interfaces/ISigsVerifier.sol\";\n\ncontract MessageBusSender is Ownable {\n    ISigsVerifier public immutable sigsVerifier;\n\n    uint256 public feeBase;\n    uint256 public feePerByte;\n    mapping(address => uint256) public withdrawnFees;\n\n    event Message(address indexed sender, address receiver, uint256 dstChainId, bytes message, uint256 fee);\n    // message to non-evm chain with >20 bytes addr\n    event Message2(address indexed sender, bytes receiver, uint256 dstChainId, bytes message, uint256 fee);\n\n    event MessageWithTransfer(\n        address indexed sender,\n        address receiver,\n        uint256 dstChainId,\n        address bridge,\n        bytes32 srcTransferId,\n        bytes message,\n        uint256 fee\n    );\n\n    event FeeWithdrawn(address receiver, uint256 amount);\n\n    event FeeBaseUpdated(uint256 feeBase);\n    event FeePerByteUpdated(uint256 feePerByte);\n\n    constructor(ISigsVerifier _sigsVerifier) {\n        sigsVerifier = _sigsVerifier;\n    }\n\n    /**\n     * @notice Sends a message to a contract on another chain.\n     * Sender needs to make sure the uniqueness of the message Id, which is computed as\n     * hash(type.MessageOnly, sender, receiver, srcChainId, srcTxHash, dstChainId, message).\n     * If messages with the same Id are sent, only one of them will succeed at dst chain.\n     * A fee is charged in the native gas token.\n     * @param _receiver The address of the destination app contract.\n     * @param _dstChainId The destination chain ID.\n     * @param _message Arbitrary message bytes to be decoded by the destination app contract.\n     */\n    function sendMessage(\n        address _receiver,\n        uint256 _dstChainId,\n        bytes calldata _message\n    ) external payable {\n        _sendMessage(_dstChainId, _message);\n        emit Message(msg.sender, _receiver, _dstChainId, _message, msg.value);\n    }\n\n    // Send message to non-evm chain with bytes for receiver address,\n    // otherwise same as above.\n    function sendMessage(\n        bytes calldata _receiver,\n        uint256 _dstChainId,\n        bytes calldata _message\n    ) external payable {\n        _sendMessage(_dstChainId, _message);\n        emit Message2(msg.sender, _receiver, _dstChainId, _message, msg.value);\n    }\n\n    function _sendMessage(uint256 _dstChainId, bytes calldata _message) private {\n        require(_dstChainId != block.chainid, \"Invalid chainId\");\n        uint256 minFee = calcFee(_message);\n        require(msg.value >= minFee, \"Insufficient fee\");\n    }\n\n    /**\n     * @notice Sends a message associated with a transfer to a contract on another chain.\n     * If messages with the same srcTransferId are sent, only one of them will succeed.\n     * A fee is charged in the native token.\n     * @param _receiver The address of the destination app contract.\n     * @param _dstChainId The destination chain ID.\n     * @param _srcBridge The bridge contract to send the transfer with.\n     * @param _srcTransferId The transfer ID.\n     * @param _dstChainId The destination chain ID.\n     * @param _message Arbitrary message bytes to be decoded by the destination app contract.\n     */\n    function sendMessageWithTransfer(\n        address _receiver,\n        uint256 _dstChainId,\n        address _srcBridge,\n        bytes32 _srcTransferId,\n        bytes calldata _message\n    ) external payable {\n        require(_dstChainId != block.chainid, \"Invalid chainId\");\n        uint256 minFee = calcFee(_message);\n        require(msg.value >= minFee, \"Insufficient fee\");\n        // SGN needs to verify\n        // 1. msg.sender matches sender of the src transfer\n        // 2. dstChainId matches dstChainId of the src transfer\n        // 3. bridge is either liquidity bridge, peg src vault, or peg dst bridge\n        emit MessageWithTransfer(msg.sender, _receiver, _dstChainId, _srcBridge, _srcTransferId, _message, msg.value);\n    }\n\n    /**\n     * @notice Withdraws message fee in the form of native gas token.\n     * @param _account The address receiving the fee.\n     * @param _cumulativeFee The cumulative fee credited to the account. Tracked by SGN.\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A withdrawal must be\n     * signed-off by +2/3 of the sigsVerifier's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function withdrawFee(\n        address _account,\n        uint256 _cumulativeFee,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external {\n        bytes32 domain = keccak256(abi.encodePacked(block.chainid, address(this), \"withdrawFee\"));\n        sigsVerifier.verifySigs(abi.encodePacked(domain, _account, _cumulativeFee), _sigs, _signers, _powers);\n        uint256 amount = _cumulativeFee - withdrawnFees[_account];\n        require(amount > 0, \"No new amount to withdraw\");\n        withdrawnFees[_account] = _cumulativeFee;\n        (bool sent, ) = _account.call{value: amount, gas: 50000}(\"\");\n        require(sent, \"failed to withdraw fee\");\n        emit FeeWithdrawn(_account, amount);\n    }\n\n    /**\n     * @notice Calculates the required fee for the message.\n     * @param _message Arbitrary message bytes to be decoded by the destination app contract.\n     @ @return The required fee.\n     */\n    function calcFee(bytes calldata _message) public view returns (uint256) {\n        return feeBase + _message.length * feePerByte;\n    }\n\n    // -------------------- Admin --------------------\n\n    function setFeePerByte(uint256 _fee) external onlyOwner {\n        feePerByte = _fee;\n        emit FeePerByteUpdated(feePerByte);\n    }\n\n    function setFeeBase(uint256 _fee) external onlyOwner {\n        feeBase = _fee;\n        emit FeeBaseUpdated(feeBase);\n    }\n}\n"
    },
    "celer/contracts/safeguard/Ownable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n *\n * This adds a normal func that setOwner if _owner is address(0). So we can't allow\n * renounceOwnership. So we can support Proxy based upgradable contract\n */\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(msg.sender);\n    }\n\n    /**\n     * @dev Only to be called by inherit contracts, in their init func called by Proxy\n     * we require _owner == address(0), which is only possible when it's a delegateCall\n     * because constructor sets _owner in contract state.\n     */\n    function initOwner() internal {\n        require(_owner == address(0), \"owner already set\");\n        _setOwner(msg.sender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/__mocks__/MessageBusMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.17;\n\nimport { IMessageBus, MsgDataTypes } from \"celer/contracts/message/interfaces/IMessageBus.sol\";\nimport { IMessageReceiverApp } from \"celer/contracts/message/framework/MessageApp.sol\";\n\ncontract MessageBusMock is IMessageBus {\n    event sendMessageEvent(address _receiver, uint256 _dstChainId, bytes _message, uint256 _value);\n    event sendMessageEventBytes(bytes _receiver, uint256 _dstChainId, bytes _message, uint256 _value);\n    event sendMessageWithTransferEvent(\n        address _receiver,\n        uint256 _dstChainId,\n        address _srcBridge,\n        bytes32 _srcTransferId,\n        bytes _message,\n        uint256 _value\n    );\n    event executeMessageEvent(bytes _message, MsgDataTypes.RouteInfo _route, bytes[] _sigs, address[] _signers, uint256[] _powers);\n    event executeMessageWithTransferEvent(\n        bytes _message,\n        MsgDataTypes.TransferInfo _route,\n        bytes[] _sigs,\n        address[] _signers,\n        uint256[] _powers\n    );\n\n    function sendMessage(address _receiver, uint256 _dstChainId, bytes calldata _message) external payable {\n        emit sendMessageEvent(_receiver, _dstChainId, _message, msg.value);\n    }\n\n    function sendMessage(bytes calldata _receiver, uint256 _dstChainId, bytes calldata _message) external payable {\n        emit sendMessageEventBytes(_receiver, _dstChainId, _message, msg.value);\n    }\n\n    function sendMessageWithTransfer(\n        address _receiver,\n        uint256 _dstChainId,\n        address _srcBridge,\n        bytes32 _srcTransferId,\n        bytes calldata _message\n    ) external payable {\n        emit sendMessageWithTransferEvent(_receiver, _dstChainId, _srcBridge, _srcTransferId, _message, msg.value);\n    }\n\n    function executeMessage(\n        bytes calldata _message,\n        MsgDataTypes.RouteInfo calldata _route,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external payable {\n        emit executeMessageEvent(_message, _route, _sigs, _signers, _powers);\n    }\n\n    function executeMessageWithTransfer(\n        bytes calldata _message,\n        MsgDataTypes.TransferInfo calldata _transfer,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external payable {\n        emit executeMessageWithTransferEvent(_message, _transfer, _sigs, _signers, _powers);\n    }\n\n    function executeMessageWithTransferRefund(\n        bytes calldata _message, // the same message associated with the original transfer\n        MsgDataTypes.TransferInfo calldata _transfer,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external payable {}\n\n    function withdrawFee(\n        address _account,\n        uint256 _cumulativeFee,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external {}\n\n    function calcFee(bytes calldata _message) public pure returns (uint256) {\n        return 1 + _message.length * 1;\n    }\n\n    function liquidityBridge() external pure returns (address) {\n        return 0x0000000000000000000000000000000000000001;\n    }\n\n    function pegBridge() external pure returns (address) {\n        return 0x0000000000000000000000000000000000000001;\n    }\n\n    function pegBridgeV2() external pure returns (address) {\n        return 0x0000000000000000000000000000000000000001;\n    }\n\n    function pegVault() external pure returns (address) {\n        return 0x0000000000000000000000000000000000000001;\n    }\n\n    function pegVaultV2() external view returns (address) {\n        return 0x0000000000000000000000000000000000000001;\n    }\n\n    ///\n    /// Helper functions to execute message bus calls\n    ///\n\n    function relayerCall_executeMessage(\n        address _relayer,\n        address _srcContract,\n        uint64 _srcChainId,\n        bytes calldata _message\n    ) external payable returns (IMessageReceiverApp.ExecutionStatus) {\n        return IMessageReceiverApp(_relayer).executeMessage{ value: msg.value }(_srcContract, _srcChainId, _message, msg.sender);\n    }\n\n    function relayerCall_executeMessageRaw(\n        address _relayer,\n        bytes calldata _message\n    ) external payable returns (IMessageReceiverApp.ExecutionStatus) {\n        (bool _success, bytes memory _data) = address(_relayer).call(_message);\n        _data;\n        return _success ? IMessageReceiverApp.ExecutionStatus.Success : IMessageReceiverApp.ExecutionStatus.Fail;\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/__mocks__/RelayerCelerMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport { IRelayerCeler } from \"./../diamond/interfaces/IRelayerCeler.sol\";\nimport { ICelerFeeHubFacet } from \"./../diamond/interfaces/ICelerFeeHubFacet.sol\";\n\ncontract RelayerCelerMock is IRelayerCeler {\n    uint256 public deployFeesFeeCalcReturnValue = 100;\n    uint256 public sendFeesFeeCalcReturnValue = 100;\n\n    event deployFeesEvent(address _receiver, address _target, uint256 _dstChainId, bytes _message);\n    event sendFeesEvent(address _asset, uint256 _amount, uint32 minMaxSlippage, bytes _message);\n\n    function deployFees(address _receiver, address _target, uint256 _chainId, bytes calldata _message) external payable {\n        emit deployFeesEvent(_receiver, _target, _chainId, _message);\n    }\n\n    function sendFees(address _asset, uint256 _amount, uint32 minMaxSlippage, bytes calldata _message) external payable {\n        emit sendFeesEvent(_asset, _amount, minMaxSlippage, _message);\n    }\n\n    function deployFeesFeeCalc(address _target, bytes calldata _message) external view returns (uint256 _wei) {\n        _target;\n        _message;\n        _wei = deployFeesFeeCalcReturnValue;\n    }\n\n    function sendFeesFeeCalc(bytes calldata _message) external view returns (uint256 _wei) {\n        _message;\n        _wei = sendFeesFeeCalcReturnValue;\n    }\n\n    function setDeployFeesFeeCalcReturnValue(uint256 _deployFeesFeeCalcReturnValue) external {\n        deployFeesFeeCalcReturnValue = _deployFeesFeeCalcReturnValue;\n    }\n\n    function setSendFeesFeeCalcReturnValue(uint256 _sendFeesFeeCalcReturnValue) external {\n        sendFeesFeeCalcReturnValue = _sendFeesFeeCalcReturnValue;\n    }\n\n    /// internal testing\n\n    function fakeCelerFeeHubFacetDeployFeesWithCelerConfirm(address _contract, uint64 _chainId, bytes memory _message) external {\n        ICelerFeeHubFacet(_contract).deployFeesWithCelerConfirm(_chainId, _message);\n    }\n}\n"
    },
    "contracts/__mocks__/RelayerCelerTargetMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.17;\n\nimport { RelayerCeler, MsgDataTypes } from \"./../diamond/relayers/RelayerCeler.sol\";\n\ncontract RelayerCelerTargetMock is RelayerCeler {\n    event sendMessageWithTransferEvent(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        uint64 _dstChainId,\n        uint64 _nonce,\n        uint32 _maxSlippage,\n        bytes _message,\n        MsgDataTypes.BridgeSendType _bridgeSendType,\n        address _messageBus,\n        uint256 _fee\n    );\n\n    constructor(\n        address _diamond,\n        address _relayerHome,\n        address _operator,\n        address _messageBus,\n        uint256 _chainHome,\n        bool _isHomeRelayer\n    ) RelayerCeler(_diamond, _relayerHome, _operator, _messageBus, _chainHome, _isHomeRelayer) {}\n\n    function _sendMessageWithTransfer(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        uint64 _dstChainId,\n        uint64 _nonce,\n        uint32 _maxSlippage,\n        bytes memory _message,\n        MsgDataTypes.BridgeSendType _bridgeSendType,\n        uint256 _fee\n    ) internal override returns (bytes32) {\n        emit sendMessageWithTransferEvent(\n            _receiver,\n            _token,\n            _amount,\n            _dstChainId,\n            _nonce,\n            _maxSlippage,\n            _message,\n            _bridgeSendType,\n            messageBus,\n            _fee\n        );\n        return keccak256(\"TRANSFER_ID\");\n    }\n}\n"
    },
    "contracts/diamond/helpers/Constants.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\nlibrary Constants {\n    /*-------------------------------- Role --------------------------------*/\n    // 0x0000000000000000000000000000000000000000000000000000000000000000\n    bytes32 constant DEFAULT_ADMIN_ROLE = 0x00;\n    // 0xa49807205ce4d355092ef5a8a18f56e8913cf4a201fbe287825b095693c21775\n    bytes32 constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    // 0xfc425f2263d0df187444b70e47283d622c70181c5baebb1306a01edba1ce184c\n    bytes32 constant DEPLOYER_ROLE = keccak256(\"DEPLOYER_ROLE\");\n    // 0x6c0757dc3e6b28b2580c03fd9e96c274acf4f99d91fbec9b418fa1d70604ff1c\n    bytes32 constant FEE_MANAGER_ROLE = keccak256(\"FEE_MANAGER_ROLE\");\n    // 0x63eb04268b235ac1afacf3bcf4b19c5c175d0417a1555fb3ff79ae190f71ee7c\n    bytes32 constant FEE_STORE_MANAGER_ROLE = keccak256(\"FEE_STORE_MANAGER_ROLE\");\n    // 0x77f52ccf2f32e71a0cff8f14ad8c8303b7d2e4c7609b8fba963114f4db2af767\n    bytes32 constant FEE_DISTRIBUTOR_PUSH_ROLE = keccak256(\"FEE_DISTRIBUTOR_PUSH_ROLE\");\n    // 0xe85d5f1f8338cb18f500856d1568d0f3b0d0971f25b3ccd134475e991354edbf\n    bytes32 constant FEE_DISTRIBUTOR_MANAGER = keccak256(\"FEE_DISTRIBUTOR_MANAGER\");\n    /*----------------------------------------------------------------------*/\n\n    /*------------------------------- Fee ID -------------------------------*/\n    // 0xacfc432e98ad100d9f8c385f3782bc88a17e1de7e53f69678cbcc41e8ffe72b0\n    bytes32 constant ERC20_MARKETING_FEE = keccak256(\"ERC20_MARKETING_FEE\");\n    // 0x6b78196f16f828b24a5a6584d4a1bcc5ce2f3154ba57839db273e6a4ebbe92c2\n    bytes32 constant ERC20_REWARD_FEE = keccak256(\"ERC20_REWARD_FEE\");\n    // 0x6e3678bee6f77c8a6179922c9a518b08407e6d9d2593ac683a87c979c8b31a12\n    bytes32 constant ERC20_PLATFORM_FEE = keccak256(\"ERC20_PLATFORM_FEE\");\n    // 0x6e2178bb28988b4c92cd3092e9e342e7639bfda2f68a02ac478cb084759607cf\n    bytes32 constant ERC20_DEVELOPER_FEE = keccak256(\"ERC20_DEVELOPER_FEE\");\n    /*----------------------------------------------------------------------*/\n\n    /*--------------------------- Relayer Actions --------------------------*/\n    // 0xf145583e6e33d9da99af75b579493b11db4229a339336b82c748312f152b29a9\n    bytes32 constant RELAYER_ACTION_DEPLOY_FEES = keccak256(\"RELAYER_ACTION_DEPLOY_FEES\");\n    // 0xf375f410a0dc135af0d9a16e273eac999064981d8813a68af762e93567a43aac\n    bytes32 constant RELAYER_ACTION_DEPLOY_FEES_CONFIRM = keccak256(\"RELAYER_ACTION_DEPLOY_FEES_CONFIRM\");\n    // 0x9d62257b25ea052fe7cd5123fd6b791268b8673b073aae5de4a823c4dc7d7607\n    bytes32 constant RELAYER_ACTION_SEND_FEES = keccak256(\"RELAYER_ACTION_SEND_FEES\");\n    /*----------------------------------------------------------------------*/\n}\n"
    },
    "contracts/diamond/helpers/Enums.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\n/// enums\nenum FeeCurrency {\n    Null,\n    // L1\n    Native,\n    // different asset\n    Token\n}\n\nenum FeeType {\n    Null,\n    // absolute/onetime\n    Default,\n    // buy/sell depending on target\n    From,\n    // buy/sell depending on target\n    To\n}\n\nenum FeeSyncAction {\n    Null,\n    // adding a fee\n    Add,\n    // updating a fee\n    Update,\n    // removing a fee\n    Delete\n}\n\nenum FeeDeployState {\n    Null,\n    // a fee is recently added, updated or removed\n    Queued,\n    // a fee config is deployed\n    Pending,\n    // a fee gets receives information about being deployed\n    Deployed\n}\n"
    },
    "contracts/diamond/helpers/Functions.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.17;\n\nimport { AddressZero } from \"./GenericErrors.sol\";\n\nfunction addressZeroCheck(address _candidate) pure {\n    if (_candidate == address(0)) revert AddressZero();\n}\n"
    },
    "contracts/diamond/helpers/GenericErrors.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\nerror AddressZero();\nerror ZeroValueNotAllowed();\nerror InsufficientAllowance();\nerror InsufficientBalance();\nerror InsufficientFunds();\nerror NotAllowed();\nerror AlreadyInitialized();\nerror NoReetrancy();\nerror WrongChain();\nerror UnexpectedBalance();\nerror FailToSendNative();\nerror MissingData();\n"
    },
    "contracts/diamond/helpers/Structs.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\nimport { FeeCurrency, FeeType, FeeSyncAction, FeeDeployState } from \"./Enums.sol\";\n\n/// General Fee Config\n\nstruct FeeConfig {\n    // relative: 10000 = 1% or 100 = 0.01%\n    // absolute: 10000 = 1 or 1 = 0.0001\n    uint256 fee;\n    // Assets are always going to the fee distributor on the home chain. This config is necessary to define which receiver gets this asset.\n    // It's purpose can be overwritten by the FeeDistributor. So it will serve as a fallback.\n    address receiver;\n    // defines the type. It does not have a purpose yet but may have in the future\n    // see {Enums->FeeType}\n    FeeType ftype;\n    // type of how the fees should be handles\n    // see {Enums->FeeCurrency}\n    FeeCurrency currency;\n    // // Deploy state of a fee config\n    // // see {Enums->FeeDeployState}\n    // FeeDeployState deployState;\n}\n\n/// Fee Management\n\nstruct AddFeeConfigParams {\n    // fee id which can be defined elsewhere but needs to be a bytes32\n    bytes32 id;\n    // see {struct FeeConfig->fee}\n    uint256 fee;\n    // see {struct FeeConfig->receiver}\n    address receiver;\n    // see {struct FeeConfig->ftype}\n    FeeType ftype;\n    // see {struct FeeConfig->currency}\n    FeeCurrency currency;\n}\n\nstruct UpdateFeeConfigParams {\n    // see {struct AddFeeConfigParams->id}\n    bytes32 id;\n    // see {struct FeeConfig->fee}\n    uint256 fee;\n    // see {struct FeeConfig->fee}\n    address receiver;\n}\n\nstruct RemoveFeeConfigParams {\n    // see {struct AddFeeConfigParams->id}\n    bytes32 id;\n}\n\n/// Chain Management\n\nstruct AddChainParams {\n    // chain id\n    uint256 chainId;\n    // address of the participant, most likely the diamon address of the target chain\n    address target;\n}\nstruct RemoveChainParams {\n    // chain id\n    uint256 chainId;\n}\n\n/// Fee & Chain Management\n\nstruct AssignFeeConfigToChainParams {\n    // fee config id\n    bytes32 id;\n    // chain id to assign the fee config id to\n    uint256 chainId;\n}\nstruct UnassignFeeConfigFromChainParams {\n    // fee config id\n    bytes32 id;\n    // chain id to unassign the fee config id from\n    uint256 chainId;\n}\nstruct UnassignFeeConfigFromAllChainsParams {\n    // fee config id\n    bytes32 id;\n}\n\n/// Syncing\n\nstruct FeeSyncQueue {\n    // fee config id\n    bytes32 id;\n    // chain id\n    uint256 chainId;\n    // action to execute on the target chain\n    FeeSyncAction action;\n}\n\nstruct FeeConfigDeployState {\n    bytes32 id;\n    FeeDeployState state;\n}\n\n/// Data Transfer Objects\n\nstruct FeeConfigSyncDTO {\n    // fee config id\n    bytes32 id;\n    // fee value\n    uint256 fee;\n    // address to make conditional charged based on a specific token\n    // a contract can decide by itself whether to it or not\n    // if defined and used, this fee should be restricted and charged onto a specific token\n    address target;\n    // desired action to execute on the target chain\n    FeeSyncAction action;\n}\nstruct FeeConfigSyncHomeFees {\n    // fee config id\n    bytes32 id;\n    // amount of the collected fees of this if\n    uint256 amount;\n}\nstruct FeeConfigSyncHomeDTO {\n    // total amount of collected fees\n    uint256 totalFees;\n    // address of the bounty receiver on the home chain\n    address bountyReceiver;\n    // containing fee information that will moved to the home chain\n    FeeConfigSyncHomeFees[] fees;\n}\n\nstruct CelerRelayerData {\n    // bytes32 hash which defined the action that should be taken\n    bytes32 what;\n    // address of the contract which what is being executed to\n    address target;\n    // encoded message of the desired scope\n    bytes message;\n}\n\n/// Fee Store\n\nstruct FeeStoreConfig {\n    // fee config id\n    bytes32 id;\n    // fee\n    uint256 fee;\n    // address of the contract which what is being executed to\n    address target;\n    // flag for being markes as deleted\n    bool deleted;\n}\n\n/// Fee Distributor\n\nstruct AddReceiverParams {\n    // public name for the receiver\n    // can be \"Staking\", \"Liquidity Backing\" or whatever\n    string name;\n    // potion of share in points. Points will be summarized in the distribution to calculate the relative share\n    uint64 points;\n    // address of the contract/account that receives the share\n    address account;\n    // swap path in case a share receiver expects another token then the intermediate token of the bridge\n    address[] swapPath;\n}\n"
    },
    "contracts/diamond/interfaces/ICelerFeeHubFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.17;\n\n/// @title CelerFeeHubFacet Interface\n/// @author Daniel <danieldegendev@gmail.com>\ninterface ICelerFeeHubFacet {\n    /// Registers the successful deployment of the fees to the given chain\n    /// @param _chainId chain id\n    /// @param _message encoded message\n    function deployFeesWithCelerConfirm(uint64 _chainId, bytes memory _message) external;\n}\n"
    },
    "contracts/diamond/interfaces/IFeeDistributorFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.17;\n\nimport { FeeConfigSyncHomeDTO } from \"./../helpers/Structs.sol\";\n\n/// @title Fee Distributor Interface\n/// @author Daniel <danieldegendev@gmail.com>\ninterface IFeeDistributorFacet {\n    // this is guarateed to get the tokens before being executed\n\n    /// Pushes the fee to the desired receivers\n    /// @param _token the token address being received\n    /// @param _amount amount of tokens being received\n    /// @param _dto the dto of the fee store to determine the split of _amount\n    /// @dev an updated dto needs to be created since the receiving amount is not\n    ///      matching the sent amount anymore. The contract will 100% receive the\n    ///      _token _amount before being executed\n    /// @dev only available to FEE_DISTRIBUTOR_PUSH_ROLE role\n    /// @dev if the token doesn't match, it will fail.\n    function pushFees(address _token, uint256 _amount, FeeConfigSyncHomeDTO calldata _dto) external payable;\n\n    /// Distributes a single native fee\n    /// @param _feeId id of the fee\n    /// @param _bountyReceiver address of the bounty receiver\n    /// @param _bountyShareInBps percentage share in bps\n    /// @return _amount fee amount that has been paid (excl. bounty)\n    /// @return _bountyAmount bounty that has been paid\n    /// @dev the fee receiver should to have defined a proper swapping path\n    function feeDistributorDepositSingleFeeNative(\n        bytes32 _feeId,\n        address _bountyReceiver,\n        uint256 _bountyShareInBps\n    ) external payable returns (uint256 _amount, uint256 _bountyAmount);\n}\n"
    },
    "contracts/diamond/interfaces/IFeeStoreFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.17;\n\nimport { FeeStoreConfig, FeeConfigSyncDTO, FeeConfigSyncHomeDTO } from \"./../helpers/Structs.sol\";\n\n/// @title Fee Store Facet Interface\n/// @author Daniel <danieldegendev@gmail.com>\ninterface IFeeStoreFacet {\n    /// Synchronizes fee configs\n    /// @param _feeConfigSyncDTO array of fee configs to process in the fee store\n    function syncFees(FeeConfigSyncDTO[] calldata _feeConfigSyncDTO) external payable;\n\n    /// Restores fees which are actually intended to be sent to the home chain\n    /// @param _dto data which is primarily used for sending fees to the home chain\n    function restoreFeesFromSendFees(FeeConfigSyncHomeDTO memory _dto) external payable;\n\n    /// Gets a fee store config based on the fee id\n    /// @param _id fee config id\n    /// @return _feeStoreConfig FeeStoreConfig, see {contracts/diamond/helpers/Structs.sol#FeeStoreConfig}\n    function getFeeStoreConfig(bytes32 _id) external view returns (FeeStoreConfig memory _feeStoreConfig);\n}\n"
    },
    "contracts/diamond/interfaces/IRelayerCeler.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.17;\n\n/// @title Relayer Celer Interface\n/// @author Daniel <danieldegendev@gmail.com>\ninterface IRelayerCeler {\n    /// Deploys the fees to the desired chain\n    /// @param _receiver relayer on target chain\n    /// @param _target diamond address on target chain\n    /// @param _chainId target chain id\n    /// @param _message message to send to the message bus\n    function deployFees(address _receiver, address _target, uint256 _chainId, bytes calldata _message) external payable;\n\n    /// Pre calculates upcoming fees for deploying fees\n    /// @param _target diamond address on target chain\n    /// @param _message message to send to the message bus\n    function deployFeesFeeCalc(address _target, bytes calldata _message) external view returns (uint256 _wei);\n\n    /// Sends the fees to the home chain\n    /// @param _asset asset that get send\n    /// @param _amount amount of assets that gets send\n    /// @param minMaxSlippage calculated slippage by celer\n    /// @param _message message to send to the message bus\n    function sendFees(address _asset, uint256 _amount, uint32 minMaxSlippage, bytes calldata _message) external payable;\n\n    /// Pre calculates upcoming fees for sending fees\n    /// @param _message message to send to the message bus\n    function sendFeesFeeCalc(bytes calldata _message) external view returns (uint256 _wei);\n}\n"
    },
    "contracts/diamond/relayers/RelayerCeler.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.17;\n\nimport { IERC20, SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { Ownable2Step } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { MessageApp, IMessageBus } from \"celer/contracts/message/framework/MessageApp.sol\";\nimport { MsgDataTypes } from \"celer/contracts/message/libraries/MsgDataTypes.sol\";\n\nimport { IFeeDistributorFacet } from \"./../interfaces/IFeeDistributorFacet.sol\";\nimport { ICelerFeeHubFacet } from \"./../interfaces/ICelerFeeHubFacet.sol\";\nimport { IFeeStoreFacet } from \"./../interfaces/IFeeStoreFacet.sol\";\nimport { IRelayerCeler } from \"./../interfaces/IRelayerCeler.sol\";\nimport { ZeroValueNotAllowed, NotAllowed, FailToSendNative } from \"./../helpers/GenericErrors.sol\";\nimport { CelerRelayerData, FeeConfigSyncHomeDTO } from \"./../helpers/Structs.sol\";\nimport { addressZeroCheck } from \"./../helpers/Functions.sol\";\nimport { Constants } from \"./../helpers/Constants.sol\";\n\n/// @title Relayer for CELER IM\n/// @author Daniel <danieldegendev@gmail.com>\n/// @notice this contract will manage the interaction with the IM service of CELER. It can only be called by the message bus or the diamonds on the desired chains\n/// @dev also have a look at https://github.com/celer-network/sgn-v2-contracts/blob/main/contracts/message/framework/MessageApp.sol\n/// @custom:version 1.0.0\ncontract RelayerCeler is IRelayerCeler, MessageApp, Ownable2Step {\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n\n    /// @dev address of the diamond\n    address immutable diamond;\n\n    /// @dev address of the relayer on the home chain\n    address immutable relayerHome;\n\n    /// @dev chain id of the home chain\n    uint256 immutable chainHome;\n\n    /// @dev flag whether this relayer is based on a target chain or a home chain (true=home chain)\n    bool immutable isHomeRelayer;\n\n    /// @notice address of the operator which receives the funds in case every legit execution fails\n    address public operator;\n\n    /// @notice nonce for the transfers being created to avoid duplications\n    uint64 public nonce = 0;\n\n    /// @dev mapping of valid actors from specified chains\n    mapping(uint256 => address) private _actors;\n\n    event RefundForwarded(address asset, address receiver, uint256 amount);\n    event MessageReceived(address srcContract, uint64 srcChainId, bytes message, bool status);\n    event ActorAdded(uint256 chainId, address actor);\n    event ActorRemoved(uint256 chainId);\n\n    error ActorNotExisting();\n    error MissingGasFees();\n\n    modifier onlyDiamondHome() {\n        if (msg.sender != diamond || !isHomeRelayer) revert NotAllowed();\n        _;\n    }\n\n    modifier onlyDiamondTarget() {\n        if (msg.sender != diamond || isHomeRelayer) revert NotAllowed();\n        _;\n    }\n\n    modifier paybackOverhead(address _recipient) {\n        uint256 _balanceBefore = address(this).balance - msg.value;\n        _;\n        uint256 _balanceAfter = address(this).balance;\n        if (_balanceAfter > _balanceBefore) payable(_recipient).sendValue(_balanceAfter - _balanceBefore);\n        else if (_balanceAfter < _balanceBefore) revert MissingGasFees();\n    }\n\n    /// Constructor\n    /// @param _diamond address of the diamond\n    /// @param _relayerHome address of the relayer on the home chain\n    /// @param _operator address of the operator\n    /// @param _messageBus address of the message bus from celer (if update needed, new deployment necessary)\n    /// @param _chainHome chain id of the home chain\n    /// @param _isHomeRelayer flag wheter this contract is deployed on the home chain or target chain\n    /// @dev it also initializes the owner\n    constructor(\n        address _diamond,\n        address _relayerHome,\n        address _operator,\n        address _messageBus,\n        uint256 _chainHome,\n        bool _isHomeRelayer\n    ) MessageApp(_messageBus) Ownable() {\n        diamond = _diamond;\n        relayerHome = _relayerHome;\n        operator = _operator;\n        chainHome = _chainHome;\n        isHomeRelayer = _isHomeRelayer;\n    }\n\n    /// @inheritdoc IRelayerCeler\n    /// @dev can only be executed by the home chain diamond\n    function deployFees(address _receiver, address _target, uint256 _chainId, bytes calldata _message) external payable onlyDiamondHome {\n        CelerRelayerData memory _crd = CelerRelayerData({ what: Constants.RELAYER_ACTION_DEPLOY_FEES, target: _target, message: _message });\n        bytes memory _crdMessage = abi.encode(_crd);\n        uint256 _fee = IMessageBus(messageBus).calcFee(_crdMessage);\n        sendMessage(_receiver, uint64(_chainId), _crdMessage, _fee);\n    }\n\n    /// @inheritdoc IRelayerCeler\n    /// @dev can only be executed by the home chain diamond\n    function deployFeesFeeCalc(address _target, bytes calldata _message) external view onlyDiamondHome returns (uint256 _wei) {\n        CelerRelayerData memory _crd = CelerRelayerData({ what: Constants.RELAYER_ACTION_DEPLOY_FEES, target: _target, message: _message });\n        _wei = IMessageBus(messageBus).calcFee(abi.encode(_crd));\n    }\n\n    /// @inheritdoc IRelayerCeler\n    /// @dev can only be executred bei the target chain diamond\n    function sendFees(address _asset, uint256 _amount, uint32 minMaxSlippage, bytes calldata _message) external payable onlyDiamondTarget {\n        CelerRelayerData memory _crd = CelerRelayerData({\n            what: Constants.RELAYER_ACTION_SEND_FEES,\n            target: address(0),\n            message: _message\n        });\n        bytes memory _crdMessage = abi.encode(_crd);\n        uint256 _fee = IMessageBus(messageBus).calcFee(_crdMessage);\n        _sendMessageWithTransfer(\n            relayerHome,\n            _asset,\n            _amount,\n            uint64(chainHome),\n            nonce,\n            minMaxSlippage,\n            _crdMessage,\n            MsgDataTypes.BridgeSendType.PegV2Burn,\n            _fee\n        );\n        nonce++;\n    }\n\n    /// @inheritdoc IRelayerCeler\n    /// @dev can only be executred bei the target chain diamond\n    function sendFeesFeeCalc(bytes calldata _message) external view onlyDiamondTarget returns (uint256 _wei) {\n        CelerRelayerData memory _crd = CelerRelayerData({\n            what: Constants.RELAYER_ACTION_SEND_FEES,\n            target: address(0),\n            message: _message\n        });\n        _wei = IMessageBus(messageBus).calcFee(abi.encode(_crd));\n    }\n\n    /// Executes the message on the desired chain\n    /// @param _srcContract relayer contract address\n    /// @param _srcChainId chain id of the relayer\n    /// @param _message encoded CelerRelayerData data\n    /// @param _executor trusted account which is configured in the executor\n    /// @dev this is only executed by the message bus from CELER IM\n    function executeMessage(\n        address _srcContract,\n        uint64 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external payable override onlyMessageBus paybackOverhead(_executor) returns (ExecutionStatus) {\n        if (!isActor(_srcChainId, _srcContract)) revert NotAllowed();\n        CelerRelayerData memory _crd = abi.decode(_message, (CelerRelayerData));\n\n        // deploy fees to fee store\n        if (_crd.what == Constants.RELAYER_ACTION_DEPLOY_FEES) {\n            (bool _success, ) = address(_crd.target).call(_crd.message);\n            emit MessageReceived(_srcContract, _srcChainId, _message, _success);\n            if (_success) {\n                // send confirmation with mirrored data\n                CelerRelayerData memory _crdConfirm = CelerRelayerData({\n                    what: Constants.RELAYER_ACTION_DEPLOY_FEES_CONFIRM,\n                    target: address(0),\n                    message: _crd.message\n                });\n                bytes memory _crdMessage = abi.encode(_crdConfirm);\n                uint256 _fee = IMessageBus(messageBus).calcFee(_crdMessage);\n                sendMessage(_srcContract, _srcChainId, _crdMessage, _fee);\n                return ExecutionStatus.Success;\n            }\n        }\n\n        // process confirmation data and execute on celer fee hub facet\n        if (_crd.what == Constants.RELAYER_ACTION_DEPLOY_FEES_CONFIRM) {\n            ICelerFeeHubFacet(diamond).deployFeesWithCelerConfirm(_srcChainId, _crd.message);\n            return ExecutionStatus.Success;\n        }\n\n        return ExecutionStatus.Fail;\n    }\n\n    /// @notice Called by MessageBus to execute a message with an associated token transfer.\n    /// The contract is guaranteed to have received the right amount of tokens before this function is called.\n    /// @param _sender The address of the source app contract\n    /// @param _token The address of the token that comes out of the bridge\n    /// @param _amount The amount of tokens received at this contract through the cross-chain bridge.\n    /// @param _srcChainId The source chain ID where the transfer is originated from\n    /// @param _message Arbitrary message bytes originated from and encoded by the source app contract\n    /// @param _executor trusted account which is configured in the executor\n    function executeMessageWithTransfer(\n        address _sender,\n        address _token,\n        uint256 _amount,\n        uint64 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external payable override onlyMessageBus paybackOverhead(_executor) returns (ExecutionStatus) {\n        if (!isActor(_srcChainId, _sender)) revert NotAllowed();\n        CelerRelayerData memory _crd = abi.decode(_message, (CelerRelayerData));\n\n        // send fees to distributor\n        if (_crd.what == Constants.RELAYER_ACTION_SEND_FEES) {\n            SafeERC20.safeTransfer(IERC20(_token), diamond, _amount);\n            FeeConfigSyncHomeDTO memory _dto = abi.decode((_crd.message), (FeeConfigSyncHomeDTO));\n            IFeeDistributorFacet(diamond).pushFees{ value: msg.value }(_token, _amount, _dto);\n            emit MessageReceived(_sender, _srcChainId, _message, true);\n            return ExecutionStatus.Success;\n        }\n\n        emit MessageReceived(_sender, _srcChainId, _message, false);\n        return ExecutionStatus.Fail;\n    }\n\n    /// @notice Only called by MessageBus if\n    ///         1. executeMessageWithTransfer reverts, or\n    ///         2. executeMessageWithTransfer returns ExecutionStatus.Fail\n    /// The contract is guaranteed to have received the right amount of tokens before this function is called.\n    /// @param _sender The address of the source app contract\n    /// @param _token The address of the token that comes out of the bridge\n    /// @param _amount The amount of tokens received at this contract through the cross-chain bridge.\n    /// @param _srcChainId The source chain ID where the transfer is originated from\n    function executeMessageWithTransferFallback(\n        address _sender,\n        address _token,\n        uint256 _amount,\n        uint64 _srcChainId,\n        bytes calldata,\n        address\n    ) external payable virtual override onlyMessageBus returns (ExecutionStatus) {\n        if (!isActor(_srcChainId, _sender)) revert NotAllowed();\n        try IERC20(_token).transfer(operator, _amount) returns (bool _success) {\n            if (_success) return ExecutionStatus.Success;\n            else return ExecutionStatus.Fail;\n        } catch {\n            return ExecutionStatus.Fail;\n        }\n    }\n\n    /// @notice Called by MessageBus to process refund of the original transfer from this contract.\n    /// The contract is guaranteed to have received the refund before this function is called.\n    /// @param _token The token address of the original transfer\n    /// @param _amount The amount of the original transfer\n    /// @param _message The same message associated with the original transfer\n    function executeMessageWithTransferRefund(\n        address _token,\n        uint256 _amount,\n        bytes calldata _message,\n        address\n    ) external payable override onlyMessageBus returns (ExecutionStatus) {\n        CelerRelayerData memory _crd = abi.decode(_message, (CelerRelayerData));\n        if (_crd.what == Constants.RELAYER_ACTION_SEND_FEES) {\n            IERC20(_token).approve(diamond, _amount);\n            IFeeStoreFacet(diamond).restoreFeesFromSendFees(abi.decode((_crd.message), (FeeConfigSyncHomeDTO)));\n            return ExecutionStatus.Success;\n        }\n        return ExecutionStatus.Fail;\n    }\n\n    /// Payout refund to receiver once token gets stuck\n    /// @param _asset address of token that should be moved from the relayer\n    /// @param _receiver receiver of token\n    /// @param _amount amount of token\n    /// @dev only executeable by the owner\n    function forwardRefund(address _asset, address payable _receiver, uint256 _amount) external onlyOwner {\n        if (_asset == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n            payable(_receiver).sendValue(_amount);\n        } else {\n            SafeERC20.safeTransfer(IERC20(_asset), _receiver, _amount);\n        }\n        emit RefundForwarded(_asset, _receiver, _amount);\n    }\n\n    /// Adds an actor to the relayer\n    /// @param _chainId chain id of the actor\n    /// @param _actor address of the actor\n    /// @dev manage actors that can execute methods of this relayer. Will mostly be relayers from the corresponding chains\n    function addActor(uint256 _chainId, address _actor) external onlyOwner {\n        if (_chainId == 0) revert ZeroValueNotAllowed();\n        addressZeroCheck(_actor);\n        _actors[_chainId] = _actor;\n        emit ActorAdded(_chainId, _actor);\n    }\n\n    /// Removes an actor based on the chain id\n    /// @param _chainId chain id of the actor\n    function removeActor(uint256 _chainId) external onlyOwner {\n        if (_chainId == 0) revert ZeroValueNotAllowed();\n        if (_actors[_chainId] == address(0)) revert ActorNotExisting();\n        delete _actors[_chainId];\n        emit ActorRemoved(_chainId);\n    }\n\n    /// Checks whether an actor is existing or not\n    /// @param _chainId chain id of actor\n    /// @param _actor address of actor\n    /// @return _isActor flag if is actor or not\n    function isActor(uint256 _chainId, address _actor) public view returns (bool _isActor) {\n        _isActor = _chainId != 0 && _actor != address(0) && _actors[_chainId] == _actor;\n    }\n\n    /// internals\n\n    /// @notice Sends a message associated with a transfer to a contract on another chain.\n    /// @param _receiver The address of the destination app contract.\n    /// @param _token The address of the token to be sent.\n    /// @param _amount The amount of tokens to be sent.\n    /// @param _dstChainId The destination chain ID.\n    /// @param _nonce A number input to guarantee uniqueness of transferId. Can be timestamp in practice.\n    /// @param _maxSlippage The max slippage accepted, given as percentage in point (pip). Eg. 5000 means 0.5%.\n    ///        Must be greater than minimalMaxSlippage. Receiver is guaranteed to receive at least\n    ///        (100% - max slippage percentage) * amount or the transfer can be refunded.\n    ///        Only applicable to the {MsgDataTypes.BridgeSendType.Liquidity}.\n    /// @param _message Arbitrary message bytes to be decoded by the destination app contract.\n    ///        If message is empty, only the token transfer will be sent\n    /// @param _bridgeSendType One of the {BridgeSendType} enum.\n    /// @param _fee The fee amount to pay to MessageBus.\n    /// @return _transferId he transfer ID.\n    /// @dev wrapper function to write proper tests without mocking your ass of\n    function _sendMessageWithTransfer(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        uint64 _dstChainId,\n        uint64 _nonce,\n        uint32 _maxSlippage,\n        bytes memory _message,\n        MsgDataTypes.BridgeSendType _bridgeSendType,\n        uint256 _fee\n    ) internal virtual returns (bytes32 _transferId) {\n        _transferId = super.sendMessageWithTransfer(\n            _receiver,\n            _token,\n            _amount,\n            _dstChainId,\n            _nonce,\n            _maxSlippage,\n            _message,\n            _bridgeSendType,\n            _fee\n        );\n    }\n\n    /// receiver\n    receive() external payable {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 99999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}