{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@solidstate/contracts/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Elliptic Curve Digital Signature Algorithm (ECDSA) operations\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nlibrary ECDSA {\n    error ECDSA__InvalidS();\n    error ECDSA__InvalidSignature();\n    error ECDSA__InvalidSignatureLength();\n    error ECDSA__InvalidV();\n\n    /**\n     * @notice recover signer of hashed message from signature\n     * @param hash hashed data payload\n     * @param signature signed data payload\n     * @return recovered message signer\n     */\n    function recover(\n        bytes32 hash,\n        bytes memory signature\n    ) internal pure returns (address) {\n        if (signature.length != 65) revert ECDSA__InvalidSignatureLength();\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        return recover(hash, v, r, s);\n    }\n\n    /**\n     * @notice recover signer of hashed message from signature v, r, and s values\n     * @param hash hashed data payload\n     * @param v signature \"v\" value\n     * @param r signature \"r\" value\n     * @param s signature \"s\" value\n     * @return recovered message signer\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (\n            uint256(s) >\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\n        ) revert ECDSA__InvalidS();\n        if (v != 27 && v != 28) revert ECDSA__InvalidV();\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) revert ECDSA__InvalidSignature();\n\n        return signer;\n    }\n\n    /**\n     * @notice generate an \"Ethereum Signed Message\" in the format returned by the eth_sign JSON-RPC method\n     * @param hash hashed data payload\n     * @return signed message hash\n     */\n    function toEthSignedMessageHash(\n        bytes32 hash\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked('\\x19Ethereum Signed Message:\\n32', hash)\n            );\n    }\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20Internal } from './IERC20Internal.sol';\n\n/**\n * @title ERC20 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-20\n */\ninterface IERC20 is IERC20Internal {\n    /**\n     * @notice query the total minted token supply\n     * @return token supply\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice query the token balance of given account\n     * @param account address to query\n     * @return token balance\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @notice query the allowance granted from given holder to given spender\n     * @param holder approver of allowance\n     * @param spender recipient of allowance\n     * @return token allowance\n     */\n    function allowance(\n        address holder,\n        address spender\n    ) external view returns (uint256);\n\n    /**\n     * @notice grant approval to spender to spend tokens\n     * @dev prefer ERC20Extended functions to avoid transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\n     * @param spender recipient of allowance\n     * @param amount quantity of tokens approved for spending\n     * @return success status (always true; otherwise function should revert)\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @notice transfer tokens to given recipient\n     * @param recipient beneficiary of token transfer\n     * @param amount quantity of tokens to transfer\n     * @return success status (always true; otherwise function should revert)\n     */\n    function transfer(\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @notice transfer tokens to given recipient on behalf of given holder\n     * @param holder holder of tokens prior to transfer\n     * @param recipient beneficiary of token transfer\n     * @param amount quantity of tokens to transfer\n     * @return success status (always true; otherwise function should revert)\n     */\n    function transferFrom(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC20Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Partial ERC20 interface needed by internal functions\n */\ninterface IERC20Internal {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
    },
    "@solidstate/contracts/security/pausable/IPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IPausableInternal } from './IPausableInternal.sol';\n\ninterface IPausable is IPausableInternal {\n    /**\n     * @notice query whether contract is paused\n     * @return status whether contract is paused\n     */\n    function paused() external view returns (bool status);\n}\n"
    },
    "@solidstate/contracts/security/pausable/IPausableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\ninterface IPausableInternal {\n    error Pausable__Paused();\n    error Pausable__NotPaused();\n\n    event Paused(address account);\n    event Unpaused(address account);\n}\n"
    },
    "@solidstate/contracts/security/pausable/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IPausable } from './IPausable.sol';\nimport { PausableInternal } from './PausableInternal.sol';\n\n/**\n * @title Pausable security control module.\n */\nabstract contract Pausable is IPausable, PausableInternal {\n    /**\n     * @inheritdoc IPausable\n     */\n    function paused() external view virtual returns (bool status) {\n        status = _paused();\n    }\n}\n"
    },
    "@solidstate/contracts/security/pausable/PausableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IPausableInternal } from './IPausableInternal.sol';\nimport { PausableStorage } from './PausableStorage.sol';\n\n/**\n * @title Internal functions for Pausable security control module.\n */\nabstract contract PausableInternal is IPausableInternal {\n    modifier whenNotPaused() {\n        if (_paused()) revert Pausable__Paused();\n        _;\n    }\n\n    modifier whenPaused() {\n        if (!_paused()) revert Pausable__NotPaused();\n        _;\n    }\n\n    /**\n     * @notice query whether contract is paused\n     * @return status whether contract is paused\n     */\n    function _paused() internal view virtual returns (bool status) {\n        status = PausableStorage.layout().paused;\n    }\n\n    /**\n     * @notice Triggers paused state, when contract is unpaused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage.layout().paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @notice Triggers unpaused state, when contract is paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        delete PausableStorage.layout().paused;\n        emit Unpaused(msg.sender);\n    }\n}\n"
    },
    "@solidstate/contracts/security/pausable/PausableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary PausableStorage {\n    struct Layout {\n        bool paused;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.Pausable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/base/ERC20Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20 } from '../../../interfaces/IERC20.sol';\nimport { IERC20Base } from './IERC20Base.sol';\nimport { ERC20BaseInternal } from './ERC20BaseInternal.sol';\nimport { ERC20BaseStorage } from './ERC20BaseStorage.sol';\n\n/**\n * @title Base ERC20 implementation, excluding optional extensions\n */\nabstract contract ERC20Base is IERC20Base, ERC20BaseInternal {\n    /**\n     * @inheritdoc IERC20\n     */\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply();\n    }\n\n    /**\n     * @inheritdoc IERC20\n     */\n    function balanceOf(address account) external view returns (uint256) {\n        return _balanceOf(account);\n    }\n\n    /**\n     * @inheritdoc IERC20\n     */\n    function allowance(\n        address holder,\n        address spender\n    ) external view returns (uint256) {\n        return _allowance(holder, spender);\n    }\n\n    /**\n     * @inheritdoc IERC20\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        return _approve(msg.sender, spender, amount);\n    }\n\n    /**\n     * @inheritdoc IERC20\n     */\n    function transfer(\n        address recipient,\n        uint256 amount\n    ) external returns (bool) {\n        return _transfer(msg.sender, recipient, amount);\n    }\n\n    /**\n     * @inheritdoc IERC20\n     */\n    function transferFrom(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) external returns (bool) {\n        return _transferFrom(holder, recipient, amount);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/base/ERC20BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20BaseInternal } from './IERC20BaseInternal.sol';\nimport { ERC20BaseStorage } from './ERC20BaseStorage.sol';\n\n/**\n * @title Base ERC20 internal functions, excluding optional extensions\n */\nabstract contract ERC20BaseInternal is IERC20BaseInternal {\n    /**\n     * @notice query the total minted token supply\n     * @return token supply\n     */\n    function _totalSupply() internal view virtual returns (uint256) {\n        return ERC20BaseStorage.layout().totalSupply;\n    }\n\n    /**\n     * @notice query the token balance of given account\n     * @param account address to query\n     * @return token balance\n     */\n    function _balanceOf(\n        address account\n    ) internal view virtual returns (uint256) {\n        return ERC20BaseStorage.layout().balances[account];\n    }\n\n    /**\n     * @notice query the allowance granted from given holder to given spender\n     * @param holder approver of allowance\n     * @param spender recipient of allowance\n     * @return token allowance\n     */\n    function _allowance(\n        address holder,\n        address spender\n    ) internal view virtual returns (uint256) {\n        return ERC20BaseStorage.layout().allowances[holder][spender];\n    }\n\n    /**\n     * @notice enable spender to spend tokens on behalf of holder\n     * @param holder address on whose behalf tokens may be spent\n     * @param spender recipient of allowance\n     * @param amount quantity of tokens approved for spending\n     * @return success status (always true; otherwise function should revert)\n     */\n    function _approve(\n        address holder,\n        address spender,\n        uint256 amount\n    ) internal virtual returns (bool) {\n        if (holder == address(0)) revert ERC20Base__ApproveFromZeroAddress();\n        if (spender == address(0)) revert ERC20Base__ApproveToZeroAddress();\n\n        ERC20BaseStorage.layout().allowances[holder][spender] = amount;\n\n        emit Approval(holder, spender, amount);\n\n        return true;\n    }\n\n    /**\n     * @notice decrease spend amount granted by holder to spender\n     * @param holder address on whose behalf tokens may be spent\n     * @param spender address whose allowance to decrease\n     * @param amount quantity by which to decrease allowance\n     */\n    function _decreaseAllowance(\n        address holder,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = _allowance(holder, spender);\n\n        if (amount > allowance) revert ERC20Base__InsufficientAllowance();\n\n        unchecked {\n            _approve(holder, spender, allowance - amount);\n        }\n    }\n\n    /**\n     * @notice mint tokens for given account\n     * @param account recipient of minted tokens\n     * @param amount quantity of tokens minted\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        if (account == address(0)) revert ERC20Base__MintToZeroAddress();\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\n        l.totalSupply += amount;\n        l.balances[account] += amount;\n\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @notice burn tokens held by given account\n     * @param account holder of burned tokens\n     * @param amount quantity of tokens burned\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        if (account == address(0)) revert ERC20Base__BurnFromZeroAddress();\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\n        uint256 balance = l.balances[account];\n        if (amount > balance) revert ERC20Base__BurnExceedsBalance();\n        unchecked {\n            l.balances[account] = balance - amount;\n        }\n        l.totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @notice transfer tokens from holder to recipient\n     * @param holder owner of tokens to be transferred\n     * @param recipient beneficiary of transfer\n     * @param amount quantity of tokens transferred\n     * @return success status (always true; otherwise function should revert)\n     */\n    function _transfer(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) internal virtual returns (bool) {\n        if (holder == address(0)) revert ERC20Base__TransferFromZeroAddress();\n        if (recipient == address(0)) revert ERC20Base__TransferToZeroAddress();\n\n        _beforeTokenTransfer(holder, recipient, amount);\n\n        ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\n        uint256 holderBalance = l.balances[holder];\n        if (amount > holderBalance) revert ERC20Base__TransferExceedsBalance();\n        unchecked {\n            l.balances[holder] = holderBalance - amount;\n        }\n        l.balances[recipient] += amount;\n\n        emit Transfer(holder, recipient, amount);\n\n        return true;\n    }\n\n    /**\n     * @notice transfer tokens to given recipient on behalf of given holder\n     * @param holder holder of tokens prior to transfer\n     * @param recipient beneficiary of token transfer\n     * @param amount quantity of tokens to transfer\n     * @return success status (always true; otherwise function should revert)\n     */\n    function _transferFrom(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) internal virtual returns (bool) {\n        _decreaseAllowance(holder, msg.sender, amount);\n\n        _transfer(holder, recipient, amount);\n\n        return true;\n    }\n\n    /**\n     * @notice ERC20 hook, called before all transfers including mint and burn\n     * @dev function should be overridden and new implementation must call super\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param amount quantity of tokens transferred\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@solidstate/contracts/token/ERC20/base/ERC20BaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ERC20BaseStorage {\n    struct Layout {\n        mapping(address => uint256) balances;\n        mapping(address => mapping(address => uint256)) allowances;\n        uint256 totalSupply;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC20Base');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/base/IERC20Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20 } from '../../../interfaces/IERC20.sol';\nimport { IERC20BaseInternal } from './IERC20BaseInternal.sol';\n\n/**\n * @title ERC20 base interface\n */\ninterface IERC20Base is IERC20BaseInternal, IERC20 {\n\n}\n"
    },
    "@solidstate/contracts/token/ERC20/base/IERC20BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20Internal } from '../../../interfaces/IERC20Internal.sol';\n\n/**\n * @title ERC20 base interface\n */\ninterface IERC20BaseInternal is IERC20Internal {\n    error ERC20Base__ApproveFromZeroAddress();\n    error ERC20Base__ApproveToZeroAddress();\n    error ERC20Base__BurnExceedsBalance();\n    error ERC20Base__BurnFromZeroAddress();\n    error ERC20Base__InsufficientAllowance();\n    error ERC20Base__MintToZeroAddress();\n    error ERC20Base__TransferExceedsBalance();\n    error ERC20Base__TransferFromZeroAddress();\n    error ERC20Base__TransferToZeroAddress();\n}\n"
    },
    "@solidstate/contracts/token/ERC20/extended/ERC20Extended.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20Extended } from './IERC20Extended.sol';\nimport { ERC20ExtendedInternal } from './ERC20ExtendedInternal.sol';\n\n/**\n * @title ERC20 safe approval extensions\n * @dev mitigations for transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\n */\nabstract contract ERC20Extended is IERC20Extended, ERC20ExtendedInternal {\n    /**\n     * @inheritdoc IERC20Extended\n     */\n    function increaseAllowance(\n        address spender,\n        uint256 amount\n    ) external returns (bool) {\n        return _increaseAllowance(spender, amount);\n    }\n\n    /**\n     * @inheritdoc IERC20Extended\n     */\n    function decreaseAllowance(\n        address spender,\n        uint256 amount\n    ) external returns (bool) {\n        return _decreaseAllowance(spender, amount);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/extended/ERC20ExtendedInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { ERC20BaseInternal, ERC20BaseStorage } from '../base/ERC20Base.sol';\nimport { IERC20ExtendedInternal } from './IERC20ExtendedInternal.sol';\n\n/**\n * @title ERC20 safe approval extensions\n * @dev mitigations for transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\n */\nabstract contract ERC20ExtendedInternal is\n    ERC20BaseInternal,\n    IERC20ExtendedInternal\n{\n    /**\n     * @notice increase spend amount granted to spender\n     * @param spender address whose allowance to increase\n     * @param amount quantity by which to increase allowance\n     * @return success status (always true; otherwise function will revert)\n     */\n    function _increaseAllowance(\n        address spender,\n        uint256 amount\n    ) internal virtual returns (bool) {\n        uint256 allowance = _allowance(msg.sender, spender);\n\n        unchecked {\n            if (allowance > allowance + amount)\n                revert ERC20Extended__ExcessiveAllowance();\n\n            return _approve(msg.sender, spender, allowance + amount);\n        }\n    }\n\n    /**\n     * @notice decrease spend amount granted to spender\n     * @param spender address whose allowance to decrease\n     * @param amount quantity by which to decrease allowance\n     * @return success status (always true; otherwise function will revert)\n     */\n    function _decreaseAllowance(\n        address spender,\n        uint256 amount\n    ) internal virtual returns (bool) {\n        _decreaseAllowance(msg.sender, spender, amount);\n\n        return true;\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/extended/IERC20Extended.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20ExtendedInternal } from './IERC20ExtendedInternal.sol';\n\n/**\n * @title ERC20 extended interface\n */\ninterface IERC20Extended is IERC20ExtendedInternal {\n    /**\n     * @notice increase spend amount granted to spender\n     * @param spender address whose allowance to increase\n     * @param amount quantity by which to increase allowance\n     * @return success status (always true; otherwise function will revert)\n     */\n    function increaseAllowance(\n        address spender,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @notice decrease spend amount granted to spender\n     * @param spender address whose allowance to decrease\n     * @param amount quantity by which to decrease allowance\n     * @return success status (always true; otherwise function will revert)\n     */\n    function decreaseAllowance(\n        address spender,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@solidstate/contracts/token/ERC20/extended/IERC20ExtendedInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20BaseInternal } from '../base/IERC20BaseInternal.sol';\n\n/**\n * @title ERC20 extended internal interface\n */\ninterface IERC20ExtendedInternal is IERC20BaseInternal {\n    error ERC20Extended__ExcessiveAllowance();\n    error ERC20Extended__InsufficientAllowance();\n}\n"
    },
    "@solidstate/contracts/token/ERC20/ISolidStateERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20Base } from './base/IERC20Base.sol';\nimport { IERC20Extended } from './extended/IERC20Extended.sol';\nimport { IERC20Metadata } from './metadata/IERC20Metadata.sol';\nimport { IERC20Permit } from './permit/IERC20Permit.sol';\n\ninterface ISolidStateERC20 is\n    IERC20Base,\n    IERC20Extended,\n    IERC20Metadata,\n    IERC20Permit\n{}\n"
    },
    "@solidstate/contracts/token/ERC20/metadata/ERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20Metadata } from './IERC20Metadata.sol';\nimport { ERC20MetadataInternal } from './ERC20MetadataInternal.sol';\n\n/**\n * @title ERC20 metadata extensions\n */\nabstract contract ERC20Metadata is IERC20Metadata, ERC20MetadataInternal {\n    /**\n     * @inheritdoc IERC20Metadata\n     */\n    function name() external view returns (string memory) {\n        return _name();\n    }\n\n    /**\n     * @inheritdoc IERC20Metadata\n     */\n    function symbol() external view returns (string memory) {\n        return _symbol();\n    }\n\n    /**\n     * @inheritdoc IERC20Metadata\n     */\n    function decimals() external view returns (uint8) {\n        return _decimals();\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/metadata/ERC20MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20MetadataInternal } from './IERC20MetadataInternal.sol';\nimport { ERC20MetadataStorage } from './ERC20MetadataStorage.sol';\n\n/**\n * @title ERC20Metadata internal functions\n */\nabstract contract ERC20MetadataInternal is IERC20MetadataInternal {\n    /**\n     * @notice return token name\n     * @return token name\n     */\n    function _name() internal view virtual returns (string memory) {\n        return ERC20MetadataStorage.layout().name;\n    }\n\n    /**\n     * @notice return token symbol\n     * @return token symbol\n     */\n    function _symbol() internal view virtual returns (string memory) {\n        return ERC20MetadataStorage.layout().symbol;\n    }\n\n    /**\n     * @notice return token decimals, generally used only for display purposes\n     * @return token decimals\n     */\n    function _decimals() internal view virtual returns (uint8) {\n        return ERC20MetadataStorage.layout().decimals;\n    }\n\n    function _setName(string memory name) internal virtual {\n        ERC20MetadataStorage.layout().name = name;\n    }\n\n    function _setSymbol(string memory symbol) internal virtual {\n        ERC20MetadataStorage.layout().symbol = symbol;\n    }\n\n    function _setDecimals(uint8 decimals) internal virtual {\n        ERC20MetadataStorage.layout().decimals = decimals;\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/metadata/ERC20MetadataStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ERC20MetadataStorage {\n    struct Layout {\n        string name;\n        string symbol;\n        uint8 decimals;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC20Metadata');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/metadata/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20MetadataInternal } from './IERC20MetadataInternal.sol';\n\n/**\n * @title ERC20 metadata interface\n */\ninterface IERC20Metadata is IERC20MetadataInternal {\n    /**\n     * @notice return token name\n     * @return token name\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @notice return token symbol\n     * @return token symbol\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @notice return token decimals, generally used only for display purposes\n     * @return token decimals\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@solidstate/contracts/token/ERC20/metadata/IERC20MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title ERC20 metadata internal interface\n */\ninterface IERC20MetadataInternal {\n\n}\n"
    },
    "@solidstate/contracts/token/ERC20/permit/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\nimport { ERC20Base } from '../base/ERC20Base.sol';\nimport { ERC20Metadata } from '../metadata/ERC20Metadata.sol';\nimport { ERC20PermitInternal } from './ERC20PermitInternal.sol';\nimport { ERC20PermitStorage } from './ERC20PermitStorage.sol';\nimport { IERC2612 } from './IERC2612.sol';\nimport { IERC20Permit } from './IERC20Permit.sol';\n\n/**\n * @title ERC20 extension with support for ERC2612 permits\n * @dev derived from https://github.com/soliditylabs/ERC20-Permit (MIT license)\n */\nabstract contract ERC20Permit is IERC20Permit, ERC20PermitInternal {\n    /**\n     * @inheritdoc IERC2612\n     */\n    function DOMAIN_SEPARATOR()\n        external\n        view\n        returns (bytes32 domainSeparator)\n    {\n        return _DOMAIN_SEPARATOR();\n    }\n\n    /**\n     * @inheritdoc IERC2612\n     */\n    function nonces(address owner) public view returns (uint256) {\n        return _nonces(owner);\n    }\n\n    /**\n     * @inheritdoc IERC2612\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        _permit(owner, spender, amount, deadline, v, r, s);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/permit/ERC20PermitInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\nimport { ECDSA } from '../../../cryptography/ECDSA.sol';\nimport { ERC20BaseInternal } from '../base/ERC20BaseInternal.sol';\nimport { ERC20MetadataInternal } from '../metadata/ERC20MetadataInternal.sol';\nimport { ERC20PermitStorage } from './ERC20PermitStorage.sol';\nimport { IERC20PermitInternal } from './IERC20PermitInternal.sol';\n\n/**\n * @title ERC20 extension with support for ERC2612 permits\n * @dev derived from https://github.com/soliditylabs/ERC20-Permit (MIT license)\n */\nabstract contract ERC20PermitInternal is\n    ERC20BaseInternal,\n    ERC20MetadataInternal,\n    IERC20PermitInternal\n{\n    using ECDSA for bytes32;\n\n    /**\n     * @notice return the EIP-712 domain separator unique to contract and chain\n     * @return domainSeparator domain separator\n     */\n    function _DOMAIN_SEPARATOR()\n        internal\n        view\n        returns (bytes32 domainSeparator)\n    {\n        domainSeparator = ERC20PermitStorage.layout().domainSeparators[\n            _chainId()\n        ];\n\n        if (domainSeparator == 0x00) {\n            domainSeparator = _calculateDomainSeparator();\n        }\n    }\n\n    /**\n     * @notice get the current ERC2612 nonce for the given address\n     * @return current nonce\n     */\n    function _nonces(address owner) internal view returns (uint256) {\n        return ERC20PermitStorage.layout().nonces[owner];\n    }\n\n    /**\n     * @notice calculate unique EIP-712 domain separator\n     * @return domainSeparator domain separator\n     */\n    function _calculateDomainSeparator()\n        internal\n        view\n        returns (bytes32 domainSeparator)\n    {\n        // no need for assembly, running very rarely\n        domainSeparator = keccak256(\n            abi.encode(\n                keccak256(\n                    'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'\n                ),\n                keccak256(bytes(_name())), // ERC-20 Name\n                keccak256(bytes('1')), // Version\n                _chainId(),\n                address(this)\n            )\n        );\n    }\n\n    /**\n     * @notice get the current chain ID\n     * @return chainId chain ID\n     */\n    function _chainId() private view returns (uint256 chainId) {\n        assembly {\n            chainId := chainid()\n        }\n    }\n\n    /**\n     * @notice approve spender to transfer tokens held by owner via signature\n     * @dev this function may be vulnerable to approval replay attacks\n     * @param owner holder of tokens and signer of permit\n     * @param spender beneficiary of approval\n     * @param amount quantity of tokens to approve\n     * @param v secp256k1 'v' value\n     * @param r secp256k1 'r' value\n     * @param s secp256k1 's' value\n     * @dev If https://eips.ethereum.org/EIPS/eip-1344[ChainID] ever changes, the\n     * EIP712 Domain Separator is automatically recalculated.\n     */\n    function _permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal virtual {\n        if (block.timestamp > deadline) revert ERC20Permit__ExpiredDeadline();\n\n        // Assembly for more efficiently computing:\n        // bytes32 hashStruct = keccak256(\n        //   abi.encode(\n        //     _PERMIT_TYPEHASH,\n        //     owner,\n        //     spender,\n        //     amount,\n        //     _nonces[owner].current(),\n        //     deadline\n        //   )\n        // );\n\n        ERC20PermitStorage.Layout storage l = ERC20PermitStorage.layout();\n\n        bytes32 hashStruct;\n        uint256 nonce = l.nonces[owner];\n\n        assembly {\n            // Load free memory pointer\n            let pointer := mload(64)\n\n            // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\n            mstore(\n                pointer,\n                0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9\n            )\n            mstore(add(pointer, 32), owner)\n            mstore(add(pointer, 64), spender)\n            mstore(add(pointer, 96), amount)\n            mstore(add(pointer, 128), nonce)\n            mstore(add(pointer, 160), deadline)\n\n            hashStruct := keccak256(pointer, 192)\n        }\n\n        bytes32 domainSeparator = l.domainSeparators[_chainId()];\n\n        if (domainSeparator == 0x00) {\n            domainSeparator = _calculateDomainSeparator();\n            l.domainSeparators[_chainId()] = domainSeparator;\n        }\n\n        // Assembly for more efficient computing:\n        // bytes32 hash = keccak256(\n        //   abi.encodePacked(uint16(0x1901), domainSeparator, hashStruct)\n        // );\n\n        bytes32 hash;\n\n        assembly {\n            // Load free memory pointer\n            let pointer := mload(64)\n\n            mstore(\n                pointer,\n                0x1901000000000000000000000000000000000000000000000000000000000000\n            ) // EIP191 header\n            mstore(add(pointer, 2), domainSeparator) // EIP712 domain hash\n            mstore(add(pointer, 34), hashStruct) // Hash of struct\n\n            hash := keccak256(pointer, 66)\n        }\n\n        address signer = hash.recover(v, r, s);\n\n        if (signer != owner) revert ERC20Permit__InvalidSignature();\n\n        l.nonces[owner]++;\n        _approve(owner, spender, amount);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/permit/ERC20PermitStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ERC20PermitStorage {\n    struct Layout {\n        mapping(address => uint256) nonces;\n        // Mapping of ChainID to domain separators. This is a very gas efficient way\n        // to not recalculate the domain separator on every call, while still\n        // automatically detecting ChainID changes.\n        mapping(uint256 => bytes32) domainSeparators;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC20Permit');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/permit/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20Metadata } from '../metadata/IERC20Metadata.sol';\nimport { IERC2612 } from './IERC2612.sol';\nimport { IERC20PermitInternal } from './IERC20PermitInternal.sol';\n\n// TODO: note that IERC20Metadata is needed for eth-permit library\n\ninterface IERC20Permit is IERC20PermitInternal, IERC2612 {\n\n}\n"
    },
    "@solidstate/contracts/token/ERC20/permit/IERC20PermitInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC2612Internal } from './IERC2612Internal.sol';\n\ninterface IERC20PermitInternal is IERC2612Internal {\n    error ERC20Permit__ExpiredDeadline();\n    error ERC20Permit__InvalidSignature();\n}\n"
    },
    "@solidstate/contracts/token/ERC20/permit/IERC2612.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC2612Internal } from './IERC2612Internal.sol';\n\n/**\n * @title ERC2612 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-2612.\n */\ninterface IERC2612 is IERC2612Internal {\n    /**\n     * @notice return the EIP-712 domain separator unique to contract and chain\n     * @return domainSeparator domain separator\n     */\n    function DOMAIN_SEPARATOR() external view returns (bytes32 domainSeparator);\n\n    /**\n     * @notice get the current ERC2612 nonce for the given address\n     * @return current nonce\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @notice approve spender to transfer tokens held by owner via signature\n     * @dev this function may be vulnerable to approval replay attacks\n     * @param owner holder of tokens and signer of permit\n     * @param spender beneficiary of approval\n     * @param amount quantity of tokens to approve\n     * @param v secp256k1 'v' value\n     * @param r secp256k1 'r' value\n     * @param s secp256k1 's' value\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "@solidstate/contracts/token/ERC20/permit/IERC2612Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\ninterface IERC2612Internal {}\n"
    },
    "@solidstate/contracts/token/ERC20/SolidStateERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { ISolidStateERC20 } from './ISolidStateERC20.sol';\nimport { ERC20Base } from './base/ERC20Base.sol';\nimport { ERC20Extended } from './extended/ERC20Extended.sol';\nimport { ERC20Metadata } from './metadata/ERC20Metadata.sol';\nimport { ERC20Permit } from './permit/ERC20Permit.sol';\n\n/**\n * @title SolidState ERC20 implementation, including recommended extensions\n */\nabstract contract SolidStateERC20 is\n    ISolidStateERC20,\n    ERC20Base,\n    ERC20Extended,\n    ERC20Metadata,\n    ERC20Permit\n{\n\n}\n"
    },
    "@solidstate/contracts/utils/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { UintUtils } from './UintUtils.sol';\n\nlibrary AddressUtils {\n    using UintUtils for uint256;\n\n    error AddressUtils__InsufficientBalance();\n    error AddressUtils__NotContract();\n    error AddressUtils__SendValueFailed();\n\n    function toString(address account) internal pure returns (string memory) {\n        return uint256(uint160(account)).toHexString(20);\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendValue(address payable account, uint256 amount) internal {\n        (bool success, ) = account.call{ value: amount }('');\n        if (!success) revert AddressUtils__SendValueFailed();\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data\n    ) internal returns (bytes memory) {\n        return\n            functionCall(target, data, 'AddressUtils: failed low-level call');\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory error\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, error);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                'AddressUtils: failed low-level call with value'\n            );\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) internal returns (bytes memory) {\n        if (value > address(this).balance)\n            revert AddressUtils__InsufficientBalance();\n        return _functionCallWithValue(target, data, value, error);\n    }\n\n    /**\n     * @notice execute arbitrary external call with limited gas usage and amount of copied return data\n     * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\n     * @param target recipient of call\n     * @param gasAmount gas allowance for call\n     * @param value native token value to include in call\n     * @param maxCopy maximum number of bytes to copy from return data\n     * @param data encoded call data\n     * @return success whether call is successful\n     * @return returnData copied return data\n     */\n    function excessivelySafeCall(\n        address target,\n        uint256 gasAmount,\n        uint256 value,\n        uint16 maxCopy,\n        bytes memory data\n    ) internal returns (bool success, bytes memory returnData) {\n        returnData = new bytes(maxCopy);\n\n        assembly {\n            // execute external call via assembly to avoid automatic copying of return data\n            success := call(\n                gasAmount,\n                target,\n                value,\n                add(data, 0x20),\n                mload(data),\n                0,\n                0\n            )\n\n            // determine whether to limit amount of data to copy\n            let toCopy := returndatasize()\n\n            if gt(toCopy, maxCopy) {\n                toCopy := maxCopy\n            }\n\n            // store the length of the copied bytes\n            mstore(returnData, toCopy)\n\n            // copy the bytes from returndata[0:toCopy]\n            returndatacopy(add(returnData, 0x20), 0, toCopy)\n        }\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) private returns (bytes memory) {\n        if (!isContract(target)) revert AddressUtils__NotContract();\n\n        (bool success, bytes memory returnData) = target.call{ value: value }(\n            data\n        );\n\n        if (success) {\n            return returnData;\n        } else if (returnData.length > 0) {\n            assembly {\n                let returnData_size := mload(returnData)\n                revert(add(32, returnData), returnData_size)\n            }\n        } else {\n            revert(error);\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20 } from '../interfaces/IERC20.sol';\nimport { AddressUtils } from './AddressUtils.sol';\n\n/**\n * @title Safe ERC20 interaction library\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nlibrary SafeERC20 {\n    using AddressUtils for address;\n\n    error SafeERC20__ApproveFromNonZeroToNonZero();\n    error SafeERC20__DecreaseAllowanceBelowZero();\n    error SafeERC20__OperationFailed();\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    /**\n     * @dev safeApprove (like approve) should only be called when setting an initial allowance or when resetting it to zero; otherwise prefer safeIncreaseAllowance and safeDecreaseAllowance\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        if ((value != 0) && (token.allowance(address(this), spender) != 0))\n            revert SafeERC20__ApproveFromNonZeroToNonZero();\n\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.approve.selector, spender, value)\n        );\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            if (oldAllowance < value)\n                revert SafeERC20__DecreaseAllowanceBelowZero();\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(\n                token,\n                abi.encodeWithSelector(\n                    token.approve.selector,\n                    spender,\n                    newAllowance\n                )\n            );\n        }\n    }\n\n    /**\n     * @notice send transaction data and check validity of return value, if present\n     * @param token ERC20 token interface\n     * @param data transaction data\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(\n            data,\n            'SafeERC20: low-level call failed'\n        );\n\n        if (returndata.length > 0) {\n            if (!abi.decode(returndata, (bool)))\n                revert SafeERC20__OperationFailed();\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/utils/UintUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title utility functions for uint256 operations\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nlibrary UintUtils {\n    error UintUtils__InsufficientHexLength();\n\n    bytes16 private constant HEX_SYMBOLS = '0123456789abcdef';\n\n    function add(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? sub(a, -b) : a + uint256(b);\n    }\n\n    function sub(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? add(a, -b) : a - uint256(b);\n    }\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0';\n        }\n\n        uint256 temp = value;\n        uint256 digits;\n\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n\n        bytes memory buffer = new bytes(digits);\n\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n\n        return string(buffer);\n    }\n\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0x00';\n        }\n\n        uint256 length = 0;\n\n        for (uint256 temp = value; temp != 0; temp >>= 8) {\n            unchecked {\n                length++;\n            }\n        }\n\n        return toHexString(value, length);\n    }\n\n    function toHexString(\n        uint256 value,\n        uint256 length\n    ) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n\n        unchecked {\n            for (uint256 i = 2 * length + 1; i > 1; --i) {\n                buffer[i] = HEX_SYMBOLS[value & 0xf];\n                value >>= 4;\n            }\n        }\n\n        if (value != 0) revert UintUtils__InsufficientHexLength();\n\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/diamond/facets/ERC20Facet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.19;\n\nimport { SolidStateERC20 } from \"@solidstate/contracts/token/ERC20/SolidStateERC20.sol\";\nimport { Pausable } from \"@solidstate/contracts/security/pausable/Pausable.sol\";\nimport { IERC20 } from \"@solidstate/contracts/interfaces/IERC20.sol\";\n\nimport { IERC20Facet } from \"../interfaces/IERC20Facet.sol\";\nimport { LibAccessControlEnumerable } from \"../libraries/LibAccessControlEnumerable.sol\";\nimport { LibFeeStoreStorage } from \"../libraries/LibFeeStoreStorage.sol\";\nimport { LibFeeStore } from \"../libraries/LibFeeStore.sol\";\nimport { NotAllowed } from \"../helpers/GenericErrors.sol\";\nimport { Constants } from \"../helpers/Constants.sol\";\n\n/// @title ERC20 Token Facet\n/// @author Daniel <danieldegendev@gmail.com>\n/// @notice Provides the functionality of an ERC20 token to an EIP-2535 based diamond\n/// @custom:version 1.0.0\ncontract ERC20Facet is SolidStateERC20, Pausable, IERC20Facet {\n    /// Storage Slot\n    bytes32 internal constant ERC20_FACET_STORAGE_SLOT = keccak256(\"degenx.erc20.storage.v1\");\n\n    event SetLP(address lp);\n    event ExcludeAccountFromTax(address account);\n    event IncludeAccountToTax(address account);\n    event FeeAdded(bytes32 id, bool buyFee);\n    event FeeRemoved(bytes32 id, bool buyFee);\n\n    error FeeIdAlreadySet(bytes32 id);\n    error FeeIdNotSet(bytes32 id);\n    error FeeIdMissing();\n    error InvalidFeeId(bytes32 id);\n    error NoBurnPossible();\n\n    /// @param lp The address of the liquidity pool of this token (will only have one pool for now)\n    /// @param isMinter A flag that defines if the current executor is in a mint process (only allowed minters)\n    /// @param isBurner A flag that defines if the current executor is in a burn process (only allowed burners)\n    /// @param initialized A flag that defines if the contract is initialized already\n    /// @param buyFee An array of bytes32 to configure buy fee ids\n    /// @param sellFee An array of bytes32 to configure sell fee ids\n    /// @param excludes A map of addresses which can get flagged to be from paying fees\n    /// @param fees A map of fee ids to its charged amounts\n    struct ERC20FacetStorage {\n        address lp;\n        bool isMinter;\n        bool isBurner;\n        bool initialized;\n        bytes32[] buyFee;\n        bytes32[] sellFee;\n        mapping(address => bool) excludes;\n        mapping(bytes32 => uint256) fees;\n    }\n\n    /// Initializes the contract\n    /// @param __name The name of the token\n    /// @param __symbol The symbol of the token\n    /// @param __decimals The number of decimals of the token\n    function initERC20Facet(string calldata __name, string calldata __symbol, uint8 __decimals) external {\n        LibAccessControlEnumerable.checkRole(Constants.DEPLOYER_ROLE);\n        ERC20FacetStorage storage s = _store();\n        if (s.initialized) revert(\"initialized\");\n        _pause();\n        _setName(__name);\n        _setSymbol(__symbol);\n        _setDecimals(__decimals);\n        s.initialized = true;\n    }\n\n    /// @inheritdoc IERC20Facet\n    function mint(address _to, uint256 _amount) external {\n        LibAccessControlEnumerable.checkRole(Constants.MINTER_ROLE);\n        ERC20FacetStorage storage s = _store();\n        s.isMinter = true;\n        _mint(_to, _amount);\n        s.isMinter = false;\n    }\n\n    /// @inheritdoc IERC20Facet\n    function burn(address _from, uint256 _amount) external {\n        LibAccessControlEnumerable.checkRole(Constants.BURNER_ROLE);\n        ERC20FacetStorage storage s = _store();\n        s.isBurner = true;\n        _burn(_from, _amount);\n        s.isBurner = false;\n    }\n\n    /// @inheritdoc IERC20Facet\n    function enable() external {\n        LibAccessControlEnumerable.checkRole(Constants.ADMIN_ROLE);\n        _unpause();\n    }\n\n    /// @inheritdoc IERC20Facet\n    function disable() external {\n        LibAccessControlEnumerable.checkRole(Constants.ADMIN_ROLE);\n        _pause();\n    }\n\n    /// @inheritdoc IERC20Facet\n    function setLP(address _lp) external {\n        LibAccessControlEnumerable.checkRole(Constants.ADMIN_ROLE);\n        ERC20FacetStorage storage s = _store();\n        s.lp = _lp;\n        emit SetLP(_lp);\n    }\n\n    /// @inheritdoc IERC20Facet\n    function excludeAccountFromTax(address _account) external {\n        LibAccessControlEnumerable.checkRole(Constants.ADMIN_ROLE);\n        ERC20FacetStorage storage s = _store();\n        s.excludes[_account] = true;\n        emit ExcludeAccountFromTax(_account);\n    }\n\n    /// @inheritdoc IERC20Facet\n    function includeAccountForTax(address _account) external {\n        LibAccessControlEnumerable.checkRole(Constants.ADMIN_ROLE);\n        ERC20FacetStorage storage s = _store();\n        delete s.excludes[_account];\n        emit IncludeAccountToTax(_account);\n    }\n\n    /// Adds a buy fee based on a fee id\n    /// @param _id fee id\n    function addBuyFee(bytes32 _id) external {\n        _addFee(_id, true);\n    }\n\n    /// Removes a buy fee based on a fee id\n    /// @param _id fee id\n    function removeBuyFee(bytes32 _id) external {\n        _removeFee(_id, true);\n    }\n\n    /// Adds a sell fee based on a fee id\n    /// @param _id fee id\n    function addSellFee(bytes32 _id) external {\n        _addFee(_id, false);\n    }\n\n    /// Removes a sell fee based on a fee id\n    /// @param _id fee id\n    function removeSellFee(bytes32 _id) external {\n        _removeFee(_id, false);\n    }\n\n    /// viewables\n\n    /// Checks if an account is whether excluded from paying fees or not\n    /// @param _account account to check\n    function isExcluded(address _account) external view returns (bool _isExcluded) {\n        ERC20FacetStorage storage s = _store();\n        _isExcluded = s.excludes[_account];\n    }\n\n    /// Checks whether a fee id is a buy fee or not\n    /// @param _id fee id\n    function isBuyFee(bytes32 _id) external view returns (bool _itis) {\n        _itis = _isFee(_id, true);\n    }\n\n    /// Check whether a fee id is a sell fee or not\n    /// @param _id fee id\n    function isSellFee(bytes32 _id) external view returns (bool _itis) {\n        _itis = _isFee(_id, false);\n    }\n\n    /// Returns the address of the currently set liquidity pool\n    /// @return _lp address of the liquidity pool\n    function getLP() external view returns (address _lp) {\n        ERC20FacetStorage storage s = _store();\n        _lp = s.lp;\n    }\n\n    /// Returns all buy fee ids\n    /// @return _fees array of fee ids\n    function getBuyFees() external view returns (bytes32[] memory _fees) {\n        ERC20FacetStorage storage s = _store();\n        _fees = s.buyFee;\n    }\n\n    /// Returns all sell fee ids\n    /// @return _fees array of fee ids\n    function getSellFees() external view returns (bytes32[] memory _fees) {\n        ERC20FacetStorage storage s = _store();\n        _fees = s.sellFee;\n    }\n\n    /// internals\n\n    /// Returns if a fee is an actual fee from the buy fees or from the sell fees\n    /// @param _id fee id\n    /// @param _isBuyFee flag to decide whether it is a buy fee or not\n    /// @return _itis returns true if it is a fee\n    function _isFee(bytes32 _id, bool _isBuyFee) internal view returns (bool _itis) {\n        ERC20FacetStorage storage s = _store();\n        bytes32[] storage _fees = _isBuyFee ? s.buyFee : s.sellFee;\n        for (uint256 i = 0; i < _fees.length; ) {\n            if (_fees[i] == _id) {\n                _itis = true;\n                break;\n            }\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// Adds a fee based on a fee id and a flag if it should be added as buy fee or sell fee\n    /// @param _id fee id\n    /// @param _isBuyFee flag if fee id should be processed as buy fee or sell fee\n    function _addFee(bytes32 _id, bool _isBuyFee) internal {\n        LibAccessControlEnumerable.checkRole(Constants.ADMIN_ROLE);\n        ERC20FacetStorage storage s = _store();\n        LibFeeStoreStorage.FeeStoreStorage storage feeStore = LibFeeStoreStorage.feeStoreStorage();\n        if (_id == bytes32(\"\")) revert FeeIdMissing();\n        if (feeStore.feeConfigs[_id].id != _id) revert InvalidFeeId(_id);\n        bytes32[] storage _fees = _isBuyFee ? s.buyFee : s.sellFee;\n        for (uint256 i = 0; i < _fees.length; ) {\n            if (_fees[i] == _id) revert FeeIdAlreadySet(_id);\n            unchecked {\n                i++;\n            }\n        }\n        _fees.push(_id);\n        emit FeeAdded(_id, _isBuyFee);\n    }\n\n    /// Removes a fee based on a fee id and a flag if it should be removed as buy fee or sell fee\n    /// @param _id fee id\n    /// @param _isBuyFee flag if fee id should be processed as buy fee or sell fee\n    function _removeFee(bytes32 _id, bool _isBuyFee) internal {\n        LibAccessControlEnumerable.checkRole(Constants.ADMIN_ROLE);\n        ERC20FacetStorage storage s = _store();\n        if (!_isFee(_id, _isBuyFee)) revert FeeIdNotSet(_id);\n        bytes32[] storage _fees = _isBuyFee ? s.buyFee : s.sellFee;\n        for (uint256 i = 0; i < _fees.length; ) {\n            if (_fees[i] == _id) _fees[i] = _fees[_fees.length - 1];\n            unchecked {\n                i++;\n            }\n        }\n        _fees.pop();\n        emit FeeRemoved(_id, _isBuyFee);\n    }\n\n    /// @notice The execution is successful when the contract is enabled.\n    ///         Furthermore it will also check if the receiver address is a burn address,\n    ///         so it will be prevented from burning by a unallowed account.\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override whenNotPaused {\n        super._beforeTokenTransfer(from, to, amount);\n        ERC20FacetStorage storage s = _store();\n        if (!s.isBurner && to == address(0xdEaD)) {\n            revert NoBurnPossible();\n        }\n    }\n\n    /// Transfers the token from one address to another\n    /// @param _from holder address\n    /// @param _to receiver address\n    /// @param _amount amount of tokens to transfer\n    /// @notice During this process, it will be checked if the provided address are a liquidity pool address and then\n    ///         being marked as a buy transfer or sell transfer. During a buy or sell, desired fees will be charged.\n    ///         But only if non of the addresses is excluded from the fees and the router is set. Since swapping tokens\n    ///         during a buy process, it will be only done in a sell process. The charged fees are getting cut of from\n    ///         the initial amount of tokens and the rest is getting transfered.\n    function _transfer(address _from, address _to, uint256 _amount) internal override returns (bool) {\n        ERC20FacetStorage storage s = _store();\n        bool isBuy = s.lp == _from;\n        bool isSell = s.lp == _to;\n        if ((isBuy || isSell) && !s.excludes[_from] && !s.excludes[_to]) {\n            uint256 _totalFee = 0;\n            bytes32[] storage _fees = isBuy ? s.buyFee : s.sellFee;\n            for (uint256 i = 0; i < _fees.length; ) {\n                (, uint256 _singleFee, ) = LibFeeStore.calcFeesRelative(_fees[i], address(this), _amount);\n                LibFeeStore.putFees(_fees[i], _singleFee);\n                _totalFee += _singleFee;\n                unchecked {\n                    i++;\n                }\n            }\n            if (_totalFee > 0) {\n                super._transfer(_from, address(this), _totalFee);\n                _amount -= _totalFee;\n            }\n        }\n        return super._transfer(_from, _to, _amount);\n    }\n\n    /// @dev Store\n    function _store() internal pure returns (ERC20FacetStorage storage _s) {\n        bytes32 slot = ERC20_FACET_STORAGE_SLOT;\n        assembly {\n            _s.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/diamond/helpers/Constants.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\nlibrary Constants {\n    /*-------------------------------- Role --------------------------------*/\n    // 0x0000000000000000000000000000000000000000000000000000000000000000\n    bytes32 constant DEFAULT_ADMIN_ROLE = 0x00;\n    // 0xa49807205ce4d355092ef5a8a18f56e8913cf4a201fbe287825b095693c21775\n    bytes32 constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    // 0xfc425f2263d0df187444b70e47283d622c70181c5baebb1306a01edba1ce184c\n    bytes32 constant DEPLOYER_ROLE = keccak256(\"DEPLOYER_ROLE\");\n    // 0x6c0757dc3e6b28b2580c03fd9e96c274acf4f99d91fbec9b418fa1d70604ff1c\n    bytes32 constant FEE_MANAGER_ROLE = keccak256(\"FEE_MANAGER_ROLE\");\n    // 0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6\n    bytes32 constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    // 0x3c11d16cbaffd01df69ce1c404f6340ee057498f5f00246190ea54220576a848\n    bytes32 constant BURNER_ROLE = keccak256(\"BURNER_ROLE\");\n    // 0x63eb04268b235ac1afacf3bcf4b19c5c175d0417a1555fb3ff79ae190f71ee7c\n    bytes32 constant FEE_STORE_MANAGER_ROLE = keccak256(\"FEE_STORE_MANAGER_ROLE\");\n    // 0x77f52ccf2f32e71a0cff8f14ad8c8303b7d2e4c7609b8fba963114f4db2af767\n    bytes32 constant FEE_DISTRIBUTOR_PUSH_ROLE = keccak256(\"FEE_DISTRIBUTOR_PUSH_ROLE\");\n    // 0xe85d5f1f8338cb18f500856d1568d0f3b0d0971f25b3ccd134475e991354edbf\n    bytes32 constant FEE_DISTRIBUTOR_MANAGER = keccak256(\"FEE_DISTRIBUTOR_MANAGER\");\n    /*----------------------------------------------------------------------*/\n\n    /*------------------------------- Fee ID -------------------------------*/\n    // 0xacfc432e98ad100d9f8c385f3782bc88a17e1de7e53f69678cbcc41e8ffe72b0\n    bytes32 constant ERC20_MARKETING_FEE = keccak256(\"ERC20_MARKETING_FEE\");\n    // 0x6b78196f16f828b24a5a6584d4a1bcc5ce2f3154ba57839db273e6a4ebbe92c2\n    bytes32 constant ERC20_REWARD_FEE = keccak256(\"ERC20_REWARD_FEE\");\n    // 0x6e3678bee6f77c8a6179922c9a518b08407e6d9d2593ac683a87c979c8b31a12\n    bytes32 constant ERC20_PLATFORM_FEE = keccak256(\"ERC20_PLATFORM_FEE\");\n    // 0x6e2178bb28988b4c92cd3092e9e342e7639bfda2f68a02ac478cb084759607cf\n    bytes32 constant ERC20_DEVELOPER_FEE = keccak256(\"ERC20_DEVELOPER_FEE\");\n    /*----------------------------------------------------------------------*/\n\n    /*--------------------------- Relayer Actions --------------------------*/\n    // 0xf145583e6e33d9da99af75b579493b11db4229a339336b82c748312f152b29a9\n    bytes32 constant RELAYER_ACTION_DEPLOY_FEES = keccak256(\"RELAYER_ACTION_DEPLOY_FEES\");\n    // 0xf375f410a0dc135af0d9a16e273eac999064981d8813a68af762e93567a43aac\n    bytes32 constant RELAYER_ACTION_DEPLOY_FEES_CONFIRM = keccak256(\"RELAYER_ACTION_DEPLOY_FEES_CONFIRM\");\n    // 0x9d62257b25ea052fe7cd5123fd6b791268b8673b073aae5de4a823c4dc7d7607\n    bytes32 constant RELAYER_ACTION_SEND_FEES = keccak256(\"RELAYER_ACTION_SEND_FEES\");\n    /*----------------------------------------------------------------------*/\n}\n"
    },
    "contracts/diamond/helpers/Enums.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\n/// enums\nenum FeeCurrency {\n    Null,\n    // L1\n    Native,\n    // different asset\n    Token\n}\n\nenum FeeType {\n    Null,\n    // absolute/onetime\n    Default,\n    // buy/sell depending on target\n    From,\n    // buy/sell depending on target\n    To\n}\n\nenum FeeSyncAction {\n    Null,\n    // adding a fee\n    Add,\n    // updating a fee\n    Update,\n    // removing a fee\n    Delete\n}\n\nenum FeeDeployState {\n    Null,\n    // a fee is recently added, updated or removed\n    Queued,\n    // a fee config is deployed\n    Pending,\n    // a fee gets receives information about being deployed\n    Deployed\n}\n"
    },
    "contracts/diamond/helpers/GenericErrors.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\nerror AddressZero();\nerror ZeroValueNotAllowed();\nerror InsufficientAllowance();\nerror InsufficientBalance();\nerror InsufficientFunds();\nerror NotAllowed();\nerror AlreadyInitialized();\nerror NoReetrancy();\nerror WrongChain();\nerror UnexpectedBalance();\nerror FailToSendNative();\n"
    },
    "contracts/diamond/helpers/Structs.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\nimport { FeeCurrency, FeeType, FeeSyncAction, FeeDeployState } from \"./Enums.sol\";\n\n/// General Fee Config\n\nstruct FeeConfig {\n    // relative: 10000 = 1% or 100 = 0.01%\n    // absolute: 10000 = 1 or 1 = 0.0001\n    uint256 fee;\n    // Assets are always going to the fee distributor on the home chain. This config is necessary to define which receiver gets this asset.\n    // It's purpose can be overwritten by the FeeDistributor. So it will serve as a fallback.\n    address receiver;\n    // defines the type. It does not have a purpose yet but may have in the future\n    // see {Enums->FeeType}\n    FeeType ftype;\n    // type of how the fees should be handles\n    // see {Enums->FeeCurrency}\n    FeeCurrency currency;\n    // // Deploy state of a fee config\n    // // see {Enums->FeeDeployState}\n    // FeeDeployState deployState;\n}\n\n/// Fee Management\n\nstruct AddFeeConfigParams {\n    // fee id which can be defined elsewhere but needs to be a bytes32\n    bytes32 id;\n    // see {struct FeeConfig->fee}\n    uint256 fee;\n    // see {struct FeeConfig->receiver}\n    address receiver;\n    // see {struct FeeConfig->ftype}\n    FeeType ftype;\n    // see {struct FeeConfig->currency}\n    FeeCurrency currency;\n}\n\nstruct UpdateFeeConfigParams {\n    // see {struct AddFeeConfigParams->id}\n    bytes32 id;\n    // see {struct FeeConfig->fee}\n    uint256 fee;\n    // see {struct FeeConfig->fee}\n    address receiver;\n}\n\nstruct RemoveFeeConfigParams {\n    // see {struct AddFeeConfigParams->id}\n    bytes32 id;\n}\n\n/// Chain Management\n\nstruct AddChainParams {\n    // chain id\n    uint256 chainId;\n    // address of the participant, most likely the diamon address of the target chain\n    address target;\n}\nstruct RemoveChainParams {\n    // chain id\n    uint256 chainId;\n}\n\n/// Fee & Chain Management\n\nstruct AssignFeeConfigToChainParams {\n    // fee config id\n    bytes32 id;\n    // chain id to assign the fee config id to\n    uint256 chainId;\n}\nstruct UnassignFeeConfigFromChainParams {\n    // fee config id\n    bytes32 id;\n    // chain id to unassign the fee config id from\n    uint256 chainId;\n}\nstruct UnassignFeeConfigFromAllChainsParams {\n    // fee config id\n    bytes32 id;\n}\n\n/// Syncing\n\nstruct FeeSyncQueue {\n    // fee config id\n    bytes32 id;\n    // chain id\n    uint256 chainId;\n    // action to execute on the target chain\n    FeeSyncAction action;\n}\n\nstruct FeeConfigDeployState {\n    bytes32 id;\n    FeeDeployState state;\n}\n\n/// Data Transfer Objects\n\nstruct FeeConfigSyncDTO {\n    // fee config id\n    bytes32 id;\n    // fee value\n    uint256 fee;\n    // address to make conditional charged based on a specific token\n    // a contract can decide by itself whether to it or not\n    // if defined and used, this fee should be restricted and charged onto a specific token\n    address target;\n    // desired action to execute on the target chain\n    FeeSyncAction action;\n}\nstruct FeeConfigSyncHomeFees {\n    // fee config id\n    bytes32 id;\n    // amount of the collected fees of this if\n    uint256 amount;\n}\nstruct FeeConfigSyncHomeDTO {\n    // total amount of collected fees\n    uint256 totalFees;\n    // address of the bounty receiver on the home chain\n    address bountyReceiver;\n    // containing fee information that will moved to the home chain\n    FeeConfigSyncHomeFees[] fees;\n}\n\nstruct CelerRelayerData {\n    // bytes32 hash which defined the action that should be taken\n    bytes32 what;\n    // address of the contract which what is being executed to\n    address target;\n    // encoded message of the desired scope\n    bytes message;\n}\n\n/// Fee Store\n\nstruct FeeStoreConfig {\n    // fee config id\n    bytes32 id;\n    // fee\n    uint256 fee;\n    // address of the contract which what is being executed to\n    address target;\n    // flag for being markes as deleted\n    bool deleted;\n}\n\n/// Fee Distributor\n\nstruct AddReceiverParams {\n    // public name for the receiver\n    // can be \"Staking\", \"Liquidity Backing\" or whatever\n    string name;\n    // potion of share in points. Points will be summarized in the distribution to calculate the relative share\n    uint64 points;\n    // address of the contract/account that receives the share\n    address account;\n    // swap path in case a share receiver expects another token then the intermediate token of the bridge\n    address[] swapPath;\n}\n"
    },
    "contracts/diamond/interfaces/IERC20Facet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.19;\n\n/// @title ERC20 Facet Interface\n/// @author Daniel <danieldegendev@gmail.com>\ninterface IERC20Facet {\n    /// Minting an amount of tokens for a designated receiver\n    /// @param _to receiver address of the token\n    /// @param _amount receiving amount\n    /// @notice This can only be executed by the MINTER_ROLE which will be bridge related contracts\n    function mint(address _to, uint256 _amount) external;\n\n    /// Burning an amount of tokens from a designated holder\n    /// @param _from holder address to burn the tokens from\n    /// @param _amount burnable amount\n    function burn(address _from, uint256 _amount) external;\n\n    /// @notice This enables the transfers of this tokens\n    function enable() external;\n\n    /// @notice This disables the transfers of this tokens\n    function disable() external;\n\n    /// Exclude an account from being charged on fees\n    /// @param _account address to exclude\n    function excludeAccountFromTax(address _account) external;\n\n    /// Includes an account againt to pay fees\n    /// @param _account address to include\n    function includeAccountForTax(address _account) external;\n\n    /// Sets the liquidity pool address\n    /// @param _lp address of the liquidity pool of the token\n    function setLP(address _lp) external;\n}\n"
    },
    "contracts/diamond/libraries/LibAccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nlibrary LibAccessControlEnumerable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    bytes32 constant ACCESS_CONTROL_STORAGE_POSITION = keccak256(\"degenx.access.control.storage\");\n\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    struct AccessControlStorage {\n        mapping(bytes32 => RoleData) roles;\n        mapping(bytes32 => EnumerableSet.AddressSet) roleMembers;\n        mapping(bytes4 => bool) supportedInterfaces;\n    }\n\n    function accessControlStorage() internal pure returns (AccessControlStorage storage acs) {\n        bytes32 position = ACCESS_CONTROL_STORAGE_POSITION;\n        assembly {\n            acs.slot := position\n        }\n    }\n\n    function checkRole(bytes32 role) internal view {\n        checkRole(role, msg.sender);\n    }\n\n    function checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    function hasRole(bytes32 role, address account) internal view returns (bool) {\n        AccessControlStorage storage acs = accessControlStorage();\n        return acs.roles[role].members[account];\n    }\n\n    function grantRole(bytes32 role, address account) internal {\n        AccessControlStorage storage acs = accessControlStorage();\n        if (!hasRole(role, account)) {\n            acs.roles[role].members[account] = true;\n            emit RoleGranted(role, account, msg.sender);\n            acs.roleMembers[role].add(account);\n        }\n    }\n\n    function revokeRole(bytes32 role, address account) internal {\n        AccessControlStorage storage acs = accessControlStorage();\n        if (hasRole(role, account)) {\n            acs.roles[role].members[account] = false;\n            emit RoleRevoked(role, account, msg.sender);\n            acs.roleMembers[role].remove(account);\n        }\n    }\n\n    function setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\n        AccessControlStorage storage acs = accessControlStorage();\n        bytes32 previousAdminRole = acs.roles[role].adminRole;\n        acs.roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n}\n"
    },
    "contracts/diamond/libraries/LibFeeStore.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.17;\n\nimport { IERC20Metadata } from \"@solidstate/contracts/token/ERC20/metadata/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@solidstate/contracts/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@solidstate/contracts/interfaces/IERC20.sol\";\n\nimport { LibFeeStoreStorage } from \"./LibFeeStoreStorage.sol\";\nimport { ZeroValueNotAllowed, NotAllowed } from \"./../helpers/GenericErrors.sol\";\nimport { FeeStoreConfig, FeeConfigSyncHomeDTO, FeeConfigSyncHomeFees } from \"./../helpers/Structs.sol\";\n\n/// @title Fee Store Library\n/// @author Daniel <danieldegendev@gmail.com>\n/// @notice Functions to help with the fee store for other instances\nlibrary LibFeeStore {\n    using SafeERC20 for IERC20;\n    uint256 constant DENOMINATOR_RELATIVE = 10 ** 5; // bps denominator\n    uint256 constant DENOMINATOR_ABSOLUTE = 10 ** 4;\n\n    error ZeroFees();\n    error FeeNotExisting(bytes32 id);\n    error FeeExists(bytes32 id);\n\n    event FeeConfigAdded(bytes32 indexed id);\n    event FeeConfigUpdated(bytes32 indexed id);\n    event FeeConfigDeleted(bytes32 indexed id);\n    event FeeConfigMarkedAsDeleted(bytes32 indexed id);\n    event FeesPrepared(uint256 amount, FeeConfigSyncHomeDTO candidate);\n\n    /// Store a specific amount of fees in the store\n    /// @param _feeConfigId fee config id\n    /// @param _amount amount of tokens\n    function putFees(bytes32 _feeConfigId, uint256 _amount) internal {\n        if (_amount == 0) revert ZeroValueNotAllowed();\n        LibFeeStoreStorage.FeeStoreStorage storage s = LibFeeStoreStorage.feeStoreStorage();\n        FeeStoreConfig memory _config = s.feeConfigs[_feeConfigId];\n        if (_config.id == bytes32(\"\")) revert NotAllowed();\n        s.collectedFees[_config.id] += _amount;\n        s.collectedFeesTotal += _amount;\n    }\n\n    /// Prepares the fees collected on the store to be send to the home chain\n    /// @return _dto the dto that will be used on the home chain for receiving and process fees\n    /// @dev this method will also clean up every fee collected and sets it to 0\n    function prepareToSendFees() internal returns (FeeConfigSyncHomeDTO memory _dto) {\n        LibFeeStoreStorage.FeeStoreStorage storage s = LibFeeStoreStorage.feeStoreStorage();\n        if (s.collectedFeesTotal == 0) revert ZeroFees();\n\n        uint256 _feeIndex = 0;\n        uint256 _noOfExpectedFees = 0;\n\n        // get how many fees need to get sent\n        for (uint256 i = 0; i < s.feeConfigIds.length; ) {\n            if (s.collectedFees[s.feeConfigIds[i]] > 0) _noOfExpectedFees++;\n            unchecked {\n                i++;\n            }\n        }\n\n        // collect amounts and gathers configs\n        _dto.fees = new FeeConfigSyncHomeFees[](_noOfExpectedFees);\n        for (uint256 i = 0; i < s.feeConfigIds.length; ) {\n            bytes32 _id = s.feeConfigIds[i];\n            if (s.collectedFees[_id] > 0) {\n                uint256 _amount = s.collectedFees[_id];\n                s.collectedFees[_id] = 0;\n                if (s.feeConfigs[_id].deleted) deleteFee(_id);\n                _dto.totalFees += _amount;\n                _dto.fees[_feeIndex] = FeeConfigSyncHomeFees({ id: _id, amount: _amount });\n                unchecked {\n                    _feeIndex++;\n                }\n            }\n            unchecked {\n                i++;\n            }\n        }\n        s.collectedFeesTotal = 0;\n        emit FeesPrepared(_dto.totalFees, _dto);\n    }\n\n    /// Removes a fee from the store\n    /// @param _id fee id\n    /// @dev if a fee is still in use, it will be marked as deleted. Once fees get moved to home chain, it will be deleted properly\n    function deleteFee(bytes32 _id) internal {\n        LibFeeStoreStorage.FeeStoreStorage storage s = LibFeeStoreStorage.feeStoreStorage();\n        if (s.feeConfigs[_id].id == bytes32(0)) revert FeeNotExisting(_id);\n        if (s.collectedFees[_id] > 0) {\n            s.feeConfigs[_id].deleted = true;\n            emit FeeConfigMarkedAsDeleted(_id);\n        } else {\n            delete s.collectedFees[_id];\n            delete s.feeConfigs[_id];\n            for (uint256 i = 0; i < s.feeConfigIds.length; ) {\n                if (s.feeConfigIds[i] == _id) {\n                    s.feeConfigIds[i] = s.feeConfigIds[s.feeConfigIds.length - 1];\n                    break;\n                }\n                unchecked {\n                    i++;\n                }\n            }\n            s.feeConfigIds.pop();\n            emit FeeConfigDeleted(_id);\n        }\n    }\n\n    /// Adds a fee to the store\n    /// @param _id fee id\n    /// @param _fee fee value\n    /// @param _target the target address\n    function addFee(bytes32 _id, uint256 _fee, address _target) internal {\n        LibFeeStoreStorage.FeeStoreStorage storage s = LibFeeStoreStorage.feeStoreStorage();\n        if (s.feeConfigs[_id].id != bytes32(0)) revert FeeExists(_id);\n        s.feeConfigs[_id] = FeeStoreConfig({ id: _id, fee: _fee, target: _target, deleted: false });\n        s.feeConfigIds.push(_id);\n        emit FeeConfigAdded(_id);\n    }\n\n    /// Updates a fee on the store\n    /// @param _id fee id\n    /// @param _fee fee value\n    /// @param _target the target address\n    function updateFee(bytes32 _id, uint256 _fee, address _target) internal {\n        LibFeeStoreStorage.FeeStoreStorage storage s = LibFeeStoreStorage.feeStoreStorage();\n        if (s.feeConfigs[_id].id == bytes32(0)) revert FeeNotExisting(_id);\n        s.feeConfigs[_id] = FeeStoreConfig({ id: _id, fee: _fee, target: _target, deleted: false });\n        emit FeeConfigUpdated(_id);\n    }\n\n    /// viewables\n\n    /// Calculates the relative fee based on the inserted amount\n    /// @param _feeConfigId fee config id\n    /// @param _asset address of the token\n    /// @param _amount amount that fees are based on\n    /// @return _amountNet amount excluding fee\n    /// @return _fee amount of fee\n    /// @return _feePoints fee value that is applied\n    function calcFeesRelative(\n        bytes32 _feeConfigId,\n        address _asset,\n        uint256 _amount\n    ) internal view returns (uint256 _amountNet, uint256 _fee, uint256 _feePoints) {\n        return calcFees(_feeConfigId, _asset, _amount, false);\n    }\n\n    /// Calculates the absolute fee based on the inserted amount\n    /// @param _feeConfigId fee config id\n    /// @param _asset address of the token\n    /// @param _amount amount that fees are based on\n    /// @return _amountNet amount excluding fee\n    /// @return _fee amount of fee\n    /// @return _feePoints fee value that is applied\n    function calcFeesAbsolute(\n        bytes32 _feeConfigId,\n        address _asset,\n        uint256 _amount\n    ) internal view returns (uint256 _amountNet, uint256 _fee, uint256 _feePoints) {\n        return calcFees(_feeConfigId, _asset, _amount, true);\n    }\n\n    /// Calculates the relative or absolute fees based on the inserted amount\n    /// @param _feeConfigId fee config id\n    /// @param _asset address of the token\n    /// @param _amount amount that fees are based on\n    /// @param _absolute whether a calculation is relative or absolute\n    /// @return _amountNet amount excluding fee\n    /// @return _fee amount of fee\n    /// @return _feePoints fee value that is applied\n    function calcFees(\n        bytes32 _feeConfigId,\n        address _asset,\n        uint256 _amount,\n        bool _absolute\n    ) internal view returns (uint256 _amountNet, uint256 _fee, uint256 _feePoints) {\n        if (_amount == 0) revert ZeroValueNotAllowed();\n        LibFeeStoreStorage.FeeStoreStorage storage s = LibFeeStoreStorage.feeStoreStorage();\n        FeeStoreConfig memory _config = s.feeConfigs[_feeConfigId];\n        if (_config.id == bytes32(\"\")) return (_amount, 0, 0);\n        _feePoints = _config.fee;\n        _fee = _absolute\n            ? ((_feePoints * (10 ** IERC20Metadata(_asset).decimals())) / DENOMINATOR_ABSOLUTE)\n            : ((_amount * _feePoints) / DENOMINATOR_RELATIVE);\n        _amountNet = _amount - _fee;\n    }\n\n    function getOperator() internal view returns (address _operator) {\n        LibFeeStoreStorage.FeeStoreStorage storage s = LibFeeStoreStorage.feeStoreStorage();\n        _operator = s.operator;\n    }\n\n    function setOperator(address _operator) internal {\n        LibFeeStoreStorage.FeeStoreStorage storage s = LibFeeStoreStorage.feeStoreStorage();\n        s.operator = _operator;\n    }\n\n    function getIntermediateAsset() internal view returns (address _intermediateAsset) {\n        LibFeeStoreStorage.FeeStoreStorage storage s = LibFeeStoreStorage.feeStoreStorage();\n        _intermediateAsset = s.intermediateAsset;\n    }\n\n    function setIntermediateAsset(address _intermediateAsset) internal {\n        LibFeeStoreStorage.FeeStoreStorage storage s = LibFeeStoreStorage.feeStoreStorage();\n        s.intermediateAsset = _intermediateAsset;\n    }\n}\n"
    },
    "contracts/diamond/libraries/LibFeeStoreStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.19;\n\nimport { FeeStoreConfig } from \"./../helpers/Structs.sol\";\n\nlibrary LibFeeStoreStorage {\n    bytes32 constant FEE_STORE_STORAGE_POSITION = keccak256(\"degenx.fee-store.storage.v1\");\n\n    struct FeeStoreStorage {\n        // feeConfigId => FeeStoreConfig\n        mapping(bytes32 => FeeStoreConfig) feeConfigs;\n        // feeConfigId => amount of fees collected\n        mapping(bytes32 => uint256) collectedFees;\n        // represents a sum of each amount in collectedFees\n        uint256 collectedFeesTotal;\n        bytes32[] feeConfigIds;\n        address operator;\n        address intermediateAsset;\n    }\n\n    function feeStoreStorage() internal pure returns (FeeStoreStorage storage fss) {\n        bytes32 position = FEE_STORE_STORAGE_POSITION;\n        assembly {\n            fss.slot := position\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 99999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}